[{"title":"与青春有关的日子（2001&2011）十年纪之全明星","url":"/blog/2011/02/24/iverson-2001-2011/","content":"\n没有奇迹。纵使勒布朗·詹姆斯率东部“殊死”抵抗一番，依旧未能填平那将近20分的沟壑。终于，有人怀念起十年以前，那个与世界为敌，狂妄得无法无天的小子来了。“我离开后，你们才会真正明白我的价值。”我们的艾如是说道。\n\n\n还记得那时的全明星吗？尚在湖人的沙克，梳着辫子头的天尊，拄着双拐的希尔，笑容灿烂的马布里，引爆全场的卡特，顶着怪异头型的科比，一副无所谓表情的麦迪，以及，那时风华绝代的阿伦艾弗森。那些是时代的宠儿。他们不知道未来的命运，不知道沙克会与科比闹翻，不知道希尔把最好的年华献给了队医，不知道卡特有一天失去翅膀也会泯然众人，不知道马布里会被视为球队毒药，不知道麦迪会被带上“软”与“炸伤”的帽子，不知道AI有一天会流浪到土耳其，不知道未来的某一天，自己会成为时代的倒影。\n那仅仅是2001年，那时的华盛顿是属于他们的舞台。遥远的十年以前，轻狂的AI连走起路来都放荡不羁。那些个意气风发的少年，一张张微笑的脸，试图把这世界改变。如果有十年前的照片，那一定已经泛黄。只有在比赛录像中，现场DJ充满激情的呼喊才依旧清晰，那些故人的笑容也依然明朗。那总会让我们产生错觉，闭上眼，仿佛一切发生在昨天。心微微的疼，因为那些人已不复当年。\n那是场高低悬殊的比赛，至少东部七名队员身高都不足两米，所有人都觉得他们不够强壮，无法取得比赛的胜利。只是，AI与马布里联手向世界证明了，胜利与身体无关，与之有关的，只是——心！那颗为胜利而跳动的心脏。于是造就了如此一场惊心动魄荡气回肠的比赛。看看今年的全明星，再与十年前做对比，你就会发现，一代人已经走向妥协，这个世界的反面英雄已经几乎绝迹。再也没有人会在落后二十几分时依旧骄傲的说我们会赢了；再也没有人可以那么勇敢地站在权威的背面了；再也没有人会玩世不恭地对这个世界竖起中指了。十年过去了，那时叱咤风云的人物都离开了。但使龙城飞将在，不教胡马度阴山。\n但，当年轻的球员们看到阿伦艾弗森与世界为敌后的下场时，恐怕已经没有多少人愿意和他再走上同一条道路。那种坚持与忠诚，执着与顽强，反抗与斗争，那首属于英雄的赞歌再也不会在NBA响起了，这个世界也许还需要个人英雄主义，只是没有人愿意去做那个英雄了。单挑篮球之神，全明星逆转，总决赛与繁华的洛杉矶为敌，纹身，嘻哈，垄沟头，轻描淡写，不爱训练，我行我素，史诗般的对决，胜利失败，爱与恨。再也没有人可以承受这一切了。答案，真的无法被取代。阿伦艾弗森走的，的确是一条前无古人后无来者的道路，因为再也没有人还有勇气如他一般。单凭这一点，他所做的一切，就值得所有人，脱帽致敬。\n所以，纵使上赛季被球队裁掉，老将底薪，球队备胎，依旧全明星。你所做的事情，权威不喜欢，我们却深爱。那些传奇，权威可以淡漠，我们却会铭记。无论你是无限风光如日中天，还是黯然神伤举步维艰，我们都站在你的身后。你是我们无法消散的光芒，你是我们此生不变的信仰。\n无论未来有多远，我们等你。\n\n作者简介骄傲的狮子座,喜欢笑,喜欢明亮到刺眼的阳光,喜欢初春时节融化的冰雪，喜欢湛蓝色的天空，喜欢一生都在飞翔的北极燕鸥，喜欢伤感的文字,喜欢动人的故事,喜欢费城，此生挚爱 Allen Iverson。\n笔者附言嘿嘿，偷偷搬运下！不要让原作者发现！(●’◡’●)（2016-11-22 16:10:55）\n\n","categories":["艾已成诗"],"tags":["艾弗森","艾已成诗","全明星","流年"]},{"title":"Hexo 使用总结 & 常见问题","url":"/blog/2016/04/25/hexo-faq/","content":"\n前言Hexo 是一个非常简洁的静态博客框架，可以快速的搭建生成自己的博客，但是在使用中总会遇到各种各样奇怪的错误，在这里我整理一下我所遇到的错误和一些使用技巧等等，也欢迎各位读者对使用技巧和使用问题进行补充。如果有什么问题也可以随时在下方提问。\n注意：\n\n_config.yml 文件在项目下有两个，一个在博客根目录下，一个在主题目录下。我在文中会用 站点配置文件 和 主题配置文件 区分。\n本博客使用的是 NexT 主题，某些设置可能与主题有关。\n\n\n\n不渲染 md 或者 html我们知道，在 source 文件夹下的所有 md 文件或者 html 文件都会被渲染，有时候我们不想这些文件被渲染怎么办？比如很多时候我们想要写一个 README.md 或者一些自定义的页面。比如百度或者谷歌在验证站长权限的时候，通常都会要求在主目录下添加一个 html 文件。\n不渲染 html 文件在不想被渲染的 html 文件最上面添加如下代码\n---layout: false---\n\n不渲染 md 文件使用上面的办法虽然不会渲染 md 文件，但是还是将 md 文件转化成了 html 文件，如果想保留原 md 文件后缀要怎么做呢？这就需要在 站点配置文件 _config.yml 中配置，找到 skip_render 参数，开始匹配的位置是基于你的 source_dir 的，一般来说，是你的 source 文件夹下。下面我分别列举几种常见的情况进行说明：\n\nskip_render: test/*    单个文件夹下全部文件\nskip_render: test/*.md 单个文件夹下指定类型文件\nskip_render: test/**   单个文件夹下全部文件以及子目录\n多个文件夹以及各种复杂情况：_config.ymlskip_render:  - `test1/*.html`  - `test2/**`\n\n\n\n首页文章显示查看原文按钮我们常常想在首页只显示文章的概述，而不是文章的全部，用一个 阅读全文 的字样代替，要怎么做呢？如下图：\n\n\n在文章中只要写成如下格式即可：\n这是摘要&lt;!-- more --&gt;这是全文\n\n需要注意的是，点击 阅读全文 之后，文章会自动定位到 &lt;!-- more --&gt; 所在位置，想要修改成从头阅读需要修改 主题配置文件 _config.yml：\n_config.yml# Automatically scroll page to section which is under &lt;!-- more --&gt; mark.scroll_to_more: false // NexT v7版本已经不支持\n\n配置 SSH 公钥免部署输入密码_config.yml# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy:  type: git  repo:    github: git@github.com:cylong1016/cylong1016.github.io.git # Github SSH    # github: https://github.com/cylong1016/cylong1016.github.io.git # Github HTTPS    coding: git@git.coding.net:cylong1016/cylong1016.git # Coding SSH    # coding: https://git.coding.net/cylong1016/cylong1016.git # Coding HTTPS  branch: master\n\n上面的代码是 站点配置文件 _config.yml 中的配置，分别是部署到 Github 和 Coding 上的两种方式，使用 HTTPS 方式的话每次部署都需要输入用户名和密码，很麻烦。\n\n所以我选择使用 SSH 的方式，此方式是本机与远程仓库建立对接，这样部署的时候就不需要输入用户名和密码了。但是需要以下的配置：\n\n打开终端或者 Git Bash，依次输入：mkdir ~/.ssh    # 如果之前没有这个文件夹就创建此文件夹cd ~/.ssh       # 进入到 .ssh 文件夹中ssh-keygen -t rsa -C &quot;youremail@example.com&quot;    # 生成密钥# 接着会提示输入 file 和 passphrase，直接回车就行。# 接着会看到下面的输出：Your identification has been saved in /home/cylong/.ssh/id_rsa.Your public key has been saved in /home/cylong/.ssh/id_rsa.pub.The key fingerprint is:fd:56:db:23:db:bf:df:54:0a:6a:43:51:13:34:22:b6 youremail@example.com# 接着输入ssh-add ~/.ssh/id_rsa\n打开 https://github.com/settings/ssh（Github），点击 New SSH key，复制 id_rsa.pub 中的所有内容到 Key 框中，在 Title 框中输入方便自己记忆的名字（比如我的是 Personal Ubuntu）。https://coding.net/user/account/setting/keys（Coding）也一样，但是需要注意的是注册邮箱要一样，否则要两个 SSH。\n输入 ssh -T git@github.com 和 ssh -T git@git.coding.net 测试是否配置成功。\n\n参考：使用 Github SSH Key 以免去 Hexo 部署时输入密码 | Xuanwo’s Blog\n使用 Fort Awesome 图标我们知道，在我们写博客的时候，博客文件，或者自己自定义的页面，比如关于页面，都是 md 文件。最后会转化成 Html 文件。但是所支持的标签还是没有 Html 的全面，不过我们可以直接在 md 文件中写 Html 标签，比如：\n&lt;del&gt;你什么都没有看见&lt;/del&gt;\n\n当然，你可以直接使用 Fort Awesome 图标，下面是我在 关于 页面写的代码：\n&lt;span class=&quot;fa fa-envelope&quot;&gt;&lt;/span&gt; 邮箱：chenyunlong1016@gmail.com&lt;span class=&quot;fab fa-weixin&quot;&gt;&lt;/span&gt; 微信：cylong1016\n\nUbuntu 下使用 Hexo辗转反侧，还是忍不住使用 Ubuntu 系统。而且基本所有的人都和我说以后的开发都要使用 Linux 系统。所以最近准备使用 Ubuntu 练手，当然，博客也要在 Ubuntu 上更新了。由于我的博客已经在 Windows 系统下搭建好了，教程参考 Hexo + Git 搭建免费的个人博客 | 笑话人生 （虽然是 Windows 下的教程，但是其他平台步骤都是一样的）。Hexo 源码放在 GitHub | HexoBlog 上。所以直接 clone 下来就好。下面就说说我在 Ubuntu 系统下遇到的问题。\n\n在执行 npm 命令时出现以下错误：\nsh: 1: node: not foundnpm WARN This failure might be due to the use of legacy binary &quot;node&quot;npm WARN For further explanations, please read/usr/share/doc/nodejs/README.Debian\n解决办法，执行以下命令：\nsudo apt-get install nodejs-legacy\n详情请参考：\n\nCannot install packages using node package manager in Ubuntu | Stack OverflowWhat are the differences between node.js and node | Stack OverflowCannot install hexo in Ubuntu 14.04 #580 | hexojs/hexo\n\n\n执行 hexo 命令时出现以下错误：\nFATAL Cannot find module &#x27;/home/cylong/Github/HexoBlog/node_modules/hexo-deployer-git&#x27;\n原因是没有 hexo-deployer-git module。执行以下命令安装：\nnpm install hexo-deployer-git\n\n可以正常执行 hexo 命令，但是会出现下面的警告：\nNative thread-sleep not available.This will result in much slower performance, but it will still work.You should re-install spawn-sync or upgrade to the lastest version of node if possible.Check /usr/local/lib/node_modules/hexo-cli/node_modules/hexo-util/node_modules/cross-spawn/node_modules/spawn-sync/error.log for more details\n解决办法如上警告所说，升级 node.js。\nsudo npm cache clean -fsudo npm install -g nsudo n stable\n详情请参考：How do I update Node.js | Stack Overflow\n\n执行 hexo g 无法部署到 Github 上，出现如下错误：\nPermission denied (publickey).fatal: Could not read from remote repository.Please make sure you have the correct access rightsand the repository exists.FATAL Something&#x27;s wrong. Maybe you can find the solution here: https://hexo.io/docs/troubleshooting.htmlError: Permission denied (publickey).fatal: Could not read from remote repository.Please make sure you have the correct access rightsand the repository exists.\n解决办法，请参考：配置 SSH 公钥免去部署的时候输入密码\n\n\nNexT 添加版权声明\n修改 主题配置文件 _config.yml，开启版权声明：_config.yml# Creative Commons 4.0 International License.# See: https://creativecommons.org/share-your-work/licensing-types-examples# Available values of license: by | by-nc | by-nc-nd | by-nc-sa | by-nd | by-sa | zero# You can set a language value if you prefer a translated version of CC license, e.g. deed.zh# CC licenses are available in 39 languages, you can find the specific and correct abbreviation you need on https://creativecommons.orgcreative_commons:  license: by-nc-sa  sidebar: true  post: true  language:\n默认的配置只有 本文作者、本文链接、版权声明 三个字段，于是我又新增了 本文标题 字段，首先修改 NexT 主题下的 \\layout\\_partials\\post\\post-copyright.swig 文件，添加 本文标题 字段，并将作者信息增加跳转链接：&#123;%- set ccIcon = &#x27;&lt;i class=&quot;fab fa-fw fa-creative-commons&quot;&gt;&lt;/i&gt;&#x27; %&#125;&#123;%- set ccText = theme.creative_commons.license | upper %&#125;&lt;div&gt;&lt;ul class=&quot;post-copyright&quot;&gt;  &lt;li class=&quot;post-copyright-title&quot;&gt;    &lt;strong&gt;&#123;&#123; __(&#x27;post.copyright.title&#x27;) + __(&#x27;symbol.colon&#x27;) &#125;&#125;&lt;/strong&gt;    &#123;&#123; next_url(page.permalink, page.title, &#123;title: page.title&#125;) &#125;&#125;  &lt;/li&gt;  &lt;li class=&quot;post-copyright-author&quot;&gt;    &lt;strong&gt;&#123;&#123; __(&#x27;post.copyright.author&#x27;) + __(&#x27;symbol.colon&#x27;) &#125;&#125; &lt;/strong&gt;    &#123;&#123; next_url(&quot;/about/&quot;, page.author or author, &#123;title: page.author or author&#125;) &#125;&#125;  &lt;/li&gt;  &lt;li class=&quot;post-copyright-link&quot;&gt;    &lt;strong&gt;&#123;&#123; __(&#x27;post.copyright.link&#x27;) + __(&#x27;symbol.colon&#x27;) &#125;&#125;&lt;/strong&gt;    &#123;&#123; next_url(page.permalink, page.permalink, &#123;title: page.title&#125;) &#125;&#125;  &lt;/li&gt;  &lt;li class=&quot;post-copyright-license&quot;&gt;    &lt;strong&gt;&#123;&#123; __(&#x27;post.copyright.license_title&#x27;) + __(&#x27;symbol.colon&#x27;) &#125;&#125; &lt;/strong&gt;    &#123;&#123;- __(&#x27;post.copyright.license_content&#x27;, next_url(ccURL, ccIcon + ccText)) &#125;&#125;  &lt;/li&gt;&lt;/ul&gt;&lt;/div&gt;\n再修改 \\languages\\zh-CN.yml 中的版权声明文案配置：copyright:  title: 本文标题  author: 本文作者  link: 本文链接  license_title: 版权声明  license_content: &quot;本博客所有文章除特别声明外，均采用 %s 许可协议。转载请注明出处 &lt;span class=\\&quot;far fa-laugh-beam\\&quot;&gt;&lt;/span&gt;&quot;\n效果如下：\nBY-NC-SA 参考：CC BY-NC-SA 4.0 DEED | 署名-非商业性使用-相同方式共享 4.0 国际\n参考：版权信息 | Hexo-NexT\n\nNexT 添加字数统计和阅读时长\n安装 npm 包\n\nnpm install hexo-symbols-count-time\n\n\n修改 站点配置文件 _config.yml\n\nsymbols_count_time:  symbols: true             # 文章字数统计  time: true                # 文章阅读时长  total_symbols: true       # 站点总字数统计  total_time: true          # 站点总阅读时长  exclude_codeblock: false  # 排除代码字数统计  awl: 4                    # 平均字长（字中的字符数）  wpm: 275                  # 每分钟阅读字数  suffix: &quot;mins.&quot;\n\n\n修改 NexT 主题的 _config.yml 文件（Next 主题已经支持此插件，仅个性化修改即可）\n\n# Post wordcount display settings# Dependencies: https://github.com/theme-next/hexo-symbols-count-timesymbols_count_time:  separated_meta: true  item_text_post: true  item_text_total: false\n\n\n参考：\ntheme-next/hexo-symbols-count-timeHexo 博客 NexT 主题下添加字数统计和阅读时长 | CSDN 博客\n\n\n\n添加 RSS 订阅\n安装 Feed 插件\nnpm install hexo-generator-feed --save\n\n在 站点配置文件 _config.yml 中添加如下代码：\n_config.ymlfeed:  type: atom  path: atom.xml  limit: 20  hub:\n\n\ntype - 订阅类型 (atom 或 rss2)\npath - 路径 (默认: atom.xml 或 rss2.xml)\nlimit - 最多显示文章数量 (0 或 false 展示所有文章)\nhub - PubSubHubbub hubs 的 URL (PubSubHubbub 是一个“开放的、服务器对服务器、基于Web-hook的发布/订阅协议，是 Atom 和 RSS 的扩展”。不使用就留空)\n\n添加打赏功能NexT 主题支持打赏功能，简单配置即可\n\n获取支付宝和微信的收款二维码，放在 source/images 目录下\n修改 NexT 主题的 _config.yml 文件_config.yml# Reward (Donate)# Front-matter variable (unsupport animation).reward_settings:  # If true, reward will be displayed in every article by default.  enable: true  animation: false  comment: &lt;span class=&quot;fa fa-donate&quot;&gt;&lt;/span&gt; 分享精彩，留下足迹reward:  alipay: /images/alipay.jpg  wechatpay: /images/wechatpay.jpg  #paypal: /images/paypal.png  #bitcoin: /images/bitcoin.png\n重新部署后在文章最下面就会有打赏按钮，赞赏是一种美德，有余力而为之，期待为优质内容付费 \n\n添加网站底部字数统计\n安装 hexo-wordcount 插件\nnpm install hexo-wordcount --save\n\n在 /themes/next/layout/_partials/footer.swig 中最后加上:\n&lt;div class=&quot;theme-info&quot;&gt;  &lt;div class=&quot;powered-by&quot;&gt;&lt;/div&gt;  &lt;span class=&quot;post-count&quot;&gt;博客共&#123;&#123; totalcount(site) &#125;&#125;字&lt;/span&gt;&lt;/div&gt;\n参考：hexo-wordcount\n\n\n部署到 Github 后修改未更新有时候当你 hexo d --g 部署到 Github 的时候，发现有些地方并没有更新，比如你的主题样式。这时候就建议你输入 hexo clean 清除下 public 文件夹下的文件，然后再部署（部署的时候实际上是直接拷贝 public 下的文件的）。另外多说一句，hexo d --g 是以下两个命令的缩写：\nhexo g  # 生成本地 public 静态文件hexo d  # 部署到 Github 上# 也可以缩写成：hexo g --d\n\nLF will be replacedWindows 提交命令的时候出现 warning: LF will be replaced by CRLF in xxx 的警告。输入以下命令即可：\ngit config --global core.autocrlf false\n\nWindows 禁止运行脚本Windows PowerShell 执行命令的时候出现如下错误：\nPS D:\\Github\\HexoBlog&gt; hexo vhexo : 无法加载文件 C:\\Users\\win\\AppData\\Roaming\\npm\\hexo.ps1，因为在此系统上禁止运行脚本。有关详细信息，请参阅 https:/go.microsoft.com/fwlink/?LinkID=135170 中的 about_Execution_Policies。所在位置 行:1 字符: 1+ hexo v+ ~~~~    + CategoryInfo          : SecurityError: (:) []，PSSecurityException    + FullyQualifiedErrorId : UnauthorizedAccess\n\n启动 Windows PowerShell 时，执行策略很可能是 Restricted（默认设置）。\n\nRestricted 执行策略不允许任何脚本运行。AllSigned 和 RemoteSigned 执行策略可防止 Windows PowerShell 运行没有数字签名的脚本。\n\n查看当前执行策略，打开 PowerShell 输入以下命令：\nPS D:\\Github\\HexoBlog&gt; get-executionpolicyRestricted\n\n以管理员身份打开 Windows PowerShell 输入以下命令并输入 Y 即可解决：\nPS C:\\WINDOWS\\system32&gt; set-executionpolicy remotesigned执行策略更改执行策略可帮助你防止执行不信任的脚本。更改执行策略可能会产生安全风险，如 https:/go.microsoft.com/fwlink/?LinkID=135170中的 about_Execution_Policies 帮助主题所述。是否要更改执行策略?[Y] 是(Y)  [A] 全是(A)  [N] 否(N)  [L] 全否(L)  [S] 暂停(S)  [?] 帮助 (默认值为“N”): YPS C:\\WINDOWS\\system32&gt; get-executionpolicyRemoteSigned\n\n参考：PowerShell：因为在此系统上禁止运行脚本，解决方法 | syxdevcode 博客\n更新 tag 大小写后访问 404强迫症的我想修改标签大小写，结果修改完成后发现访问标签链接报 404 错误，查阅资料发现其实是由于 Windows 平台上的 Git，默认设置了大小写不敏感导致的。修改博客根目录的 .deploy_git/.git/config 文件即可解决：\nignorecase = false\n\n参考：\n\nHexo 改变 tag 因为大小写问题而 404 的解决方法 | 张洪HeoHexo 更新 tag 的大小写后标签页出现错误 | Yika`s BlogBUG 反馈：大写开头的标签出现 404 #818 | hexojs/hexo\n\n感谢\nHexo 常见问题解决方案 | Xuanwo’s BlogHexo 搭建个人博客系列：进阶设置篇 | 个人日记生生之境 提出的各种【高智商 (●’◡’●)】问题\n\n参考资料\nHexo + Git 搭建免费的个人博客 | 笑话人生Hexo 中文文档（包含：文档、API、插件、主题）NexT 使用文档（包含：开始使用、主题配置、第三方服务、内建标签、常见问题）Feed generator for Hexohexo-wordcount\n\n\n","categories":["Hexo"],"tags":["Hexo","Next"]},{"title":"Hexo + Git 搭建免费的个人博客","url":"/blog/2016/04/19/hexo-git/","content":"\n前言个人博客日益流行，大家都开始搭建自己的博客，记录成长中学习中的点点滴滴，最近觉得自己也需要有一个平台整理自己的所学所想，于是用了将近3天的时间 (实际上一天就能搞定的！) 使用 Hexo + Git 搭建了自己的个人博客，提高自己的学习动力，没事的时候可以拿出来温习下，提高下本人的渣渣水平。目前仍有很多功能没有添加，留着日后慢慢完善。准备将自己的第一篇博客献给 Hexo，表示对 Hexo 的感谢。下面详细介绍下搭建流程，有任何不懂的问题欢迎 联系我 或者在下面评论。另外个人能力有限，接受任何建议或者吐槽！共同进步 (●’◡’●)。\n\nHexo 简介大家所熟悉的博客框架莫过于 Wordpress，还有 Jekyll 等，博主在查阅了大量资料后选择了 Hexo，Hexo 是一个快速、简洁且高效的博客框架。可以方便快捷的生成博客网页。Hexo 由台湾大学生 tommy351 开发，是一个基于 Node.js 的静态博客程序。支持多种主题，博主选择的是 NexT 主题。使用 Hexo + Git 搭建博客不需要购买域名和服务器，由 GitHub 提供域名和网站页面空间。\n安装 Hexo注意: 本文针对 Windows 平台和 Hexo 3.x 【其实后来我也在 Ubuntu 上试了一下，完全一样的】\n准备在安装 Hexo 之前，请确认你已经安装了以下程序：\n\n  Node.js\n  Git\n\n安装在自己认为合适的地方创建一个文件夹作为博客项目的目录，进入文件夹，然后鼠标右键选择 Git Bash Here，依次输入：\nnpm install -g hexo-clinpm install hexo --savenpm install hexo-renderer-swig # Hexo 5.0 版本之后手动安装swig渲染器，部分主题需要hexo -v # 查看版本\n\n输入 hexo -v 后输出以下内容表示安装成功了(可能版本有差别)：\n$ hexo -vhexo: 3.2.0hexo-cli: 1.0.1os: Windows_NT 10.0.10586 win32 x64http_parser: 2.5.2node: 4.4.2v8: 4.5.103.35uv: 1.8.0zlib: 1.2.8ares: 1.10.1-DEVicu: 56.1modules: 46openssl: 1.0.2g\n\n体验 Hexo接下来在当前的博客目录下，依次输入：\nhexo init   # 初始化组件npm install\n\n之后 npm 将会自动安装你需要的组件，只需要等待 npm 操作即可。接着输入：\nhexo shexo s --debug # debug模式\n\n输出：\nINFO  Start processingINFO  Hexo is running at http://localhost:4000/. Press Ctrl+C to stop.\n\n说明你的博客可以在本地访问啦，打开浏览器输入 http://localhost:4000/ 试试看吧~\nHexo 使用下面让我们创建第一篇文章吧，输入：\nhexo n my-first   # 生成文章，或者 source\\_posts 手动编辑\n\n之后查看 source\\_posts 下面就会出现 my-first.md， 编辑这个文件就是在编辑你的这篇博客，完成保存后输入：\nhexo g # 生成 public 静态文件，这步不是必须的，当你需要生成的 Html 页面的时候输入这行代码hexo s # 启动服务器，查看本地效果\n\n浏览器中输入 http://localhost:4000/ 就会看到你刚刚编辑的博客了，如果发现无法访问的情况，可能是因为端口被占用或者你启用了代理【关掉就好】，运行如下命令修改端口：\nhexo server -p 5000 # 5000为你想要修改的端口号\n\n在服务器启动期间，Hexo 会监视文件变动并自动更新，您无须重启服务器。更多博客编辑技巧请参照 Hexo 中文文档\n部署到 GitHub创建代码仓库首先你需要一个 GitHub 账号，然后创建一个仓库，仓库名是 yourname.github.io， 比如我的是 cylong1016.github.io。\n开启 gh-pages 功能创建完成后点击界面右侧的 Settings，向下拖动，直到看见 GitHub Pages ，点击 Automatic page generator，Github 将会自动替你创建出一个 gh-pages 的页面。如果你的配置没有问题，那么大约15分钟之后，http://cylong1016.github.io 这个网址就可以正常访问了~之后打开本地博客目录下的 _config.yml 文件，最下面找到 Deployment ， 做如下修改：\n_config.ymldeploy:  type: git  repo: https://github.com/cylong1016/cylong1016.github.io.git  # cylong1016改成你的用户名  branch: master\n\n接着在 Git Bash 中依次输入：\nnpm install hexo-deployer-git --save    # 安装使用 git 方式进行部署所需要的插件hexo d                # 部署到 GitHub 上，按照提示输入自己 GitHub 的用户名和密码。\n\n部署会强制覆盖掉你之前生成的页面，在博客的目录下会产生 .deploy_git文件夹，不要删除，否则你的部署记录就会不见。之后就可以通过 http://cylong1016.github.io (cylong1016 替换成你的用户名)访问你的网站啦。在之后的部署时，建议输入以下代码:\nhexo clean  # 清除之前 public 文件夹的内容hexo g      # 生成静态的 public 文件夹，部署时候也是直接拷贝此文件夹里的文件。hexo d      # 部署到 GitHub 上，按照提示输入自己 GitHub 的用户名和密码。# hexo g 和 hexo d 这两条命令可以合并成 hexo d --g 或者 hexo g --d\n\n更换主题你可以在 Themes - Hexo 找到你喜欢的主题下载下来，放在博客目录下的 themes 目录下，之后修改 _config.yml 文件：\n_config.yml# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: next # 修改成你的主题文件夹名\n\nHexo 默认主题是 landscape，我使用的是 Next 主题，也是强烈推荐的，简洁、扁平化主题风格是我最喜欢的。配置使用 NexT 主题请参考：\n\nNexT 主题中文文档\n\n本来想单独写一个博客讲述主题方面的配置，不过这些都有官方文档，写的也都很详细，没必要做文章的搬运工(明明是博主很懒！)。如果有问题欢迎在下面提问 (●’◡’●)\n使用自己的域名购买域名首先你需要一个域名。可以在 万网 或者 GoDaddy 购买，我的域名是在万网买的。【好不容易抢到 cylong.com 这个域名，之前被人注册了，不过在16年2月份的时候就过期了，哈哈哈】\n设置 CNAME在博客目录下的 source 文件夹下，创建一个名称为 CNAME 的文件，内容为你的域名，比如我的是:\nsource/CNAMEwww.cylong.com\n\n注意： CNAME 文件是不带后缀的。另外带 www 和不带 www，虽然用户在访问的时候网页内容是一样的，但是搜索引擎却认为是两个网页，最好自己选择一个首选域。更多详情请参考：网站首选域 | 笑话人生\n域名解析简单来说就是让你的网站和你购买的域名对应起来。万网提供免费的 DNS 解析服务。也可以使用 DNSPod 的服务，但是要在域名注册商修改 DNS 服务地址为：\nf1g1ns1.dnspod.netf1g1ns2.dnspod.net\n\n我在万网购买的域名，所以直接进行解析配置【默认使用万网的 DNS 解析服务，没有使用 DNSPod 的服务】。配置过程如下：\n\n登陆 万网。\n点击最上面的 管理控制台，再点击左侧的 云解析。或者直接点击首页查询域名框下面的常用链接：域名解析。\n选择你要解析的域名，点击域名后面的 解析。\n解析配置如下：\n\n\n\n设置解析后大约几分钟就可以通过你的域名访问你的网站啦，如果你修改了 DNS 服务器，解析一般最长需要48小时生效。耐心等待吧~\n感谢\n史上最详细的 Hexo 博客搭建图文教程 | Xuanwo’s Blog使用 GitHub 和 Hexo 搭建免费静态Blog | HelloDog\n\n参考资料\nHexo 中文文档NexT 主题中文文档Hexo 使用总结 &amp; 常见问题分类：Hexo | 笑话人生\n\n\n","categories":["Hexo"],"tags":["Hexo","Next","Git","Node.js","GitHub"]},{"title":"Hexo 集成多说评论 + 多说分享 + 美化多说","url":"/blog/2016/04/25/hexo-next-duoshuo/","content":"\n多说简介多说是一款追求极致体验的社会化评论框，可以用微博、QQ、人人、豆瓣等帐号登录并评论。功能强大且永久免费。Hexo 默认使用的评论插件是国外的 Disqus，。对于国内来说，使用多说无非是最好的。这篇文章就介绍下如何在 Hexo 中添加多说评论插件和多说 CSS 的美化，顺便说一下多说分享插件。至于如何搭建 Hexo 博客请参考：\n\nHexo + Git 搭建免费的个人博客 \n\n\n\n集成多说注意: 我使用的是 NexT 主题，集成多说插件非常简单，这也是我喜欢这个主题的原因，简单、高效。其他主题的配置需要你们自己研究了，不过都差不多的。NexT 主题更多第三方服务请参考：\n\n第三方服务集成 - NexT 使用文档\n\nNexT 主题下面说一下 NexT 主题如何集成多说。首先要在 多说 创建一个站点，具体步骤如下：\n\n登录后在首页选择 “我要安装”。\n创建站点，填写表单。如图：\n在博客站点配置文件 _config.yml 中添加如下代码：# 多说评论功能duoshuo_shortname: xxx # 你填写在多说域名中的值# 多说分享服务，必须与多说评论同时使用duoshuo_share: true\n启用后默认在所有页面都会显示多说评论框，比如分类页面、标签页面、自定义的关于页面，如果不想在这些页面显示评论框，找到对应的index.md文档，在Front-matter(文件最上方以 --- 分隔的区域)中加入 comments: false 这一行代码就行了\n\nLandscape 主题顺便说一下 Hexo 默认的 Landscape 主题如何集成多说，具体步骤如下：\n\n与上面相同\n修改 themes\\landscape\\layout\\_partial\\article.ejs 模板，把：\n\n&lt;% if (!index &amp;&amp; post.comments &amp;&amp; config.disqus_shortname)&#123; %&gt;&lt;section id=&quot;comments&quot;&gt;    &lt;div id=&quot;disqus_thread&quot;&gt;        &lt;noscript&gt;Please enable JavaScript to view the &lt;a href=&quot;//disqus.com/?ref_noscript&quot;&gt;comments powered by Disqus.&lt;/a&gt;&lt;/noscript&gt;    &lt;/div&gt;&lt;/section&gt;&lt;% &#125; %&gt;\n\n改为：\n&lt;% if (!index &amp;&amp; post.comments &amp;&amp; config.duoshuo_shortname)&#123; %&gt;&lt;section id=&quot;comments&quot;&gt;    &lt;!-- 多说评论框 start --&gt;    &lt;div class=&quot;ds-thread&quot;        data-thread-key=&quot;&lt;%= post.layout %&gt;-&lt;%= post.slug %&gt;&quot;        data-title=&quot;&lt;%= post.title %&gt;&quot;        data-url=&quot;&lt;%= page.permalink %&gt;&quot;&gt;    &lt;/div&gt;    &lt;!-- 多说评论框 end --&gt;    &lt;!-- 多说公共JS代码 start (一个网页只需插入一次) --&gt;    &lt;script type=&quot;text/javascript&quot;&gt;        var duoshuoQuery = &#123;short_name:&#x27;&lt;%= config.duoshuo_shortname %&gt;&#x27;&#125;;        (function() &#123;            var ds = document.createElement(&#x27;script&#x27;);            ds.type = &#x27;text/javascript&#x27;;ds.async = true;            ds.src = (document.location.protocol == &#x27;https:&#x27; ? &#x27;https:&#x27; : &#x27;http:&#x27;) + &#x27;//static.duoshuo.com/embed.js&#x27;;            ds.charset = &#x27;UTF-8&#x27;;            (document.getElementsByTagName(&#x27;head&#x27;)[0] || document.getElementsByTagName(&#x27;body&#x27;)[0]).appendChild(ds);        &#125;)();    &lt;/script&gt;    &lt;!-- 多说公共JS代码 end --&gt;&lt;/section&gt;&lt;% &#125; %&gt;\n\n美化多说多说设置登陆 多说，点击后台管理，在设置中修改，包括基本设置、自定义文本、默认头像、外观主题。如图：\n\n\n自定义多说分享图标多说提供很多平台的分享服务，有时候我们肯能并不需要这么多，要如何修改呢？首先，进入到 themes\\next\\layout\\_partials\\share\\duoshuo_share.swig ，在这里就可以修改图标，至于都有什么图标，请参考：\n\n多说分享组件自定义图标 - 多说开发者中心\n\n多说评论显示 UA在每一条多说评论后显示评论者所使用的代理信息（如 操作系统、浏览器），效果如下：\n\n\n启用此功能，需要编辑主题配置文件 _congig.yml 如下：\n# Make duoshuo show UA# user_id must NOT be null when admin_enable is true!# you can visit http://dev.duoshuo.com get duoshuo user id.duoshuo_info:  ua_enable: true  admin_enable: true  user_id: xxxxxx  admin_nickname: 权限汪\n\n只要设置 ua_enable 为 true 即可显示 UA 信息。 admin_enable 是用于显示 博主 文字，表明评论者是博主【默认显示的是博主，我给改成权限汪了】，此字段需要同时配置 user_id。 请访问 多说开发者中心，登录并访问 我的主页 获取 user_id ， 此 ID 是网址最后那串数字。\n自定义 CSS登陆 多说，点击后台管理，在 设置/基本设置/自定义CSS 中可以修改多说的 CSS 样式，如图：\n\n\n我的修改如下（可以使用键盘上的上下左右查看看不到的代码）：\n/* 设置圆形头像 */#ds-reset .ds-avatar img &#123;    width: 54px; height:54px;   /*设置图像的长和宽*/    border-radius: 27px;        /*设置图像圆角效果,在这里我直接设置了超过 width/2 的像素，即为圆形了*/    -webkit-border-radius: 27px;/*圆角效果：兼容webkit浏览器*/    -moz-border-radius: 27px;&#125;/* 所有样式 */* &#123;    -webkit-border-radius: 0px !important;    border-radius: 0px !important;    box-shadow: inset 0 0 0px #fff !important;&#125;/* 喜欢按钮 */#ds-thread #ds-reset a.ds-like-thread-button &#123;    border: 1px solid #f3726d;    background: #fff !important;    text-shadow: 0 0px 0 #fff !important;&#125;/* 点击喜欢后弹出的分享图标 */.ds-service-link &#123;    background: url(&quot;//static.duoshuo.com/images/service-icons-color-flat.png?v=2&quot;) no-repeat;    _background-image: url(&quot;//static.duoshuo.com/images/service-icons-color-flat.gif?v=2&quot;);&#125;/* 上面那个分享图标我是想改成扁平化的，但是修改了后 *//* 下面这几个图标的坐标位置属性（多说原生的代码）就无效了，不知道为什么，于是自己手动写上去了 */#ds-reset .ds-qzone &#123;    background-position: 0 -128px;&#125;#ds-reset .ds-qqt &#123;    background-position: 0 -64px;&#125;#ds-reset .ds-renren &#123;    background-position: 0 -32px;&#125;#ds-reset .ds-kaixin &#123;    background-position: 0 -80px;&#125;#ds-reset .ds-douban &#123;    background-position: 0 -96px;&#125;#ds-reset .ds-baidu &#123;    background-position: 0 -208px;&#125;/* 被顶起来的评论 */#ds-reset .ds-gradient-bg &#123;    background: #E9E9E9 !important;&#125;/* 评论框默认显示文字样式 */#ds-thread #ds-reset .ds-textarea-wrapper textarea, #ds-thread #ds-reset .ds-textarea-wrapper .ds-hidden-text &#123;    font-family: &quot;Microsoft YaHei&quot;, Verdana, sans-serif !important;&#125;/* 发布评论按钮 */#ds-thread #ds-reset .ds-post-button &#123;    font-family: &quot;Microsoft YaHei&quot;, Verdana, sans-serif !important;    border: 0 none !important;    color: #FFFFFF !important;    background: none repeat scroll 0 0 #F3726D !important;    cursor: pointer !important;    display: inline-block !important;    text-transform: none !important;    transition: all 0.3s ease 0s !important;    -moz-transition: all 0.3s ease 0s !important;    -webkit-transition: all 0.3s ease 0s !important;    text-align: center !important;    text-shadow: 0 0px 0 #fff !important;&#125;/* 发布评论按钮  hover */#ds-thread #ds-reset .ds-post-button:hover &#123;    background: none repeat scroll 0 0 #303030 !important;    color: white !important;&#125;/* 评论框边框 */.theme-next #ds-thread #ds-reset .ds-textarea-wrapper &#123;    border-color: #DEDEDE !important;&#125;/* 评论框下面框的边框(好绕啊！) */#ds-thread #ds-reset .ds-post-toolbar &#123;    border: 1px solid #DEDEDE !important;    background: #E9E9E9 !important;&#125;/* 昵称 */#ds-reset .ds-highlight &#123;    color: #F3726D !important;&#125;/* 顶 */#ds-thread #ds-reset .ds-post-liked a.ds-post-likes &#123;    color: #F3726D !important;&#125;/* 发布旁边的“分享到”图标 */#ds-reset .ds-service-icon &#123;    background-image: url(&quot;//static.duoshuo.com/images/service-icons-color-flat.png&quot;) !important;    _background-image: url(&quot;//static.duoshuo.com/images/service-icons-color-flat.gif&quot;) !important;&#125;/* 隐藏多说底部的版权 */#ds-thread #ds-reset .ds-powered-by &#123;    display: none;&#125;/* 最近访客的头像 */#ds-recent-visitors .ds-avatar img &#123;    border-radius: 27px !important;    -webkit-border-radius: 27px !important;    -moz-border-radius: 27px !important;&#125;/* 最近访客的头像 */#ds-recent-visitors .ds-avatar &#123;    float: left&#125;\n\n我比较喜欢简洁扁平化的风格，所以做了上述的更改。小伙伴们具体看那些组件不顺眼，要修改掉，在网页上右键，选择 检查元素 就可以看到相对应的类名和 ID 等等。如果不会 CSS，建议你去 CSS 教程 - W3School 简单的学习一下 CSS 的基本知识。\n另外我发现 NexT 主题也对多说的 CSS 样式做了些更改，CSS路径 themes\\next\\source\\css\\_common\\components\\third-party\\duoshuo.styl，所以如果小伙伴用了其他主题，显示样式可能有点区别。 目前就先改这么多，更多的样式还在开发中，会不定期的更新。如果小伙伴有什么更好的样式，欢迎留言~\n更新2016-05-28 更新\n添加站点最近访客功能你只需要在想要显示的地方添加如下代码即可：\n&lt;div class=&quot;ds-recent-visitors&quot;    data-num-items=&quot;36&quot;    data-avatar-size=&quot;42&quot;    id=&quot;ds-recent-visitors&quot;&gt;&lt;/div&gt;\n\ndata-num-items：显示的最近访客数量data-avatar-size： 访客头像大小CSS 设置：请参考上面的自定义CSS\n当然，前提是你使用了多说评论功能，因为最近访客功能就是由多说提供的。我是直接写在了 about/index.md 文件中。点此 看看我的访客功能(●’◡’●)\n参考资料\n多说使用帮助 - 多说开发者中心讨论区 - 多说开发者中心主题配置 - NexT 使用文档第三方服务集成 - NexT 使用文档\n\n\n","categories":["Hexo"],"tags":["Hexo","Next","插件"]},{"title":"Atom 的炫酷插件 activate-power-mode","url":"/blog/2016/04/22/activate-power-mode/","content":"\nAtom 简介Atom 是一款免费的编辑器，我一般在写 Web 项目的时候使用。写 Java 项目用 Eclipse， 其他直接用 Notepad++，别问我为什么不用 Sublime。喜欢这款编辑器的主要原因是它的黑色扁平化主题风格非常炫酷，功能也比较强大，缺点就是比较吃内存，启动比较慢( ╯□╰ )。最近使用 Atom 写自己的博客【没错，就是现在这个博客】，想到了 activate-power-mode 插件的炫酷效果，于是就体验了一下。下面介绍下详细安装过程。\n\n\n安装使用 activate-power-mode注意：本文针对 Windows 和 Ubuntu 平台，其他平台也差不多，自己琢磨吧~\n先上图！\n\n\n准备\n  Atom\n  activate-power-mode\n  Node.js\n\n点击上面的三个链接，分别下载下来 Atom、activate-power-mode、Node.js，然后安装 Atom、Node.js。\n\nWindows：直接双击安装就可以。\nUbuntu： 运行 sudo dpkg -i xxx-atom-xxx.deb 安装 Atom。\n\n安装插件解压下载下来的 activate-power-mode zip 包，移动到 ~\\.atom\\packages 下，比如 Windows 是  C:\\Users\\cylong\\.atom\\packages ，Ubuntu 是 home/cylong/.atom/packages，接下来进入到 activate-power-mode 目录下，打开终端，输入：\nnpm install # 安装必要的 module\n\n之后重启 Atom ，使用右键选择 Toggle 或者 Ctrl ＋ Alt ＋ O 就启动插件了，体验炫酷的效果吧！\n插件设置刚开始用的时候感觉蛮好玩的，非常爽。然后用了不到一分钟，我就觉得眼睛要瞎了！估计在玩个几分钟就真的瞎了！！屏幕震动效果闪瞎我的双眼！要是能够把震动效果删除会不会好一点？于是自己开始找这个插件的设置，果然有！\n\n  首先点击 Atom 左上角的 File 按钮，Ubuntu 是 Edit\n  Windows 进入到 Settings，Ubuntu 是 Preferences\n  找到 packages 设置\n  找到  activate-power-mode\n  进入到  Settings\n  找到 Screen Shake - Enable， 将前面的 √ 去掉\n\n之后就只有颗粒效果啦，现在感觉好多了吧(●’◡’●)。插件设置中还有颗粒大小的设置，自己根据需要修改吧~\n总结把屏幕震动效果关掉后感觉好很多了。也一直在用这个效果，感觉还是蛮帅的~不过，如果一行中字符太多，Atom 会自动换行显示，但是这些字符还是在同一行的，这个时候这个插件产生的效果就会错位，就是产生的颗粒不是在当前输入的字符位置，目前我还没解决 ( ╯□╰ )，谁有好的解决办法欢迎联系我。另外，如果读者有更好的 Atom 插件或者使用技巧，欢迎留言或者 联系我。最后推荐下自己比较喜欢的编辑器 Atom 吧 (●’◡’●)\n更新2016-05-15 更新这个插件的作者是比较良心的，修复了 Atom 自动换行后，插件产生的颗粒位置错位的 BUG。现在一直在用这个插件，写代码越来越有激情了呢 o(^▽^)o\n2016-06-01 更新我有点傻了( ╯□╰ )，我发现直接进入到 Preferences(首选项)-&gt; install(安装)，就可以直接安装 activate-power-mode 插件了。\n\n","categories":["Atom"],"tags":["插件","Atom","Ubuntu","Windows"]},{"title":"Apache 如何设置 404 错误页面","url":"/blog/2016/04/29/apache-404/","content":"\n当我们浏览网站的时候，有时候会发现访问的页面不存在了，页面会有“你访问的页面不存在了，跳转到主页”或者“404 Not Found”等等的提示。我们通常称之为 404 页面。所谓的 404 页面就是当用户输入一个错误或非存在的链接时，显示的一个页面。当 Web 服务器接到类似请求时，会返回一个 404 状态码，告诉浏览器要请求的资源并不存在。显示的 404 页面主要作用是告诉用户，你输入的网址多请求的页面是不存在的或者是一个错误的链接，引导用户进入网站的其他页面。但是 Web 的默认 404 页面非常的简陋，对用户很不友好，这就需要我们自己定义个性化的 404 页面，提升用户体验。\n\n\nApache 设置 404 错误页面在 .htaccess 文件中加入代码：\nErrorDocument 404 /404.html\n\n之后在网站根目录建立一个 404.html 文件，编写你的 404 页面。\n注意\n  不要将 404 页面直接指向到网站主页，这可能导致你的首页不被搜索引擎收录。\n  /404.html 不要带域名，比如(错误写法：http://www.cylong.com/404.html)，否则返回的状态码不是 404，而是 302、200。\n\nSEO(搜索引擎优化)404 状态码对搜索引擎是非常重要的。需要注意的是，有时候我们看到一个 404 的错误页面，但返回的状态码可能并不是 404。用户并不会关心状态码是多少，但是对于搜索引擎就不一样了。当搜索引擎获取到404 状态码，就表示此 URL 已经失效，页面已经不存在了。搜索引擎就不会索引这个页面，并且删除数据库中的索引。若返回的是 200，搜索引擎就会对此 URL 建立索引，这样就会产生多个不同的 URL 具有相同的页面内容，搜索引擎就认为你的网站有大量重复的内容，可能会被降权。\n所以当我们自定义错误页面的时候，一定要保证状态码也是 404，不仅要对用户友好，也要对搜索引擎友好。\n参考资料&amp;感谢\n网站如何设置404页面，什么是404错误，404页面代码怎么写园子博客 - 如何设置404页面\n\n\n","categories":["Apache"],"tags":["Apache","SEO","htaccess"]},{"title":"网站首选域","url":"/blog/2016/05/02/preferred-domain/","content":"\n什么是首选域当我们在访问一个网站的时候，使用 http://www.cylong.com 和 http://cylong.com 访问网站，获得的内容并没有区别。对于用户来说，带 www 和不带 www 访问是一样的，但是对于搜索引擎就不一样了，两种域会被视为不同的网页，使得权重分散。Google 解释如下：\n首选网域是您希望 Google 用来将您的网页编入索引的网域（有时也称为规范网域）。指向您网站的链接可能会同时使用 www 版和非 www 版网址（例如，http://www.example.com 和 http://example.com）。首选域是您希望 Google 用来在搜索结果中显示您网站的版本。\nSearch Console帮助设置您的首选网域（www 版网址或非 www 版网址）\n\n\n\n设置首选域使用 Google Search Console 设置注意： 此方式仅适合 Google\n\n点击 Google 网站站长，然后点击首页的 SEARCH CONSOLE。\n登陆后，点击想设置首选域的网站（没有网站就添加下）。\n点击右上角的齿轮设置图标 ，然后点击 网站设置。\n选择对应的首选域。\n\n使用 301 重定向为了使其他搜索引擎和访问者都采用你的首选版本，建议你使用 301 重定向对你的非首选网域的访问重定向到首选网域。在 .htaccess 文件里添加如下代码（要针对托管在运行 Apache 的服务器上的网站实施 301 重定向，你需要有访问权限，日后可能会写什么是 .htaccess 文件，先挖个坑）：\nRewriteEngine OnRewriteCond %&#123;http_host&#125; ^cylong.com [NC]RewriteRule ^(.*)$ http://www.cylong.com/$1 [L,R=301]\n\n使访问 http://cylong.com 的时候就会自动转到 http://www.cylong.com。\nHexo 博客框架设置首选域我的博客是由 Hexo 搭建的。没有部署到一个 Apache 服务器上，所以上面的设置方法就没用了。博客源码由 Hexo 生成，部署在 Github 上。如何搭建 Hexo 博客请参考：\n\nHexo + Git 搭建免费的个人博客 。\n\n如果你使用的是 GitHub 提供的域名，比如我的是 http://cylong1016.github.com。就不需要往下看了，如果你使用的是自己购买的域名，则只需要在 CNAME 中填写你所希望的首选域就可以了，比如我的是:\nCNAMEwww.cylong.com\n\n注意当你确定你的首选域之后，在以后的 SEO 工作中，比如友情链接、链接推广时，都要采用你设置的首选域。\n\n","categories":["Web"],"tags":["Hexo","Apache","SEO","htaccess","301重定向"]},{"title":"Windows 使用 cmd(命令提示符)创建文件","url":"/blog/2016/05/09/windows-linux-new-file/","content":"\n最近在研究 .gitignore 的使用，于是想创建一个 .gitignore 文件做测试，右键-&gt;新建-&gt;文本文档 再输入文件名后，惊讶的发现，Windows 竟然提示： 请键入文件名！【不得不去吐槽！】。看样子 Windows 是把 gitignore 当成文件名的后缀了。没办法，只好打开 cmd(命令提示符)去创建文件了。\n\n\n打开 cmd一般有以下方式打开 cmd【我使用的是 Windows 10 系统，某些方法可能没用】：\n\n  在某个文件夹下按住 Shift 键，然后点击 鼠标右键，选择 在此处打开命令窗口（建议使用此方式，这样你就不用 cd 到指定的文件夹了）。\n  键盘组合键  + R，然后输入 cmd 并确定。\n  键盘组合键  + X，然后选择 命令提示符。\n  键盘组合键  + S，呼出 Cortana，然后输入 cmd 并确认（Windows 10才支持）。\n\n创建文件echo hello &gt; .abc\n\n解释：\n\n“echo hello” ：输出 “hello” 到控制台。\n“&gt; .abc” ：输出重定向到 .abc 文件中【没有此文件就会创建】。\n当然你也可以使用其他的命令，比如 type，来输出重定向。核心思想就是把某些字符串输出重定向到指定文件里就可以了。\n\n创建文件夹mkdir .abc\n\nLinux 使用 shell 创建文件顺便说一下使用 shell 创建文件吧。上面的那些命令在 shell 中都可以使用，另外说一个在 shell 中更方便的命令。\ntouch .abc\n\n注意写本文的目的是在 Windows 下创建类似 .abc 这样的文件没法使用 右键-&gt;新建 来创建文件。如果你想创建一个 abc.txt 就不要这么麻烦啦【也没人会这么做吧(●’◡’●)】\n\n","categories":["Windows"],"tags":["Windows","cmd","Linux","Shell"]},{"title":"Struts2 参数依赖注入失败","url":"/blog/2016/05/10/struts2-jsp-param/","content":"\n这是在 SegmentFault 上看到的一个问题，正好前不久学习了 J2EE 的 SSH 框架，看到这个问题忍不住答了一下。结果问题并不像表面上那么简单。没办法，自己挖的坑，跪着也要填完( ▼-▼ )。原问题链接：\n\nstruct2框架jsp页面传参失败\n\n\n\n源码和提问者要了源码，方便查找BUG。源代码太长，我就截取了部分代码。\naddFlower.jsp&lt;s:form action=&quot;addFlower&quot; method=&quot;post&quot;&gt;     &lt;table width=&quot;380&quot; &gt;          &lt;tr&gt;             &lt;td&gt;鲜花ID：&lt;/td&gt;             &lt;td&gt;             &lt;s:textfield id=&quot;goodsId&quot; name=&quot;goods.goodsId&quot;/&gt;             &lt;/td&gt;          &lt;/tr&gt;          &lt;tr&gt;              &lt;td&gt;&lt;input type=&quot;submit&quot; value=&quot;添加&quot; class=&quot;btn&quot; /&gt;          &lt;/tr&gt;     &lt;/table&gt;&lt;/s:form&gt;\n\nstruts.xml&lt;package name=&quot;flowers&quot; namespace=&quot;/&quot; extends=&quot;struts-default&quot;&gt;    &lt;action name=&quot;addFlower&quot; class=&quot;flowers&quot; method=&quot;addFlowerInfo&quot;&gt;         &lt;result name=&quot;index&quot;&gt;/flowerInformation/flowerInformation.jsp&lt;/result&gt;    &lt;/action&gt;&lt;/package&gt;\n\napplicationContext.xml&lt;bean name=&quot;adminUser&quot; class=&quot;com.xhydxs.action.AdminUserAction&quot;    scope=&quot;prototype&quot;&gt;    &lt;property name=&quot;adminUserBiz&quot; ref=&quot;adminUserBiz&quot; /&gt;&lt;/bean&gt;&lt;bean name=&quot;flowers&quot; class=&quot;com.xhydxs.action.FlowerAction&quot; scope=&quot;prototype&quot;&gt;    &lt;property name=&quot;flowerBiz&quot; ref=&quot;flowerBiz&quot; /&gt;&lt;/bean&gt;\n\nFlowerAction.javapublic class FlowerAction extends ActionSupport    implements RequestAware, SessionAware &#123;    private Goods goods;    public Goods getGoods() &#123;        return goods;    &#125;    public void setGoods(Goods goods) &#123;        this.goods = goods;    &#125;    public String addFlowerInfo() &#123;        System.out.println(&quot;goods:&quot; + goods);        return &quot;index&quot;;    &#125;&#125;\n\n运行基本上看这些代码是完全正确的啊，并没有什么错误【后来证明确实也没有错误( ╯□╰ )】。拿到项目代码的我运行了下【运行前由于环境不同，我配置了好久啊啊啊啊！】，输出一直是 goods:null。这我就非常奇怪了，和之前写的 J2EE 项目对比了下，套路都是一样的啊！后来我发现了上面的一堆错误信息【为什么不早点看这些错误信息呢】，基本上都是围绕着下面这个错误：\nCaused by: java.lang.IllegalStateException: Cannot convert value of type [com.xhydxs.action.AdminUserAction] to required type [com.xhydxs.entity.AdminUser] for property &#x27;adminUser&#x27;: no matching editors or conversion strategy found\n\n解决可以发现是类型转化问题，为什么会让 AdminUserAction 转化成 AdminUser 呢？这两个类怎么会互相转化呢？于是我使用全局查找 AdminUserAction 和 AdminUser 这两个关键词【用 Atom 编辑器】。终于让我发现以下的代码！！！\napplicationContext.xml&lt;bean name=&quot;adminUser&quot; class=&quot;com.xhydxs.action.AdminUserAction&quot;    scope=&quot;prototype&quot;&gt;    &lt;property name=&quot;adminUserBiz&quot; ref=&quot;adminUserBiz&quot; /&gt;&lt;/bean&gt;\n\nGoods.hbm.xml&lt;many-to-one name=&quot;adminUser&quot; class=&quot;com.xhydxs.entity.AdminUser&quot;    fetch=&quot;select&quot;&gt;    &lt;column name=&quot;UPD_OPR&quot; length=&quot;20&quot; not-null=&quot;true&quot; /&gt;&lt;/many-to-one&gt;\n\n发现了么？name 都是 adminUser，然而 class 分别对应着 AdminUserAction 和 AdminUser。然后把 AdminUserAction 对应的 name 改掉就行了。。。。至于为什么上面这个错误会导致 goods 为 null，因为在 Goods 类里有一个 AdminUser 成员变量，导致 struts 没法构建 goods 这个实例了&gt;3&lt;\n\n","categories":["Java"],"tags":["Java","SSH","JSP"]},{"title":"Windows 10 Metro 应用闪退、无法打开修复方法","url":"/blog/2016/05/15/windows-10-metro-error/","content":"\n最近在使用 WindowsModernAppsTools 研究 Windows Metro 应用翻墙 问题，由于我的手贱删除了些不该删除的东西，导致我的系统中很多 Win 10 应用没法打开了，比如日历、资讯、天气、必应词典等等都打不开了。虽然平时不常用，但是强迫症的我表示没法忍受啊！于是找了很多资料，终于搞定了！\n\n\n注意： 我说的应用都是 Windows 应用商店里的应用。\n解决方法\n键盘组合键  + S，呼出 Cortana，然后输入 PowerShell。在结果中的 PowerShell 上 右键-&gt;以管理员身份运行。\n输入以下命令：Get-AppXPackage -AllUsers | Foreach &#123;Add-AppxPackage -DisableDevelopmentMode -Register &quot;$($_.InstallLocation)\\AppXManifest.xml&quot;&#125;\n回车后等待命令执行完毕即可。\n以上其实是对应用进行了重置\n\n参考资料&amp;感谢\nWin10应用商店、应用打不开或闪退的解决方法 - IT之家\n\n\n","categories":["Windows"],"tags":["Windows"]},{"title":".gitignore 的使用","url":"/blog/2016/05/19/gitignore/","content":"\n当我们在项目开发的时候，常常使用 Git 做版本控制工具。有时候，我们不希望某些文件或者文件夹被 Git 追踪，比如项目产生的中间文件【.class 、 .o】 ，比如某些编辑器的副本文件【一般文件名带有 ~ 符号】，还有一些 log 文件等等。使用命令行的小伙伴可以不使用 git add 把他们加到索引中，不过随即而来的就是一些麻烦事，在你使用 git add . 的时候还是会追踪这些文件。使用 git status 也会显示 Untracked files……。我一直在使用 Github For Windows ，如果没有 .gitignore 文件，每次提交之前也要取消勾选那些不想上传的文件，非常的麻烦。\n\n\n创建 .gitignore以上说的那些问题都可以通过一个或者更多的 .gitignore 文件搞定，你可以在项目的任意目录下创建 .gitignore 文件，此文件的影响范围是当前目录和其所有子目录，可以在不同目录创建多个 .gitignore 文件【不过一般都是在项目根目录创建一个就行了】。\n需要注意的是 Windows 下直接右键-&gt;新建文本文档，然后键入文件名是没法创建的。。。详情请参考我的另一篇博客【这两篇博客应该是同一天写完的啊！拖延症得治呀( ╯□╰ )】：\n\nWindows 使用 cmd(命令提示符)创建文件\n\n你还可以在 Github 上新建一个仓库的同时指定生成特定的 .gitignore 文件，如下图：\n\n\n编辑 .gitignore创建好后，我们就可以用任何编辑器打开了，在其中填写你想要忽略的文件的文件名，Git 就会忽略这些文件。例子请往下看：\n# 以&#x27;#&#x27; 开始的行，被视为注释。# 忽略掉所有文件名是 cylong 的文件和文件夹。cylong# 如果只想忽略 cylong 文件夹【不能有上面那段代码】。cylong/# 如果只想忽略 doc/ 下面的 cylong 文件【同样不能有上面的 cylong 和 cylong/ 】doc/cylong# 忽略所有后缀为 html 文件。*.html# about.html 不想被忽略。!about.html# 忽略所有后缀为 .o 和 .a文件。*.[oa]\n\n除上面的一些例子以外，[abc]、[0-9]、[a-z]、? 这些正则表达式也是支持的。\n使用 Github 的配置文件如果只是我们自己写的话，可能并不会写的很全【重要的是比较麻烦是吧！】。还好 Github 已经为我们准备了各种配置文件，我们想要用哪个，就直接拿来用就好了。详情请戳：\n\nhttps://github.com/github/gitignore\n\n删除已经跟踪的文件如果文件已经被 Git 跟踪了， 那么这些文件即使被写在了 .gitignore 中，Git 也不会忽略他，还是会继续跟踪，解决办法是输入以下命令：\ngit rm --cached test.txt # 如果是文件夹，后面再加上 -rgit commit -m &#x27;delete test.txt&#x27;\n\n参考资料&amp;感谢\n忽略特殊文件 - 廖雪峰的官方网站.gitignore 文件使用说明 - change2hao\n\n\n","categories":["Git"],"tags":["Git","gitignore"]},{"title":"解决 GitHub Pages 禁止百度爬虫抓取的问题","url":"/blog/2016/05/22/github-baidu-spider-exception/","content":"\n最近在研究网站在 Google 和百度的收录问题，Google 收录很轻松，抓取提交下链接就好了，但是百度却花了我好长时间才搞定，这也是为什么这篇博客写的这么晚 ( ╯□╰ )。有关如何能让你的网站被搜索到请参考：\n\n如何在 Google 和百度里搜索到自己的网站\n\n\n\n原因在 百度站长平台 上进行抓取诊断的时候，发现一直抓取失败，如图：\n\n\n\n后来才发现，原来是 GitHub 禁止百度爬虫抓取，原因是百度的抓取太猛烈，给 GitHub 的用户造成了可用性问题，而且会一直禁用下去。我该吐槽 GitHub 呢？还是百度呢？大家心知肚明就好。（╯－＿－）╯╧╧\n解决我想了想，既然 GitHub 不让百度抓取，那么我干脆把博客部署到其他地方吧。于是找到了国内的 CODING ，之前可能有很多小伙伴使用的是 Gitcafe，不过已经被 CODING 收购了，2016-05-31 号就会停止服务。CODING 中也提供和 GitHub 相同的 Pages 服务。下面是具体步骤：\n\n注册登录 CODING。\n创建新项目，项目的后缀必须是和你的个性后缀一样。\n创建项目的时候你可以选择从 GitHub 上导入你的博客仓库或者之后自己部署到 CODING 上，如下图：\n进入你的项目，点击左侧的 代码，再选择 Pages 服务，选择 部署分支，默认是 coding-pages，建议换成 master 分支和 GitHub 保持一致。然后点击 立即开启。\n绑定自己的域名，如下图：\n到你的 DNS 服务商修改你的域名解析记录，这里不需要删除解析到 GitHub 的记录，像我下面这样配置就可以，这样正常访问还是访问到 GitHub 上，百度抓取的时候是抓取的 CODING 上的项目。万网 DNS 设置：\nDNSPod 设置：\n注意：我的域名在万网购买的，默认使用的是万网的 DNS，设置成百度后开始是好用的，后来就又抓取不到了（╯－＿－）╯╧╧。 于是我就换成了 DNSPod 的服务，把线路类型设置成百度、搜索引擎或者国内都可以。如果设置成搜索引擎的话注意 Google 也会去 Coding.net 抓取页面。设置成国内的话，国内的其他用户访问也访问的是 Coding.net 中的页面，相比访问 GitHub Pages 会更快一点。\n\nHexo 同时部署到 GitHub 和 Coding既然上面的 DNS 分流到了 GitHub 和 Coding 上，那么我们在部署的时候就要同时维护这两个仓库，好消息是 Hexo 框架支持同时部署到 GitHub 和 Coding 上，详细介绍请参考：\n\n配置 SSH 公钥免去部署的时候输入密码\n\n感谢\n解决 GitHub Pages 禁止百度爬虫的方法与可行性分析 | 咀嚼之味解决百度爬虫无法抓取github pages | Lippi-浮生志Hexo 同时托管到 coding.net 与 GitHub | shomy\n\n\n","categories":["Search"],"tags":["Hexo","Git","GitHub","SEO","爬虫","Search"]},{"title":"如何在 Google 和百度里搜索到自己的网站","url":"/blog/2016/05/22/google-baidu-search/","content":"\n搭建完自己的博客或者有一个自己的网站什么的，总想着能在 Google 或者是百度里搜索到吧，这样就可以提高你的网站的知名度，说不定还会结 ♂ 交到志同道合的小伙伴呢 (●’◡’●)。下面就讲解下如何让自己的网站被搜索引擎收录。\n\n\nGoogle 搜索\n点击 Google 网站站长，然后点击首页的 SEARCH CONSOLE。\n添加你的网站，进行人机验证（就是证明这个网站是你的）。\n进入到 抓取 -&gt; Google 抓取方式。\n点击 抓取 或者 抓取并呈现。\n若提示完成或者部分完成，则可以将网址 提交至索引，有两种提交方式：仅抓取此网址、抓取此网址及其直接链接。都有次数限制。\n等待一会，打开 Google，在搜索栏输入 site:www.cylong.com（换成你的域名），就可以看到你网站的内容了\n\n\n\n百度搜索\n点击 百度站长平台，登陆。\n添加你的网站，进行人机验证。\n点击 抓取诊断 判断百度是否能够抓取到你的网站。我的博客部署在 Github 上，结果 Github 禁止百度抓取 ( ╯□╰ )，如何解决请参考：解决 Github Pages 禁止百度爬虫抓取的问题\n点击 链接提交 ，这里有很多种提交方式，各有各的优点，也有详细的说明。自己选择吧（实在不会就直接手动提交）\n我使用的是自动提交方式，Hexo 的 NexT 主题已经部署了自动推送的代码，我们只需在主题配置文件中找到 baidu_push 字段 , 设置其为 true 即可。\n等待一会，打开百度，在搜索栏输入 site:www.cylong.com（换成你的域名），就可以看到你网站的内容了\n\n其他的搜索引擎其他的搜索引擎我用的也比较少，不过如果你的网站不知道什么时候也会被其收录的，我试了一下，我的博客的首页就被 Bing 收录了，当然你想像上面的那些方法在各个搜索引擎中管理你的网站也是可以的，然而我并没有闲心管那些（我猜测基本都是差不多的），有兴趣的小伙伴可以自己试一试。\n搜索引擎优化(SEO)搜索引擎优化（英语：search engine optimization，缩写为SEO），是一种通过了解搜索引擎的运作规则来调整网站，以及提高目的网站在有关搜索引擎内排名的方式。由于不少研究发现，搜索引擎的用户往往只会留意搜索结果最前面的几个条目，所以不少网站都希望通过各种形式来影响搜索引擎的排序，让自己的网站可以有优秀的搜索排名。当中尤以各种依靠广告维生的网站为甚。\n维基百科搜索引擎优化\n\n注意： 此文章是以 Hexo 搭建的博客为基础，某些插件只支持 Hexo 搭建的博客，如果是其他博客，请寻找支持自己博客的插件或者自己实现。\n添加 robots.txtrobots.txt 可以告诉搜索引擎你网站的哪些页面可以被抓取，哪些页面不可以被抓取。将 robots.txt 放置在 source 根目录下。以下是我的 robots.txt：\nrobots.txtUser-agent: *Allow: /Allow: /archives/Disallow: /js/Disallow: /css/Disallow: /fonts/Disallow: /lib/Disallow: /fancybox/Sitemap: https://www.cylong.com/sitemap.xmlSitemap: https://www.cylong.com/baidusitemap.xml\n\n\n添加网站地图(Sitemap)Sitemap 上面放置了网站上需要搜索引擎抓取的所有页面的链接，有助于搜索引擎抓取你的网站，清晰了解网站的架构，益于 SEO 优化。\n\n安装 Hexo 的 sitemap 插件\nnpm install hexo-generator-sitemap --save       # 适用于提交给 Googlenpm install hexo-generator-baidu-sitemap --save # 适用于提交给百度\n\n在站点的 _config.yml 添加以下代码：\n_config.ymlsitemap:    path: sitemap.xmlbaidusitemap:    path: baidusitemap.xml\n\n配置成功后，在你执行 hexo -g 的时候，在 public 文件夹（也就是你的站点根目录）就会出现 sitemap.xml 和 baidusitemap.xml。然后在 robots.txt 中添加如下代码：\nrobots.txtSitemap: https://www.cylong.com/sitemap.xmlSitemap: https://www.cylong.com/baidusitemap.xml\n\n第三步中搜索引擎在抓取到 robots.txt 的时候会自动抓取站点地图。你还可以手动提交给 Google 和百度，都是带有提示的傻瓜式操作，相信大家都能解决吧 (●’◡’●)\n\n\n\nGoogle： Search Console\n百度： 百度站长平台\n\n2017-04-13 更新\n在我向百度提交站点地图 baidusitemap.xml 的时候提示 XML 解析失败，猜测可能是格式有问题，通过查看 百度sitemap协议都支持哪些格式 发现 Hexo 生成的 baidusitemap.xml 确实有问题，不过百度支持上文中生成的 sitemap.xml 格式的 XML 文档，上传这个就正常了。\n\n\n一些小点子你在你的各大社交网站的个人信息里贴上你的博客域名（比如知乎、Facebook、Twitter、Github 等等）会提高你网站的访问量哟，还有在各大社交网站上回答有关问题可以附上自己的博客地址，也会增加访问量 o(^▽^)o。当然，更重要的还是你的博客要内容丰富精彩，才会吸引更多的人。如果是自己的某个网站什么的，多注意下 SEO 优化也是不错的选择。\n参考&amp;感谢\nHexo 博客 SEO 优化，添加 robots.txt | Dennis&#39; Blog\n\n\n","categories":["Search"],"tags":["Hexo","SEO","Search"]},{"title":"站在 Shadowsocks 的肩膀上发现精彩的世界","url":"/blog/2016/05/26/shadowsocks/","content":"\n国内的网络环境我不说相信大家都懂。虽然墙内的世界很丰富，但是墙外的世界还有着更加精彩的内容。这不得不让我想起了曾经看过的一部漫画——进击的巨人。大部分人都在墙内过着安逸的生活，但是总有那么一帮人，想要去墙外探索未知的世界。我就是这样的人！之前因为想要体验 Google 搜索、体验 Youtube、查阅学习资料，还有玩的部分游戏需要翻墙，找了很多免费的代理和 VPN，效果都不好，断断续续的。后来经过舍友的推荐，入了 Shadowsocks 的坑。体验了有两个月左右，效果很棒，访问速度也很快，强烈推荐给大家使用！！！(●’◡’●)\n\n\n购买服务\n点击进入 Shadowsocks（此链接是我的推广链接，因为种种原因，Shadowsocks 官网常常换，所以我的推广链接也会不断更新的，官网链接也以此为准。你点击后会直接进入首页，通过这个链接购买服务后我也会获得一些好处啦，嘿嘿 🤭），进入首页后选择 购买服务。\n之后选择你想要购买的服务，点击现在订购。我选择的是 Shadowsocks 普通版。需要注意的是，虽然显示的价格是美元，但是在后面支付的时候会自动转化为人民币。\n界面上选择你的付款年限，然后点击继续。\n在结账页面，你需要填写各种信息，需要认真填写，这也是在创建账号。\nShadowsocks 支持 Alipay 支付宝国际版。之后付款就可以了，现在大约是 104 块钱一年。我买的时候，订购服务时显示的还是人民币，99块钱一年。虽然贵了一点点，不过还是可以接受的。\n之后进入 客户中心，用第4步创建的账号登陆。\n点击产品服务，可以看到你刚刚购买的服务，状态为有效。\n点击刚刚购买的服务，会看到产品详情。下面有配置文件下载，选择 Windows 版下载。下载下来是 gui-config.json。\n\n2023-09-27 更新\n\n注：如果不着急的话，可以等双十一再买，有优惠。\n\n客户端安装使用支持的客户端：OS X， Windows， Linux， iOS， Android， OpenWRT 路由器等。详情请参考：客户端 | Shadowsocks，客户端都在 Github 上。\n2023-10-12 更新Shadowsocks 的客户端一直在不断的更新迭代，以下教程可能更新不及时，如果有落后的请直接去 Shadowsocks 官网，现在已经有很完善的各平台客户端安装教程。\nWindows 客户端\n点击下载 Shadowsocks-3.0.zip（写这篇博客时候的最新版本），或者去 Shadowsocks Windows | GitHub 上寻找其他版本。\n解压后有一个 Shadowsocks.exe 文件。最好把这个文件放到一个目录下，比如新建一个 Shadowsocks 文件夹。\n把刚刚下载的 gui-config.json 文件放到与 Shadowsocks.exe 相同的目录下。\n双击 Shadowsocks.exe，会出现一个 GUI 界面，自动读取了 gui-config.json 文件中的内容。\n在右下角托盘图标上会有一个好像纸飞机的 Shadowsocks 图标，右键-&gt;启动系统代理，就可以越过墙壁，浏览更多丰富多彩的内容啦~\n另外建议设置成 右键-&gt;开机启动，这样不用每次开机手动启动了。还可以在 右键-&gt;服务器 中选择不同的服务器。\n\nAndroid 客户端\n点击下载 Shadowsocks-nightly-2.10.3.apk（写这篇博客时候的最新版本），或者去 Shadowsocks Android | GitHub 上寻找其他版本。\n把这个 apk 安装到手机上（可以传到手机里，打开这个 apk 就能安装了），中文叫影梭。\n安装完成后仍然需要配置，支持扫描二维码配置，但是需要下载一个客户端。我不喜欢下太多的客户端，所以就手动配置，具体的值可以用记事本打开 gui-config.json 查看。\n翻墙后就可以去 Google Play 商店更新 Shadowsocks 了(●’◡’●)\n\n2016-09-27 更新\n\n目前最新版的 Shadowsocks 已经支持直接扫码配置了，不需要下载额外的客户端。在 Shadowsocks 官网里 客户中心 -&gt; 有效产品与服务 里就可以找到各个节点的二维码。\n\nLinux 客户端经历了 N 天之后,终于在舍友的指导下配置完成了。不得不说，Linux 真是一个让人折腾的系统。不过后来发现，其实还蛮简单的（╯－＿－）╯╧╧\n\n首先你需要下载 Chrome 浏览器（不需要翻墙），已经有的小伙伴就不用重新下载了。\n使用如下命令安装你下载下来的 Chrome 安装包：sudo dpkg -i xxx-chrome-xxx.deb\n通过 PPA 源安装 Shadowsocks-qt5，仅支持 Ubuntu 14.04 或更高版本。sudo add-apt-repository ppa:hzwhuang/ss-qt5sudo apt-get updatesudo apt-get install shadowsocks-qt5\n之后就可以在应用列表里搜索到 Shadowsocks-qt5 了\n打开图形化界面，点击 文件 -&gt; 从 gui-config.json 导入链接，接着就会像下图一样。\n上图的 jp01 和 us01 都是后来配置好的，导入 gui-config.json 后还是有些需要自己配置。双击某一条连接，像我如下这样配置（默认有的配置就不要改了）：\n配置完成后点击 OK，再点击界面上面的 连接，测试下延迟，看看是否能连接上。可以多配置几个，方便切换~\n接下来就是配置 Chrome，让 Chrome 可以使用代理。下载安装 SwitchySharp（目前此应用已经更新为 SwitchyOmega，请参考 Chrome 配置 SwitchyOmega）。\n打开 Chrome， 点击右上角的  图标，再点击 选项。\n点击 新建情景模式，做如下配置。\n保存后再点击  图标就会有你刚刚配置的情景模式，选择后就可以使用 Chrome 浏览器浏览墙外的世界啦~（另外 SwitchySharp 可以升级成 SwitchyOmega 了，有兴趣的小伙伴可以试一试！）\n做了上述一系列操作后只有在 Chrome 中可以翻出墙外，至于全局代理我正在研究，过几天会出教程，有会的小伙伴也可以交 ♂ 流下~（此坑算是没时间填了(╯‵□′)╯︵┻━┻）\n\nIOS 客户端由于本渣没有任何的苹果设备。。。所以自己研究吧，相信聪明的你可以完成的！\n2016-09-27 更新\n最近也是人品爆表，抽奖抽到了个 IPad mini 2，自然就研究了下如何在 IOS 中试用 Shadowsocks 了。官方推荐的客户端是 shadowrocket，App Store 里卖6块钱（现在已经下架了，只能通过国外账号下载了）。我找到的是 Lifi客户端-Shadowsocks and ShadowsocksR VPN，也是在 App Store 里下载，不过是免费的。两者的配置方式基本一样，都可以扫码配置。在 Shadowsocks 官网里 客户中心 -&gt; 我的产品与服务 里就可以找到各个节点的二维码。\n\nLifi 配置，在应用里选择 设置 -&gt; 从二维码导入 就会打开扫码界面，之后配置一下代理名称，打开系统 VPN 就可以了，非常简单（我觉得有张图挺好看的，于是强行加了张图(^_^)）\n\n\nShadowrocket 配置，打开应用，点击左上角的扫码图标就可以打开扫码页面：\n\n\n\n\n看评论说 Lifi客户端-Shadowsocks and ShadowsocksR VPN 是拿的 Potatso 源码？我也不知道是否真实，有了解的小伙伴欢迎联系我。不过在我一天的试用中发现这个客户端一直掉线，而且舍友 IOS 10 也没法使用，于是我俩都换成了 shadowrocket，IOS 10 可以用，不过也是一直掉线啊，而且有时候还闪退 (╯‵□′)╯︵┻━┻！如果用 Shadowrocket 的小伙伴发现QQ聊天的时候没法接收和发送图片，可以在应用的 Settings -&gt; Global Routing中选择 Proxy 就好了。大家可以先试一下免费的 Lifi，如果不好用再换成收费的那个 Shadowrocket 吧。有更好的客户端也欢迎在下面讨论。\n注意\n要是偶尔发现网络不稳定，切换线路试一下。\n不要同时在多台设备上使用，也不要把配置文件分享给其他人，可能会遭到封号行为。不过手机和 PC 同时使用时没事的。\n我遇到一个问题就是启动某些服务器无法下载 Google Play 里的应用，而且有些应用也提示无法在你所在的国家或者地区购买，这个时候就切换下线路，并且清除 Google Play 数据重启就行了。\n\n参考资料\nShadowsocks-qt5 | 中文文档Chrome 配置 SwitchyOmega | 笑话人生 Shadowsocks 配合 SwitchyOmega 使用有奇效，建议尝试下 (●’◡’●)\n\n\n","categories":["Shadowsocks"],"tags":["Ubuntu","Windows","Linux","Shadowsocks","Android","IOS","翻墙"]},{"title":"Windows 10 Metro 应用使用本地 Shadowsocks 代理","url":"/blog/2016/06/07/windows-10-metro-shadowsocks/","content":"\nWindows 8/10 的应用是不允许访问 localhost(127.0.0.1)，所以你配置了 Shadowsocks 代理，Windows 10 应用也无法翻墙， 因为Shadowsocks 的代理地址正好是 localhost(127.0.0.1)。这个时候我们就需要祭出 Windows 10 自带的程序：CheckNetIsolation。通过这个程序，你可以设置排除哪个应用的限制，使其可以翻墙。\n\n\n解决方法\n寻找应用的 SID：键盘组合键  + R，然后输入 regedit，打开注册表管理器，找到以下注册表项：HKEY_CURRENT_USER\\Software\\Classes\\Local Settings\\Software\\Microsoft\\Windows\\CurrentVersion\\AppContainer\\Mappings在其中找到你想要使用代理的应用，DisplayName 就是应用名，左边的项就是 SID。比如我找的是 Twitter。如下图：\n\n【PS： 你可以鼠标放在 SID 上右键-&gt;重命名，然后就可以复制整个 SID 了】\n\n键盘组合键  + X，然后按 A【命令提示符（管理员）】，打开终端后输入：\nCheckNetIsolation loopbackexempt -a -p=SID # 上一步你复制的 SID\n回车后就大功告成了。\n\n打开 Twitter 试一下\n\n\n\n\nCheckNetIsolation 参数\nCheckNetIsolation.exe loopbackexempt -a -p=SID 添加指定程序到列表\nCheckNetIsolation.exe loopbackexempt -d -p=SID 从列表删除指定程序\nCheckNetIsolation.exe loopbackexempt -s 列出环回免除的应用列表\n\n注意\n有些小伙伴可能会使用 WindowsModernAppsTools 来使 Windows 10 应用翻墙，这个软件也是使用了 CheckNetIsolation，另外最好不要随便动 Windows 10 应用的数据，说不定不小心删除了什么就导致应用崩溃了，切记切记。前车之鉴请参考：\n\nWindows 10 Metro 应用闪退、无法打开修复方法\n\n\nFacebook 的 Windows 10 应用没法翻墙。我找了很多资料，大家的讨论也是只有 Facebook 没法翻墙，其他的都可以。有知道原因并能解决的小伙伴欢迎 骚扰我 或者在下面留言 (●’◡’●)\n\n即使都是 Twitter 应用，但是不同的电脑 SID 可能不同。\n\n\n参考&amp;感谢\nMicrosoft Edge 浏览器用上 shadowsocks 代理翻墙方法\n\n\n","categories":["Windows"],"tags":["Windows","Shadowsocks","翻墙"]},{"title":"稳耐风波愿始从","url":"/blog/2016/06/09/iverson/","content":"\n夕阳西下。我看着AI坐在斯台普斯客队替补席上，呆呆望着场内发生的一切。他看着科比在他面前超越了他领先十三年的得分，听着为24号的喝彩，再看着记分牌上一点点被拉大的分数，他只是呆坐，眼神迷茫，无动于衷，仿佛自己来自另一个世界。惨败，又是惨败，第三次惨败。哨声响起，他低着头，快步走出球员通道。我看得到他的背影看不到他的落寞。怎么能低头离开斯台普斯？就在一年前他还是昂首走出去。八年前他只手遮天，梦想就断裂在这金黄的球馆，唯一一次六月的征战，旧队友，老照片，八年的风霜，未改的容颜，怎敢遗忘那些瞬间？最震耳欲聋的欢呼，让洛杉矶的轻歌曼舞画上一道休止符，晃倒泰龙卢，最骄傲的迈步，是谁再说，他踏上的是一条荆棘密布，无人可能成功的路？只是，八年了，我们早已认不出那块泰龙卢摔倒的地板。物是人非。隔了个半个地球，有人在心痛。\n\n\n隔了半个美国，也会有人难过吗？流年，剪影，十年。费城，1996，状元，三号，金链子，狐朋狗友，唱片，嘘声，对神的挑战，拉里布朗，训练，爱恨交错，忠诚，2001，洛杉矶，MVP，得分王……时间，路途，前进的光，没有回望。以为会与费城到地老天荒，只是寥寥的胜场，深深的惆怅，时光在云顶嘹亮地唱，分别的波澜轻轻地荡，刻不下的时光，注定一人去流浪。再见了，我爱的费城；再见了，我们爱的AI。断肠人去天涯。天涯远吗？不远，他在天涯，天涯怎么会远！\n谁道飘零不可怜，断肠人去自经年。那个精灵飞翔的故事还在上演，只是不再属于瓦乔维亚球馆。只是那个夜晚，是个例外——那个夜晚很美，他们的欢呼他们的笑，他们的拥抱他们记得他的好。他的亲吻他的奔跑，他微微润湿的双眼，告诉我们他同样忘不掉。WELCOME BACK, AI，THANKS FOR TEN GREAT YEARS OF HEART&amp;SOUL.轻轻把手放在耳边，绕场慢慢的跑，聆听。还记得吗？费城的欢呼是世界上最美妙的音乐。俯身，深深的亲吻。WE MISS YOU,AI.费城的天空，我们想你时，它落泪了。风雨中，陪你走，不要相忘于江湖。可，踏上回丹佛的飞机，便是陌路。天咫尺，人南北。\n叹人生，几番离合，便成迟暮。三年了，沧海桑田，人事变迁，谁会相信什么永远。当他终于回到家，发现一切都变了样，是熟悉的让人陌生？还是恍如隔世陌生的让人难过？曾经的一代枭雄，走到穷途末路，不甘就此推出，于是来场豪赌，一次搭上全部，输了就退出江湖。感谢我爱的费城——他的退役宣言里这样说。终于等到了费城的橄榄枝。我们爱的AI，请回家。有一种答案叫落叶归根。俯身，深深的亲吻，第二次。弧线不同了是吗，可那份情意此生不变。谁谓我生，我思议如风，历历人生。\n莫回首斜阳下，诉不尽离人话。当费城故事确定未完待续时，我高兴的快要疯掉，你没有去湖人，谁在乎什么总冠军？我只要你幸福。有些泪水是坚硬的，它从英雄的脸上滑过，但与懦弱无关。AI说，那是看到家门后的鼻酸反应。多好！爱费城的AI又回到了爱AI的费城。从此无关胜负，誓死守护。陪君醉笑三万场，不用诉离殇。\n落魄江湖还载酒，一种悲凉滋味。当两个费城之子相遇在费城——他出生成长的地方，他扬名立万的地方。他们早已不如十三年前那般锋芒毕露。久经沙场，看惯人世冷暖，他们，已不再年轻。只是他正如日中天，他似乎已日薄西山。有悬念吗？有奇迹吗？有人相信吗？似乎费城倒戈喊几声MVP也是正常的。只是他摇头，说不。那美妙的第三节，十五分，已无需我赘述。兄弟友爱之城的尊严，从来都要他来维护。没有悬念，没有奇迹，剧本已写好，不会改变，我们输了，只是，我们开始相信：弯弓射日，看我卷土重来。\n谁谓我悲，意如花信，瞳清若水。我从未想过有一天还会看到阿伦艾弗森穿上那件印有SIXER的球衣——那件神圣的为曾有旁人触动过的球衣，自始至终只属于一个人的球衣。我看着你在费城，看着你与费城荣辱与共，休戚相关，还你那份倔强，许你那份坚强。享受你的每一场胜利与失败——我也不清楚这样的日子还会有多久，如果费城真的是你的最后一站，我们陪你走完，直到你离开你最爱的篮球场，直到那件三号球衣在瓦乔维亚上空飘扬。\n任往事随风，他们自随波逐流，自始至终，稳耐风波愿始从。\n\n这篇文章是我女票大概在2009年【那个时候她真是青涩又可爱(/▽＼=)】写在百度空间里的，但是百度空间在15年就关闭了。然后我就要来发到自己的博客里，作为一种回忆 o(^▽^)o【还是自己的网站靠谱~】\n\n","categories":["艾已成诗"],"tags":["艾弗森","艾已成诗","篮球"]},{"title":"使用 Eclipse 根据 WSDL 生成 Java 代码","url":"/blog/2016/07/01/wsdl-to-java/","content":"\n这学期的 SOA 课程已经结束了，但是我为什么感觉什么都没有学到呢！！反正学到什么就整理下好了！这次是使用 Eclipse 根据 WSDL 生成 Java 代码。整个过程都是自动的，完全是傻瓜式的！\n\n\n准备\nWSDL 地址【自己可以发布，如何发布我会在日后写，先挖个坑一定要填上】\nEclipse IDE for Java EE Developers\n\n步骤\n打开 Eclipse，File -&gt; New -&gt; Dynamic Web Project\n右键刚刚新建的项目，New -&gt; Other -&gt; Web Services -&gt; Web Service Client\n在 Service definition 输入 WSDL 的地址，之后点 Next 或者 Finish 即可\n会生成类似下面这样的代码结构\n其中 xxxProxy.java 中就有服务提供的接口方法，直接调用就行了。\n\n参考&amp;感谢\n使用Eclipse生成Web Service Client - andybang1981的日志\n\n\n","categories":["Java"],"tags":["Java","WSDL","Web Service Client","Eclipse"]},{"title":"集中式和分布式版本控制学习整理","url":"/blog/2016/09/26/git-svn/","content":"\n在面试的时候被问到平时喜欢用 Git 还是 SVN，他们之间的区别是什么？这自然就谈到了分布式和集中式的区别。作为一个学生党，免费的 Github 给我提供了很大的便利，我的所有项目都是放在 Github 上，毕竟 Github 还是一个全球最大的同性交友网站 ╮(╯▽╰)╭。下面就说说集中式和分布式版本控制的区别。\n\n\n为什么使用版本控制在我们平时的开发过程中，大部分情况下是团队开发，即使是个人开发，我们也想对整个项目进行代码管理与备份等等。每次复制一份达成压缩包分类命名这样的肯定不是一个河里的解决办法，这只会让我们的磁盘空间越来越小，备份版本越来越多。在团队开发的时候，对代码进行合并管理的时候，总需要一些工具可以自动合并，版本控制系统应运而生。运用版本控制系统，我们可以对代码进行版本管理，可以随时查看之前版本的内容，随时回溯到之前版本中。团队合作的时候也可以自动合并代码，而不需要用一个共享文件，或者是进行定期的备份。\n集中式和分布式版本控制系统也分为两类，集中式和分布式版本控制，我们所熟知的 Git 是分布式，SVN 是集中式，下面说说两者的区别。\n集中式集中式版本控制系统有一个中央服务器，每个人在工作的时候都需要从中央服务器获取最新版本，修改后提交到中央服务器。其他人再获取最新代码进行更改。这种方式的缺点就是，我们必须有一个中央服务器，由于网络原因没法连接到服务器，或者服务器宕机，我们就没法进行数据获取和提交。而且由于是联网操作，网络环境也会影响到提交和下载速度。\n\n\n分布式那么分布式版本控制系统是如何解决这些问题的呢？首先，分布式版本控制系统没有所谓的中央服务器，每个站点【就是自己用来开发的电脑】都有一个完整的版本库，我们可以在本地进行修改提交。这样在没有网络的环境下也可以进行开发。当需要进行代码合并的时候，我们只要把自己的版本库推送给你的合作伙伴就可以了，这样他就可以看到你做的更改。同时，他也可以把他的版本库推送给你，这样你就可以看到他的修改了。由于每个人电脑里都是一个完整的版本库，所以自己不小心丢失数据的话，从其他地方里拷贝一份就可以了。不过平时开发中，我们不会用这样笨拙的方式来互相推送代码。毕竟每个人的电脑不是24小时开机，总不能打个电话给他说：我要推送代码给你啦！(╯‵□′)╯︵┻━┻因此，Github 就起到了一个“中央服务器”的作用。我们把代码提交到 Github 上，任何人都可以随时下载合并代码，给我们提供了很多便利。\n\n\n总结看完以上的介绍，很多人可能会比较模糊，我们在开发的过程中不是总需要一个中央服务器嘛？感觉上平时使用 Git 或者 SVN 操作都是一样的啊！出现这种混淆是因为我们平时开发的时候总是有一个中央服务器，总是再联网状态下。首先说明，Git 不需要一个中央服务器，我们平时使用 Github 是为了让我们的团队开发更便利，如果你不嫌麻烦，完全可以不用中央服务器。而 SVN 是必须使用一个中央服务器，而且如果没法联网或者服务器宕机，所有人都没法工作。其次，Git 是可以在断网状态下提交，因为每个人的电脑里都是一个完整的代码仓库，包含提交历史等等。而 SVN 在断网的时候是没法提交的，也没法查看历史记录。当然，Git 优于 SVN 的不仅有上面的这些，还有很多强大的功能优于 SVN。比如强大的分支功能，Git 做一个小小的标记就会产生一个分支。而 SVN 是复制一份代码到分支目录。Git 还可以进行本地回滚【因为自己电脑里也是一个完整的版本库，但是提交到中央服务器上的时候可以减少冗余版本】\n参考&amp;感谢以上这些知识都是参考下面这些连接里的内容，本意是我自己的学习笔记，特此对其进行感谢。\n\n集中式vs分布式 - 廖雪峰的官方网站如何理解 Git 的分布式？ - 知乎\n\n\n","categories":["版本控制"],"tags":["Git","SVN","分布式版本控制","集中式版本控制"]},{"title":"笑话人生，才刚刚开始","url":"/blog/2016/10/20/my-life-is-just-beginning/","content":"\n很多人的人生都有三个重大的转折点，第一是中考，第二是高考，第三是大学毕业。我很庆幸在这三个转折点，我都选择了或者有幸得到了自己心仪的结果，虽然有自己努力的结果，但不乏有很多幸运的元素。中考高考分别都是自己在初中和高中所有考试中发挥最好的一次，也许总有那种一到关键时候就超长发挥的光环。但我坚信，努力就会有好的结果。\n\n\n即将面临毕业的我也是很纠结的，在考研和工作中二选一，最后决定脚踏两条船，还好没有翻船。从9月份开始不断的投递各个公司，陆陆续续投了接近20家。不断的参加宣讲笔试面试、参加宣讲笔试面试……有成功也有失败，两个月的时光转瞬即逝，不得不说，找工作真是一件头疼的事情【其实考研更让我头疼啊！(╯‵□′)╯︵┻━┻】。\n…………【此处省略10000字，最后确定下来再填坑】\n这两个月完全是在煎熬，找工作的焦急导致心情跌落到了低谷，有一段时间甚至什么都不想干，就坐在那发呆。最后终于在收到某 Offer 后，跌落到低谷的心情瞬间上升到了天堂，一切都放松了下来，可以安心的做一些其他事情了呢~~我相信我的人生才刚刚开始，后面会有更大的挑战在等着我，加油！Fighting！【怎么中二起来了啊！而且文笔也不好啊！(╯‵□′)╯︵┻━┻另外我只想记录下这一天啊！但是又不知道说什么好啊！】\n\n","categories":["随笔"],"tags":["随笔","人生"]},{"title":"找出有序数组中 3 个和为 0 的数","url":"/blog/2016/11/08/three-number/","content":"前几天偶尔看到一道题，感觉蛮有意思的，在自己思考，外加上网查询之后，找到了一个比较完美的算法解决。问题描述如下：\n\n 给定有序排列的N个整数，找出其中3个数相加和为0，输出所有的不重复的3个数，要求输出的结果依然有序。 在单行内，输出的顺序和原来一致，每行之间的顺序和第一个数字在原数列中的顺序一致（如果相同则向后依次比较） INPUT : 5 -2 -1 0 1 2 OUTPUT: -2 0 2 -1 0 1 INPUT : 5 2 2 0 -2 -4 OUTPUT: 2 2 -4 2 0 -2\n\n\n\n思路\n首先思考：寻找有序数组（下文说的数组均是升序排列的）中两个和为 k 的值。很简单，两个指针 i 和 j 分别指向数组两端，计算两数的和，大于 k 则 j--，否则 i++，直到寻找到两个数和为 k 或者 i &gt; j 时停止。\n\n上题中可以转换为寻找数组中两个和为 -k 的数，k 为数组中的元素，我们只需要再加一层循环，遍历数组中的值，作为 k 就可以了。\n\n那么如何解决结果中有重复值的情况呢？比如我们输入 [-4, -2, 0, 2, 2] 这5个数，会输出两次 [-2, 0, 2]。其实这个也很好判断，当我们确定了三个数中的一个数，那么后面求出的两个数就确定下来了，比如我们确定”第一个数”是 -5，那么可能求出后面两个数是 [2, 3] 和 [1, 4]，当我们循环到下一个”第一个数”的时候，如果还是 -5，那求出的数据肯定还是重复的，所以直接跳过就好。【这块的描述好像不是很清楚啊！(╯‵□′)╯︵┻━┻ 不明白的话看下面的代码肯定一下子就明白了呢！】\n\n\n代码实现#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;vector&lt;vector&lt;int&gt;&gt; findThreeNumber(vector&lt;int&gt; arr, bool asc) &#123;\tint size = arr.size();\tvector&lt;vector&lt;int&gt;&gt; result;\t// 保存结果\tfor (int i = 0; i &lt; size; i++) &#123;\t// 保证&quot;第一个数&quot;在数组中\t\tint m = i + 1;\t\tint n = size - 1;\t\twhile (m &lt; n) &#123;\t\t\tint sum = arr[m] + arr[n];\t// 另外两个数的和\t\t\tif (sum + arr[i]  &gt; 0) &#123;\t\t\t\tasc ? n-- : m++;\t// 升序和降序的操作不一样\t\t\t&#125;\t\t\telse if (sum + arr[i] &lt; 0) &#123;\t\t\t\tasc ? m++ : n--;\t\t\t&#125;\t\t\telse &#123;\t// 找到三数和为0\t\t\t\tvector&lt;int&gt; v(3);\t\t\t\tv[0] = arr[i];\t\t\t\tv[1] = arr[m];\t\t\t\tv[2] = arr[n];\t\t\t\tresult.push_back(v);\t\t\t\t// &quot;第二个数&quot;和&quot;第三个数&quot;分别判断其下个数是否重复\t\t\t\tdo &#123;\t\t\t\t\tm++;\t\t\t\t&#125; while (m &lt; n &amp;&amp; arr[m - 1] == arr[m]);\t\t\t\tdo &#123;\t\t\t\t\tn--;\t\t\t\t&#125; while (m &lt; n &amp;&amp; arr[n + 1] == arr[n]);\t\t\t&#125;\t\t&#125;\t\t// 外层循环&quot;第一个数&quot;，如果下一个&quot;第一个数&quot;相同，则为重复数据\t\twhile (i &lt; size - 2 &amp;&amp; arr[i + 1] == arr[i]) &#123;\t\t\ti++;\t\t&#125;\t&#125;\treturn result;&#125;int main() &#123;\tbool asc = true;\t// 升序\tint n = 0;\tcin &gt;&gt; n;\tvector&lt;int&gt; arr(n);\tfor (int i = 0; i &lt; n; i++) &#123;\t\tcin &gt;&gt; arr[i];\t\tif (i &gt; 0 &amp;&amp; arr[i] &lt; arr[i - 1]) &#123;\t\t\tasc = false;\t\t&#125;\t&#125;\tvector&lt;vector&lt;int&gt;&gt; result = findThreeNumber(arr, asc);\tfor each (vector&lt;int&gt; v in result) &#123;\t\tcout &lt;&lt; v[0] &lt;&lt; &quot; &quot; &lt;&lt; v[1] &lt;&lt; &quot; &quot; &lt;&lt; v[2] &lt;&lt; endl;\t&#125;\tsystem(&quot;pause&quot;);&#125;\n\n\n","categories":["LeetCode"],"tags":["LeetCode","学习笔记","C/C++"]},{"title":"Hexo 集成 Disqus 评论","url":"/blog/2017/03/26/hexo-next-disqus/","content":"\n前言从创建博客的时候我就纠结用国内的多说还是国外的 Disqus，鉴于多说是国内的，是中文的，而且相比国内其他的系统更加稳定，功能多样，毅然选择了多说。不过后来多说经常崩溃，总是看不到评论，一直想换成 Disqus 或者国内其他的评论系统。这次好了，不用纠结了，用了一年的多说即将在2017年6月1日关闭服务，不得不换一个。在我刚开始使用 NexT 主题的时候，只支持多说和 Disqus，目前已经支持了很多，可以参考：\n\nNexT 第三方服务集成\n\n我后来还是选择了 Disqus 作为新的评论系统，虽然 Disqus 在国内有时候被墙掉了，英文读起来也比较费劲，但是强大的功能和用户体验让我对 Disqus 爱不释手。至于国内也有很多评论系统可以代替多说，但是根据先前的一些系统来看，最后都没有走下去呢╮(╯▽╰)╭。 我觉得 Disqus 不会半路 GG 吧 (╯‵□′)╯︵┻━┻\n\n\nNexT 主题集成 Disqus\n登陆 Disqus，点击 GET STARTED 开始创建站点，之后就可以点击右上角的 Admin 进入后台管理。\n点击第二条 I want to install Disqus on my site。\n按照表单填写信息，记住 Website Name 这条属性。\n接下来按照指引填写信息，完成第三步 3.Configure Disqus 后点击最下面 Complete Setup 完成创建。【中间会有一个嵌入代码的案例，不是 NexT 主题的可以参考下】\n接下来配置主题下面的 config.yml 文件。\n大于等于5.1.1版本，将 disqus 下的 enable 设定为 true，同时提供您的 shortname。 count 用于指定是否显示评论数量。\n\ndisqus:  enable: true  shortname:  count: true\n\n小于5.1.1 版本，设定 disqus_shortname 的值即可。\n\ndisqus_shortname: shortname\n接下来就可以进入后台管理设置你的评论了。\n\n多说评论迁移至 Disqus毕竟多说我也用了一年，积攒了一点评论，就这样放弃非常的舍不得，不过多说导出的评论文件无法直接导入到 Disqus 中，多说导出的是 JSON 文件，Disqus 支持的导入格式是 WordPress 导出的的 XML 文件。在网上找了一些，发现都不好用，于是自己就造了一个轮子，在下面的链接中有详细的说明。欢迎使用并提出宝贵的意见(●’◡’●)\n\n多说评论迁移至 Disqus\n\n\n","categories":["Hexo"],"tags":["Hexo","Next","插件"]},{"title":"Jackson - Java Object 与 JSON 之间的转化工具","url":"/blog/2017/03/31/jackson-java-json/","content":"\n一直在找一个 Java Object 与 JSON 之间方便快捷的转化工具，在舍友的推荐下了解到了 Jackson，使用之后对其爱不释手，现在推荐给大家。\nJSON 简介JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。 易于人阅读和编写。同时也易于机器解析和生成。 它基于JavaScript Programming Language, Standard ECMA-262 3rd Edition - December 1999的一个子集。 JSON采用完全独立于语言的文本格式，但是也使用了类似于C语言家族的习惯（包括C, C++, C#, Java, JavaScript, Perl, Python等）。 这些特性使JSON成为理想的数据交换语言。\nJSON 中文介绍 JSON\n\n以上链接中包含了 JSON 的详细介绍，其实 JSON 对象【”名称/值”对的集合】和 Java 对象是对应的，JSON 数组【值的有序列表】和 Java 的数组是对应的。下面就用一些具体的实例來说明。\n\n\nJSON 和 Java 的映射\nJSON 示例&#123;  &quot;name&quot; : &quot;cylong&quot;,  &quot;age&quot; : 33,  &quot;position&quot; : &quot;Developer&quot;,  &quot;salary&quot; : 7500,  &quot;skills&quot; : [ &quot;java&quot;, &quot;python&quot; ],  &quot;date&quot; : &quot;2017-03-31 12:29:42&quot;&#125;\n对应的 Java 类public class Staff &#123;  private String name;  private int age;  private String position;  private BigDecimal salary;  private List&lt;String&gt; skills;  // Jackson 语法  @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;, timezone = &quot;GMT+8&quot;)  private Date date;  // getter and setter&#125;\n\n\n\n相信以上的例子可以让你很好的理解两者之间的对应关系。其实不仅 Java，其他语言也类似。\nJackson 使用\n在 pom.xml 中添加依赖项pom.xml&lt;dependency&gt;\t&lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;\t&lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;\t&lt;version&gt;2.6.3&lt;/version&gt;&lt;/dependency&gt;\nJava 对象转化成 JSONObjectMapper mapper = new ObjectMapper();Staff obj = new Staff();// 将 Java 对象转化成 JSON 并写入文件中mapper.writeValue(new File(&quot;c:\\\\file.json&quot;), obj);// 将 Java 对象转化成 JSON 字符串String jsonInString = mapper.writeValueAsString(obj);\nJSON 转化成 Java 对象ObjectMapper mapper = new ObjectMapper();String jsonInString = &quot;&#123;&#x27;name&#x27; : &#x27;mkyong&#x27;&#125;&quot;;// 从文件中读取 JSON 并转化成 Java 对象Staff obj = mapper.readValue(new File(&quot;c:\\\\file.json&quot;), Staff.class);// 从 URL 中读取 JSON 并转化成 Java 对象Staff obj = mapper.readValue(new URL(&quot;http://mkyong.com/api/staff.json&quot;), Staff.class);// 将 JSON 字符串转化成 Java 对象Staff obj = mapper.readValue(jsonInString, Staff.class);\n\n\n\n参考&amp;感谢其实以上的内容在下面的链接中均有详细的介绍，我只是一个代码的搬运工( ╯□╰ )，就当是自己的笔记好了。\n\nJackson 2 – Convert Java Object to / from JSON 【Jackson 使用详细教程】Jackson Date 【有关 Jackson 对日期的处理】JSON 中文文档 【概念性的东西，最下面也有不同语言的支持】JSON 教程 - 极客学院 【包含 JSON 基础介绍和在其他语言中使用 JSON】\n\n\n","categories":["Java"],"tags":["Java","Jackson","JSON"]},{"title":"Java 通过 DOM 方式解析、创建 XML","url":"/blog/2017/04/04/java-dom-xml/","content":"\nDOM 简介DOM（Document Object Model） 是 W3C 处理 XML 的标准 API，不仅 Java 其他很多语言，比如 Javascript、PHP等等语言都实现了该标准。Java 类库支持 DOM 操作【也就是说不需要下载依赖其他包】。DOM 以树状结构组织节点和信息的集合，这种结构允许开发人员对 XML 文档进行增删改查。为了分析该树状结构，我们需要加载整个 XML 文档进行构造分析，所以消耗资源比较大，建议在操作小文件的时候使用。\n\n\n创建 XML 文档\n创建 XML Document 对象/** * 创建 XML Document 对象 * @return XML Document 对象 * @author cylong * @version 2017年4月5日 上午12:19:41 */private static Document createXMLDocument() &#123;    DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();    DocumentBuilder builder = null;    Document document = null;    try &#123;        builder = factory.newDocumentBuilder();        document = builder.newDocument();        Element root = document.createElement(&quot;college&quot;);        document.appendChild(root);        Element student = document.createElement(&quot;student&quot;);        student.setAttribute(&quot;id&quot;, &quot;0&quot;);        Element name = document.createElement(&quot;name&quot;);        name.appendChild(document.createTextNode(&quot;cylong&quot;));        student.appendChild(name);        Element biography = document.createElement(&quot;biography&quot;);        biography.appendChild(document.createCDATASection(&quot;Hello&quot;));        student.appendChild(biography);        Element age = document.createElement(&quot;age&quot;);        age.appendChild(document.createTextNode(&quot;24&quot;));        student.appendChild(age);        Element student1 = document.createElement(&quot;student&quot;);        student1.setAttribute(&quot;id&quot;, &quot;1&quot;);        Element name1 = document.createElement(&quot;name&quot;);        name1.appendChild(document.createTextNode(&quot;cylong1&quot;));        student1.appendChild(name1);        Element biography1 = document.createElement(&quot;biography&quot;);        biography1.appendChild(document.createCDATASection(&quot;World&quot;));        student1.appendChild(biography1);        Element age1 = document.createElement(&quot;age&quot;);        age1.appendChild(document.createTextNode(&quot;25&quot;));        student1.appendChild(age1);        root.appendChild(document.createComment(&quot;学生0&quot;));        root.appendChild(student);        root.appendChild(document.createComment(&quot;学生1&quot;));        root.appendChild(student1);    &#125; catch (ParserConfigurationException e) &#123;        e.printStackTrace();    &#125;    return document;&#125;\n将创建的 XML Document 写入到文件中/** * 将创建的 XML Document 写入到文件中 * @param document * @param path 文件路径 * @author cylong * @version 2017年4月3日 上午2:39:32 */private static void writeXML(Document document, String path) &#123;  try &#123;\tTransformerFactory tf = TransformerFactory.newInstance();\tTransformer transformer = tf.newTransformer();\tDOMSource source = new DOMSource(document);\ttransformer.setOutputProperty(OutputKeys.ENCODING, &quot;utf8&quot;);\ttransformer.setOutputProperty(OutputKeys.INDENT, &quot;yes&quot;);\tPrintWriter pw = new PrintWriter(new FileOutputStream(path));\tStreamResult result = new StreamResult(pw);    transformer.transform(source, result);  &#125; catch (TransformerConfigurationException e) &#123;\te.printStackTrace();  &#125; catch (IllegalArgumentException e) &#123; \te.printStackTrace();  &#125; catch (FileNotFoundException e) &#123;\te.printStackTrace();  &#125; catch (TransformerException e) &#123;\te.printStackTrace();  &#125;&#125;\n\n\n\n解析 XML 文档\n解析 XML 文件\n/** * 解析 XML 文档 * @param path XML 文档路径 * @author cylong * @version 2017年4月3日 上午2:48:53 */private static void parserXML(String path) &#123;    try &#123;        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();        DocumentBuilder db = dbf.newDocumentBuilder();        Document document = db.parse(path);        // optional, but recommended        // read this - http://stackoverflow.com/questions/13786607/normalization-in-dom-parsing-with-java-how-does-it-work        document.getDocumentElement().normalize();        Element root = document.getDocumentElement();        System.out.println(&quot;Root element : &quot; + root.getNodeName());        NodeList students = root.getElementsByTagName(&quot;student&quot;);        for(int i = 0; i &lt; students.getLength(); i++) &#123;            Node student = students.item(i);            System.out.println(student.getNodeName());            NodeList info = student.getChildNodes();            for(int j = 0; j &lt; info.getLength(); j++) &#123;                Node meta = info.item(j);                if (meta.getNodeType() == Node.ELEMENT_NODE) &#123;                    System.out.println(meta.getNodeName() + &quot;:&quot; + meta.getTextContent());                &#125;            &#125;        &#125;    &#125; catch (FileNotFoundException e) &#123;        e.printStackTrace();    &#125; catch (ParserConfigurationException e) &#123;        e.printStackTrace();    &#125; catch (SAXException e) &#123;        e.printStackTrace();    &#125; catch (IOException e) &#123;        e.printStackTrace();    &#125;&#125;\n\n注意可以 点此链接 了解其用处。\n// optional, but recommended// read this - http://stackoverflow.com/questions/13786607/normalization-in-dom-parsing-with-java-how-does-it-workdocument.getDocumentElement().normalize();\n\n\n\n\n参考&amp;感谢\nGithub 完整的代码案例How to read XML file in Java – (DOM Parser)\n\n\n","categories":["Java"],"tags":["Java","DOM","XML"]},{"title":"多说评论迁移至 Disqus - Java 实现","url":"/blog/2017/04/05/duoshuo-to-disqus/","content":"\n在网上找了一圈后，很多人都造过轮子，但是由于年代久远，多说和 Disqus 的评论格式可能发生变化，试了一些后并没有一个成功。无奈自己开始造轮子，不过看完两种评论文件格式后，发现其实还是瞒简单的，于是就用 Java 实现了一个。【为了节省时间就用自己最擅长的 Java 了，虽然其他语言可能会更快更方便的使用( ╯□╰ )】。下面附上工具链接和使用方法。\n\n工具源码地址\n\n\n\n导出多说评论\n进入多说后台选择 工具-&gt;导出数据。\n勾上 包含文章数据 和 包含评论数据 两个选项。\n导出后是一个 JSON 文件，为了方便查看可以使用 在线代码格式化 工具。\n\n使用工具转化\n点击下载 转化工具，并解压。\n将导出的多说 JSON 文件重命名为 duoshuo.json 放入 data 文件夹下。【先删除掉存在的文件吧，其实是我的多说评论数据】\n双击运行 run.bat。将会在 data 文件夹下生成 duoshuo-format.json 【格式化后的多说评论文件，方便查看】和 disqus.xml【导入到 Disqus 的 XML 文件】。\n\n注意：如果发现并没有生成以上的两个文件，或者生成的文件数据有误，请使用以下方式运行程序。\n\n按住 Shift + 鼠标右键选择 在此处打开命令行窗口【Windows】或者打开终端进入项目目录下【Linux】。\n输入以下命令并回车：java -jar DuoshuoToDisqus.jar\n这种方式运行的好处是可以看到程序出错信息，同时你可以在命令最后输入你的多说评论文件路径【就不用将多说评论文件放入到 data 文件夹下了。】java -jar DuoshuoToDisqus.jar C:\\duoshuo.json\n\n\n\n导入到 Disqus 中\n点击链接 进入到导入页面，选择你要导入评论的站点。\n选择刚刚生成的 disqus.xml 文件，后面的选项选择 WordPress(WXR)，点击 Upload。\n接下来静静的等待导入完成，可以看到导入的评论和文章数量，如果出错的话可以看到错误。\n\n总结整个工具其实就是解析多说的 JSON 文件并转化成 Disqus 评论的 XML 文件。想要自己用 Java 实现的可以参考以下链接：\n\n多说评论格式Disqus 评论格式Jackson - Java Object 与 JSON 之间的转化工具Java 通过 DOM 方式解析、创建 XML工具源码地址\n\n此工具需要 Java 运行环境，可以去网上搜索安装配置一下。另外此工具没有做什么非法输入的处理，所以不要尝试做一些奇怪的事情。如果运行出错请检查一下你的源多说 JSON 文件是否有错误或者使用方式是否有错，有任何问题或者想要我帮忙转化的请在下方留言或者 联系我。很高兴可以帮助到你(●’◡’●)。\n\n","categories":["Hexo"],"tags":["Hexo","Java","Disqus"]},{"title":"Chrome 配置 SwitchyOmega","url":"/blog/2017/04/09/chrome-SwitchyOmega/","content":"\n此文章是以 Shadowsocks 代理为例，若想使用 Shadowsocks 请先安装对应系统的客户端并启动。详情请参考：\n\n站在 Shadowsocks 的肩膀上发现精彩的世界 | 笑话人生\n\nChrome 浏览器无论是用户体验、强大的功能还是丰富的扩展程序都完爆国内的各种浏览器好不好 (╯‵□′)╯︵┻━┻。强烈推荐啊！目前已经可以在不翻墙的情况下去下载 Chrome（桌面版） 了，账号数据同步方面也不需要翻墙了。鼓掌撒花 ★,°:.☆(￣▽￣)/$:.°★ \nSwitchyOmegaGoogle Chrome 浏览器上的一个代理扩展程序，可以轻松快捷地管理和切换多个代理设置。比如我们接下来要介绍的 自动切换模式。\n\n\n下载安装点击 SwitchyOmega，下载页面有详细的安装教程，仔细看一下就好。\n配置 Shadowsocks 情景模式\n打开 Chrome， 点击右上角的  图标，再点击 选项。\n点击左侧的 新建情景模式，输入情景模式名称 Shadowsocks（自己任意设置名称），类型选择第一个 代理服务器。创建完成后做如下配置：\n你也可以自己设置不代理的地址列表。如上图。\n保存后你就可以通过这个情景模式科学上网了。\n\n配置自动切换模式配置好 Shadowsocks 情景模式后虽然可以使用 Chrome 浏览器科学上网了，但是这样的话无论你访问什么网站都会走代理，有时候访问国内的一些网站反而会很慢，这时候自动切换模式就解决了这个问题。下面介绍一下如何配置自动切换模式。\n\n点击左侧的 自动切换，或者自己新建情景模式，类型选择第二个 自动切换模式。然后做如下配置：\n\n\n切换规则 是在访问 条件设置 的域名时候使用后面设置的 情景模式。比如图中我设置 *.google.com 和 *.github.com 使用 Shadowsocks 情景模式（刚刚创建的那个情景模式）。我们可以点击 添加条件 来添加自己的规则。\n将图中 规则列表规则 前面的框打 √，再将后面的 情景模式 设置为 Shadowsocks，意思是规则列表中的内容，我们使用 Shadowsocks 情景模式。然后 规则列表设置 中：\n规则列表格式： AutoProxy；\n规则列表网址： https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt\n\n\n这样设置完成 规则列表规则 后就不需要在切换规则中一个一个添加条件了。\n切换规则 最后一行的 默认情景模式 代表不在规则列表中网址我们使用 直接连接 情景模式，也就是说不走代理。\n\n参考资料\nSwitchyOmega | GitHubgfwlist | GitHub\n\n\n","categories":["Shadowsocks"],"tags":["Shadowsocks","翻墙","SwitchyOmega"]},{"title":"520·答辩·校庆·校园文化夜·非酋高级成就","url":"/blog/2017/05/20/520/","content":"\n经过了几个月的时间，终于完成了大学的最后一项任务：毕业设计（包括毕业项目和毕业论文）。当然，答辩这天正好赶上校庆，赶上校园文化夜，赶上期待已久的阴阳师高级非酋成就。赶上一切的一切。这一天给我的惊喜太多，给我的纪念太多，这一天，应该是本科毕业前第一个有意义的一天（以后还有毕业典礼什么的啊！o(￣▽￣)ブ）必须把这么重要的一天记下来！【以下图片都是手机拍摄的！原谅我的渣画质！】\n\n\n毕业答辩之前还在想，这是大学最后一次“作业”了，而且并不是那么容易。没想到真投入进去的时候，好像并没有那么难。之前还听学长说论文有多难写，要修改很多遍。答辩时还有人不过，等着第二次答辩。但真正自己做起来，投入进去后，就不会有什么担心了，写完论文的时候，我还在想，我竟然不知不觉写了这么多字。为了防止学校查重不过，自己还花了钱提前查重！进到答辩现场的时候，说不紧张是肯定没人信的，好歹评审老师是那种比较逗逼的人（CZY &amp; LJ），并没有给学生太大的压力。一下午竟然就这么快过去了！宣布通过名单的时候还是难以置信，自己就这样要毕业了呢，以至于后面我一直问思思姐，我真的过了么？可以毕业了么？其实只要自己认真做了，毕业还是很简单的。最重要的一点是！我忘记拍照留念了啊！还是当时太紧张了啊！(╯‵□′)╯︵┻━┻\n校庆520这天还是南大的校庆，每次校庆，学校都会发两张5元餐券，以前一直都是用一张留一张纪念，但是后来都找不到了呢！所以这次要拍照留念！哈哈哈哈！(●’◡’●)\n\n\n答辩完出来的时候看到了热烈庆祝南京大学建校115周年的展板【其实去答辩的时候就看到了，但那个时候谁还有心思拍照呢？】不完美的是展板上写满了祝福的话或者名字啥的，虽然大家并无恶意，不过整个展板拍照后就感觉好乱╮(╯▽╰)╭\n\n\n非酋高级成就就在去仙林校区【我在鼓楼校区】参加校园文化夜的地铁上，思思姐帮我抽卡，庆祝下答辩完成。意料之内的没有SSR，但是发现拿到了期待已久的高级非酋成就！【抽卡400张没有SSR的成就】虽然这是非洲人的一种表现，但是我早就习惯了呢，而且我在意的是500连抽没有SSR的非洲阴阳师成就，会送一个稀有头像框——月见黑。这比抽到SSR的概率低的多啊。\n\n\n校园文化夜这是大学四年里第三次参加了，也是最后一次。大一大二就在仙林，每年都会参加，大三搬到鼓楼，有事耽搁了一次没去。文化夜还是老样子，社团、院系都有自己的展台，在宿舍区中间的路上。先去领盖章的一页纸，每去一个展台玩小游戏都会帮你盖章，然后去领奖品。由于答辩结束的比较晚，去到仙林都已经快8点了，首先当然是找软院的展台啊！我和思思姐正玩着呢，突然看到有人坐在电脑前，玩着小游戏。我就好奇的凑过去，这不是软院的传统，大一时候程序设计大赛做的小游戏么？赶紧上去试玩了一下，相比之下，真的比我当时做的好多了呢，长江后浪推前浪啊~接下来看到了漂亮的汉服社小姐姐，思思姐每次来都会试穿汉服让我拍照呢。\n\n\n下面这张是从思思姐那要来的大一时候穿汉服的思思姐，因为那个时候还没在一起呢。【// 相比之下是不是胖了好多！つ﹏⊂】\n\n\n后来又遇到了一个听歌识曲的游戏，我问他，有动漫方面的么？他先放了一首魔卡少女樱的主题曲，又放了一首四驱兄弟的主题曲，都被我猜到了，毕竟这都是童年呢！最后放了一首虹猫蓝兔七侠传，我竟然没听出来，看来要补番了！没逛几个展台，发现大家基本上都在收拾东西，差不多结束了，我和思思姐准备去换礼物了，然后……工作人员说礼物已经发完了。(╯‵□′)╯︵┻━┻\n520520这天怎么少得了秀恩爱呢！毕设一起做、一起答辩、一起去仙林参加校园文化夜，感谢思思姐一直的陪伴。以后也会是开开心心的每一天呢(^_^)\n\n\n\n","categories":["随笔"],"tags":["随笔"]},{"title":"2018年立个FLAG-坚持写博客！","url":"/blog/2018/06/24/new-2018/","content":"\n时隔一年，终于想起来还有博客这种事情。工作忙的昏天黑地，但是又学不到什么太多的东西，看到很多周围的同学变得越来越厉害，有自己的目标，我也不想一直这样平淡的度过，总的想点提升不是？开始为自己的将来做准备吧！\nFLAG我就立在这了！一定要坚持下去！积少成多！(╯‵□′)╯︵┻━┻\n\n\n\n","categories":["随笔"],"tags":["随笔"]},{"title":"C语言头文件使用总结","url":"/blog/2018/06/25/c-header/","content":"\n在平时工作中看到前人写的一些C头文件，很有感触。自己在写的时候也遇到了很多问题，比如重复引用导致宏或者常量重复定义，不知道该使用双引号还是使用尖括号引用等问题，决定先总结一下。做个笔记，随时复习。o(￣▽￣)ブ\nC语言头文件C语言头文件一般包含了函数声明，宏定义，常量等代码。我们在使用#include引用头文件。可以被多个c文件引用，避免了重复代码，减少了错误。让代码更加规范。A simple practice in C 或 C++ 程序中，建议把所有的常量、宏、系统全局变量和函数原型写在头文件中，在需要的时候随时引用这些头文件。\n\n\n头文件引用系统已经存在了很多头文件，当然，我们也可以自己编写。c文件引用头文件相当于直接复制到文件中，但是这样多个文件要使用这段代码的时候，就产生了很多重复代码，也不方便管理。引用存在两种引用形式。一种#include &quot;cylong.h&quot;，一种是 #include &lt;cylong.h&gt;。那这两种方式有什么区别呢？我们平时使用的时候又怎么用呢？\n#include &lt;cylong.h&gt;\n\n这种形式是引用系统文件，在系统目录下搜索此头文件。比如#include &lt;stdio.h&gt;等\n#include &quot;cylong.h&quot;\n这种形式是引用用户文件，优先在当前目录下搜索此头文件，然后再去系统目录下搜索此头文件。\n所以无论是我们自己写的头文件还是引用系统头文件，使用#include &quot;cylong.h&quot;都不会出错。但是这样并不标准，标准规定，包含标准头文件或系统头文件时应使用尖括号，包含自定义头文件时可使用双引号。\n避免重复引用经常在写代码的时候，不经意间，我们会引用同一个头文件两次，那么我们会遇到很多重复定义的错误，为了避免这样的事情发生，我们需要将头文件里的内容放到编译宏中\n#ifndef CYONG_H#define CYLONG_Hvoid fun ();// some codes#endif CYLONG_H\n\n当我们第一次引用的时候，未定义CYLONG_H宏，所以会继续编译下面的代码，当第二次引用的时候，#ifndef CYLONG_H为假，就不会编译下面的代码了，自然不会存在重复定义等问题。\n公共头文件在程序代码中，经常很多c文件会引用一些相同的头文件，这个时候，我们就可以定义一个包含这些相同头文件的头文件common.h。例如：\n#ifndef COMMON_H#define COMMON_H#include &lt;stdio.h&gt;#include &quot;cylong.h&quot;#include &quot;lsyu.h&quot;#endif COMMON_H\n\n然后我们就可以在每个需要的c文件中引用这个common.h头文件。但是需要注意的是，这个文件里除了头文件引用以外，建议不要再写其他的代码。\n参考资料\nC 头文件 | 菜鸟教程C++ #include—尖括号和双引号的区别 | C语言中文网\n\n\n","categories":["C/C++"],"tags":["C/C++","头文件"]},{"title":"Java 8 的 Lambda 表达式和 Stream API","url":"/blog/2019/03/18/lambda/","content":"\n简介Java 8 的 Lambda 表达式提供了强大的函数化的编程能力，将函数作为参数传递进方法中。免去了使用匿名方法的麻烦，这样使可读性更好，表达更清晰。它是推动 Java 8 发布的最重要新特性。Lambda 表达式的简洁让人非常激动，但是如果第一次看到一段复杂的Lambda表达式的代码，会让你非常头疼，对于初学者来说，可能就是一段垃圾代码，因为你并不知道 Lambda 表达式到底在表达什么╮(╯▽╰)╭下面我们就举一些小例子由浅入深的了解下 Lambda 表达式。\n\n\n基本语法(parameters) -&gt; expression 或者 (parameters) -&gt;&#123; statements; &#125;\n个人理解，把 Lambda 表达式看成咱们上学的时候学的函数 f(x) = x + 1 会让你更容易理解。\n以下是lambda表达式的重要特征:\n\n可选类型声明：不需要声明参数类型，编译器可以统一识别参数值。\n可选的参数圆括号：一个参数无需定义圆括号，但多个参数需要定义圆括号。\n可选的大括号：如果主体包含了一个语句，就不需要使用大括号。\n可选的返回关键字：如果主体只有一个表达式返回值则编译器会自动返回值，大括号需要指定明表达式返回了一个数值。\n\n简单实例public interface Operation &#123;    int calc(int a, int b);&#125;\n\npublic interface Greeting &#123;    void say(String msg);&#125;\n\npublic class LambdaTest &#123;    public static int calc(int a, int b, Operation operation) &#123;        return operation.calc(a, b);    &#125;    public static void say(String msg, Greeting greeting) &#123;        greeting.say(msg);    &#125;    public static void main(String args[]) &#123;        // 类型声明        Operation addition = (int a, int b) -&gt; a + b;        // 不用类型声明        Operation subtraction = (a, b) -&gt; a - b;        // 大括号中的返回语句。        // 一般只有存在多行语句的时候才会使用，单行语句不需要使用，部分IDE会提示去掉大括号。        Operation multiplication = (int a, int b) -&gt; &#123;            return a * b;        &#125;;        // 没有大括号及返回语句        Operation division = (int a, int b) -&gt; a / b;        System.out.println(&quot;10 + 5 = &quot; + LambdaTest.calc(10, 5, addition));        System.out.println(&quot;10 - 5 = &quot; + LambdaTest.calc(10, 5, subtraction));        System.out.println(&quot;10 x 5 = &quot; + LambdaTest.calc(10, 5, multiplication));        System.out.println(&quot;10 / 5 = &quot; + LambdaTest.calc(10, 5, division));        // 不用括号        Greeting sayHello = message -&gt; System.out.println(&quot;Hello &quot; + message);        // 用括号        Greeting sayBye = (message) -&gt; System.out.println(&quot;Bye &quot; + message);        LambdaTest.say(&quot;cylong&quot;, sayHello);        LambdaTest.say(&quot;cylong&quot;, sayBye);        LambdaTest.say(&quot;cylong&quot;, message -&gt; System.out.println(&quot;Hi &quot; + message));        // 以前的匿名类        LambdaTest.say(&quot;cylong&quot;, new Greeting() &#123;            @Override            public void say(String msg) &#123;                System.out.println(&quot;Hello &quot; + msg);            &#125;        &#125;);    &#125;&#125;\n\n以上代码的输出为：\n10 + 5 = 1510 - 5 = 510 x 5 = 5010 / 5 = 2Hello cylongBye cylongHello cylongHello cylong\n\nJava 8 的 Stream API其实目前用 Lambda 表达式最多的地方就是 Java 8 的新特性——Stream API，借助于 Lambda 表达式，极大的提高编程效率和程序可读性。同时它提供串行和并行两种模式进行汇聚操作，并发模式能够充分利用多核处理器的优势，使用 fork/join 并行方式来拆分任务和加速处理过程。Java 8 中的 Stream 是对集合（Collection）对象功能的增强，Stream 不是集合元素，它不是数据结构并不保存数据，它是有关算法和计算的。在以前的 Java API中，我们更多的是使用for或者Iterator来遍历集合，同时我们可能会对集合里的数据进行过滤，计算等等处理，导致代码量非常的多，还容易出错。而使用 Stream，用户只要给出需要对其包含的元素执行什么操作，比如 “过滤掉长度大于 10 的字符串”、“获取每个字符串的首字母”等，Stream 会隐式地在内部进行遍历，做出相应的数据转换。下面我们就看一些例子，深入了解下 Stream 的使用。\n集合迭代List&lt;Integer&gt; numList = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);// 普通的 for 循环for (int n : numList) &#123;    System.out.println(n);&#125;// 使用 Lambda 表达式numList.forEach(n -&gt; System.out.println(n));// 使用 Java 8 的方法引用// 看起来像C++的作用域解析运算符numList.forEach(System.out::println);\n上面的例子包含普通的for循环，Lambda表达式遍历的方式，最后一种方式是方法引用，让代码量再次减少，代码更加清晰。\n集合过滤// 输出集合中所有大于5的值numList.stream().filter(n -&gt; n &gt; 5).forEach(System.out::println);\n\n上面的代码中 filter(n -&gt; n &gt; 5)就是获得集合中大于5的所有值，filter 的参数是 java.util.function.Predicate，返回值是一个 Stream。使用 Predicate 可以向API方法添加逻辑，用更少的代码支持更多的动态行为。上面的例子就是使用 Predicate 对集合进行过滤。在 filter() 方法中，我们可以写更多复杂的逻辑来过滤集合元素。甚至可以使用 and() 或者 or()等合并多个条件，如下面这样。\n// 输出集合中所有大于5并且小于8的值Predicate&lt;Integer&gt; start = n -&gt; n &gt;5;Predicate&lt;Integer&gt; end = n -&gt; n &lt;8;numList.stream().filter(start.and(end)).forEach(System.out::println);\n\n另外，关于 filter() 方法有个常见误解。在现实生活中，做过滤的时候，通常会丢弃部分，但使用filter()方法则是获得一个新的列表，且其每个元素符合过滤原则。\n// 创建一个新的集合，所有元素的值大于5List&lt;Integer&gt; newNumList = numList.stream().filter(n -&gt; n &gt; 5).collect(Collectors.toList());newNumList.forEach(System.out::println);System.out.println();numList.forEach(System.out::print);\n\n输出是：\n67891012345678910\n\nStream 的 map 示例// 将集合中的所有值计算平方后输出numList.stream().map(n -&gt; n * n).forEach(System.out::println);\n\n本例介绍最广为人知的函数式编程概念 map。它允许你将对象进行转换。例如在本例中，我们将 n -&gt; n * n lambda 表达式传到 map() 方法，后者将其应用到流中的每一个元素。然后用 forEach() 将列表元素打印出来。\nStream 的 Reduce 示例// 将集合中的所有值求和int result = numList.stream().reduce((sum, n) -&gt; sum + n).get();System.out.println(result);\n\n在上个例子中，可以看到map将集合类（例如列表）元素进行转换的。还有一个 reduce() 函数可以将所有值合并成一个。Map和Reduce操作是函数式编程的核心操作，因为其功能，reduce 又被称为折叠操作。另外，reduce 并不是一个新的操作，你有可能已经在使用它。SQL中类似 sum()、avg() 或者 count() 的聚集函数，实际上就是 reduce 操作，因为它们接收多个值并返回一个值。流API定义的 reduce() 函数可以接受lambda表达式，并对所有值进行合并。IntStream这样的类有类似 average()、count()、sum() 的内建方法来做 reduce 操作，也有mapToLong()、mapToDouble() 方法来做转换。这并不会限制你，你可以用内建方法，也可以自己定义。\n计算集合元素的最大值、最小值、总和以及平均值// 计算集合元素的最大值、最小值、总和以及平均值IntSummaryStatistics stats = numList.stream().mapToInt((x) -&gt; x).summaryStatistics();System.out.println(&quot;Highest prime number in List : &quot; + stats.getMax());System.out.println(&quot;Lowest prime number in List : &quot; + stats.getMin());System.out.println(&quot;Sum of all prime numbers : &quot; + stats.getSum());System.out.println(&quot;Average of all prime numbers : &quot; + stats.getAverage());\n\n输出：\nHighest prime number in List : 10Lowest prime number in List : 1Sum of all prime numbers : 55Average of all prime numbers : 5.5\n\n并行流 parallelStream上文有提到，Stream API 提供串行和并行两种模式进行汇聚操作，并发模式能够充分利用多核处理器的优势。串行流就是上面的 stream，而想要并行操作，就需要使用 parallelSteram。下面举一个例子来看看 stream 和 parallelStream 的区别。\npublic class ParallelStreamTest &#123;    public static void main(String[] args) &#123;        List&lt;Integer&gt; numList = Arrays.asList(1, 2, 3, 4, 5);        doFor(numList);        doStream(numList);        doParallelStream(numList);    &#125;    private static void doFor(List&lt;Integer&gt; numList) &#123;        long start = System.currentTimeMillis();        for (int num : numList) &#123;            try &#123;                Thread.sleep(1000);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;            System.out.print(num);        &#125;        System.out.println();        long stop = System.currentTimeMillis();        System.out.println(&quot;doFor: &quot; + (stop - start));    &#125;    private static void doStream(List&lt;Integer&gt; numList) &#123;        long start = System.currentTimeMillis();        numList.stream().forEach(num -&gt; &#123;            try &#123;                Thread.sleep(1000);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;            System.out.print(num);        &#125;);        System.out.println();        long stop = System.currentTimeMillis();        System.out.println(&quot;doStream: &quot; + (stop - start));    &#125;    private static void doParallelStream(List&lt;Integer&gt; numList) &#123;        long start = System.currentTimeMillis();        numList.parallelStream().forEach(num -&gt; &#123;            try &#123;                Thread.sleep(1000);            &#125; catch (InterruptedException e) &#123;                e.printStackTrace();            &#125;            System.out.print(num);        &#125;);        System.out.println();        long stop = System.currentTimeMillis();        System.out.println(&quot;doParallelStream: &quot; + (stop - start));    &#125;&#125;\n\n输出：\n12345doFor: 500312345doStream: 500334251doParallelStream: 1009\n\n代码上 stream 和 parallelStream 语法差异较小，用法基本一样。从执行结果来看，stream 顺序输出，而 parallelStream 无序输出；parallelStream 执行耗时是 stream 的五分之一，stream 和 for 循环用时一样。可以看到在当前测试场景下，parallelStream 获得的相对较好的执行性能，那 parallelStream 背后到底是什么呢？要深入了解 parallelStream，首先要弄明白 ForkJoin 框架和 ForkJoinPool。ForkJoin 框架是 java 7 中提供的并行执行框架，他的策略是分而治之。说白了，就是把一个大的任务切分成很多小的子任务，子任务执行完毕后，再把结果合并起来。\nparallelStream 使用注意点在开发过程中，经常会遇到遍历一个很大的集合做重复的操作，这时候如果使用串行执行会相当耗时，因此一般会采用多线程来提速。但是 parallelStream 若使用不当，很容易掉进陷阱中。总结以下几点需要注意：\n\nparallelStream 对集合操作是无序的，所以若需要顺序操作，请使用 stream 或者使用 parallelStream().forEachOrdered，后者执行时间就和 stream一样了，并不会提高效率。\nparallelStream 速度并不会总是比 stream 快。将上面的例子修改为 Thread.sleep(1)，输出结果为：\n\n12345doFor: 1012345doStream: 1232154doParallelStream: 13\n\n可见并不是并行执行就是性能最好的，要根据具体的应用场景测试分析。这个例子中，每个子任务执行时间较短，而线程切换消耗了大量时间。\n\nparalleStream 是非线程安全的！非线程安全！非线程安全！重要的事情说三遍。下面看一个例子就可以很明显的看到了。\n\npublic class ThreadSafeTest &#123;    private static List&lt;Integer&gt; list1 = new ArrayList&lt;&gt;();    private static List&lt;Integer&gt; list2 = new ArrayList&lt;&gt;();    private static List&lt;Integer&gt; list3 = new ArrayList&lt;&gt;();    private static Lock lock = new ReentrantLock();    public static void main(String[] args) &#123;        IntStream.range(0, 10000).forEach(list1::add);        IntStream.range(0, 10000).parallel().forEach(list2::add);        IntStream.range(0, 10000).forEach(i -&gt; &#123;            lock.lock();            try &#123;                list3.add(i);            &#125;finally &#123;                lock.unlock();            &#125;        &#125;);        System.out.println(&quot;串行执行的大小：&quot; + list1.size());        System.out.println(&quot;并行执行的大小：&quot; + list2.size());        System.out.println(&quot;加锁并行执行的大小：&quot; + list3.size());    &#125;&#125;\n\n输出：\n串行执行的大小：10000并行执行的大小：9592加锁并行执行的大小：10000\n\n显而易见，stream.parallel.forEach()中执行的操作并非线程安全。如果需要线程安全，可以把集合转换为同步集合，即：Collections.synchronizedList(new ArrayList&lt;&gt;())。也可以像例子中的那样，对操作进行加锁。\n总结\nLambda 表达式提供了 Java 的函数化编程能力，取代了匿名内部类。让我们的代码量更少更美观。\nLambda表达式在Java中又称为闭包或匿名函数。\nStream API 提供了强大的集合操作。让我们在开发过程中更关心逻辑，而不是怎么详细的去实现。\nstream 是串行的，线程安全的。parallelStream 是并行的，线程不安全的，在使用过程中尤其要注意。\n\n参考资料\nJava 8 Lambda 表达式 | 菜鸟教程Java 8 中的 Streams API 详解 | IBM DeveloperJava 8 Lambda 表达式10个示例 | ImportNewJava 8 parallelStream 浅析 | 知乎Java 8 parallelStream 并发安全的思考 | puyangsky 博客园深入浅出 parallelStream | 梦铃之境的专栏\n\n\n","categories":["Java"],"tags":["Java","Lambda","流API"]},{"title":"愚人节快乐","url":"/blog/2019/04/01/april-fools-day/","content":"\n事情起因是看到一个面试题，原题大概是，生成 N 个 1 到 1000 之间的随机数(N &lt;= 1000)，对于重复的数字，只取其中一个，并对结果进行从小到大排序。正好前几天了解了下 Java 的 Lambda 表达式和 Stream API，突然想起来，这可以一行代码搞定啊。于是就尝试的写了一下。【原题还是比较复杂的，我就提取了精华部分】\n\n\n一行代码能搞定的事情从不会多写【为了美观我还是换行了】。\nIntStream.range(0, 100)    .map(x -&gt; (int)(Math.random() * 1000 + 1))    .distinct()    .sorted()    .forEach(System.out::println);\n\n自从 Java 8 增加了 Lambda 表达式和 Stream API 后，很多操作都非常的方便，可以参考我上一篇博客：\n\nJava 8 的 Lambda 表达式和 Stream API | 笑话人生\n\n其实这就是一篇愚人节凑数用的博客，顺便祝愿下女票可以找到心仪的实习，相信自己，努力终将不会白费 (^_^)\n\n","categories":["Java"],"tags":["Java","随笔","Lambda"]},{"title":"浅谈 HashMap","url":"/blog/2019/09/10/hashmap/","content":"\n前言HashMap 是 Java 编程中非常常用的一种数据结构，在各种面试中也是频繁出现的问题。我是一次定位问题，发现了服务后台 CPU 和内存飙升，原因是使用 HashMap 的时候，并发插入数据在 resize() 方法中产生循环链表导致死循环（JDK8 已经解决）。看到代码中大量的 HashMap，不自然的就想先了解下 HashMap 的实现原理和其线程安全问题。此文主要是介绍 HashMap 的实现原理，关于如何定位 CPU 和内存飙升问题，可以看另外一篇博客：\n\nJstack 使用介绍 | 笑话人生\n\n\n\n存储结构HashMap 是一种存储 key -&gt; value 键值对的数据结构，每一个键值对称为 Entry，这些 Entry 存储在一个 table 数组中，每个 Entry 是一个链表结构，有一个 next 指针指向下一个元素。接下来我们看一下比较重要的代码。\n\n\n/** * Basic hash bin node, used for most entries.  (See below for * TreeNode subclass, and in LinkedHashMap for its Entry subclass.) */static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;    final int hash;    final K key;    V value;    Node&lt;K,V&gt; next;&#125;/** * The table, initialized on first use, and resized as * necessary. When allocated, length is always a power of two. * (We also tolerate length zero in some operations to allow * bootstrapping mechanics that are currently not needed.) */transient Node&lt;K,V&gt;[] table;/** * The number of key-value mappings contained in this map. */transient int size;/** * The number of times this HashMap has been structurally modified * Structural modifications are those that change the number of mappings in * the HashMap or otherwise modify its internal structure (e.g., * rehash).  This field is used to make iterators on Collection-views of * the HashMap fail-fast.  (See ConcurrentModificationException). */transient int modCount;/** * The next size value at which to resize (capacity * load factor). * * @serial */// (The javadoc description is true upon serialization.// Additionally, if the table array has not been allocated, this// field holds the initial array capacity, or zero signifying// DEFAULT_INITIAL_CAPACITY.)int threshold;/** * The load factor for the hash table. * * @serial */final float loadFactor;\n\n\nNode 就是上面说的 Entry 的实现，用来保存键值对，实现了 Map.Entry 接口。其中 hash 的值是通过 hash() 方法计算出来，key 和 value 是存入的值，next 是出现哈希冲突的时候，会使用 next 指向链表中的下一个元素对象。\ntable 存储 Entry 的数组，初始长度是 DEFAULT_INITIAL_CAPACITY = 16。\nsize 是实际存储的键值对数量。\nmodCount 记录内部结构发生的次数，比如 put、remove 操作等。常见的一边遍历元素一边删除元素的操作就会报 java.util.ConcurrentModificationException。\nloadFactor 负载因子，默认是 DEFAULT_LOAD_FACTOR = 0.75f。\nthreshold 允许存储的最大元素数量是通过 table 数组长度 * loadFactor 负载因子得出。\n\nput 操作在 put 操作中，将元素 key 进行 hash 计算并找到 table 的数组下标，将 Entry 直接放入数组中，作为头元素，若通过算法得到的该数组元素已经有了元素（俗称 hash 冲突，链表结构出现的实际意义也就是为了解决 hash 冲突的问题）。当新来的 Entry 映射到冲突的数组位置时，只需要插入到对应的链表即可。接下来直接在源码上解释。\n/** * Implements Map.put and related methods. * * @param hash hash for key * @param key the key * @param value the value to put * @param onlyIfAbsent if true, don&#x27;t change existing value * @param evict if false, the table is in creation mode. * @return previous value, or null if none */final V putVal(int hash, K key, V value, boolean onlyIfAbsent,               boolean evict) &#123;    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;    // 首先判断 table 数组是否为空，为空则创建 table。    if ((tab = table) == null || (n = tab.length) == 0)        n = (tab = resize()).length;    if ((p = tab[i = (n - 1) &amp; hash]) == null)        // 如果通过 (n - 1) &amp; hash 找到的数组元素为空，则直接创建新的 node，作为头节点。        tab[i] = newNode(hash, key, value, null);    else &#123;        Node&lt;K,V&gt; e; K k;        // 找到数组元素，判断是相同的 key 值。        if (p.hash == hash &amp;&amp;            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))            e = p;        else if (p instanceof TreeNode)            // 如果是红黑树结构，则向树插入数据            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);        else &#123;            // 该数组元素 hash 相等，key 不等，同时链表长度 &lt; 8。进行遍历寻找元素，有就覆盖无则新建            for (int binCount = 0; ; ++binCount) &#123;                if ((e = p.next) == null) &#123;                    // 向链表尾插入数据                    p.next = newNode(hash, key, value, null);                    if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st                        // 链表长度 &gt;=8 结构转为红黑树                        treeifyBin(tab, hash);                    break;                &#125;                if (e.hash == hash &amp;&amp;                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))                    break;                p = e;            &#125;        &#125;        // 如果是存在的元素，则根据条件是否覆盖之前的值。        if (e != null) &#123; // existing mapping for key            V oldValue = e.value;            if (!onlyIfAbsent || oldValue == null)                e.value = value;            afterNodeAccess(e);            return oldValue;        &#125;    &#125;    // 内部结构变化次数 +1    ++modCount;    // 当 map 的实际大小大于了 threshold 则进行 resize 操作，将最大存储数量变为原来的两倍。    if (++size &gt; threshold)        resize();    afterNodeInsertion(evict);    return null;&#125;\n\n这里确定 table 的数组下标使用的 hash 算法是 (n - 1) &amp; hash(key)，相对于取模运算，使用位运算效率更高。key 值的 hash 计算是高 16bit 不变，低 16bit 和高 16bit 做了一个异或。主要是为了保证 n 太小的时候，高低位均能参与下标的计算。\n/** * Computes key.hashCode() and spreads (XORs) higher bits of hash * to lower.  Because the table uses power-of-two masking, sets of * hashes that vary only in bits above the current mask will * always collide. (Among known examples are sets of Float keys * holding consecutive whole numbers in small tables.)  So we * apply a transform that spreads the impact of higher bits * downward. There is a tradeoff between speed, utility, and * quality of bit-spreading. Because many common sets of hashes * are already reasonably distributed (so don&#x27;t benefit from * spreading), and because we use trees to handle large sets of * collisions in bins, we just XOR some shifted bits in the * cheapest possible way to reduce systematic lossage, as well as * to incorporate impact of the highest bits that would otherwise * never be used in index calculations because of table bounds. */static final int hash(Object key) &#123;    int h;    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125;\n\nget 操作get 方法通过 hash 寻找到 Entry 数组下标，找到头节点，然后顺着对应链表的头节点，一个一个向下来查找。由于 JDK8 引用了红黑树结构，在链表元素过多时，JDK8 的实现将比 JDK7 在 get 和 put 操作上效率高上很多。\n/** * Implements Map.get and related methods. * * @param hash hash for key * @param key the key * @return the node, or null if none */final Node&lt;K,V&gt; getNode(int hash, Object key) &#123;    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;        (first = tab[(n - 1) &amp; hash]) != null) &#123;        if (first.hash == hash &amp;&amp; // always check first node            ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))            return first;        if ((e = first.next) != null) &#123;            if (first instanceof TreeNode)                return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);            do &#123;                if (e.hash == hash &amp;&amp;                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))                    return e;            &#125; while ((e = e.next) != null);        &#125;    &#125;    return null;&#125;\n\nresize 操作当 map 的实际大小大于了 threshold 则进行 resize 操作，将最大存储数量变为原来的两倍。接下来我们看一下源码。\n/** * Initializes or doubles table size.  If null, allocates in * accord with initial capacity target held in field threshold. * Otherwise, because we are using power-of-two expansion, the * elements from each bin must either stay at same index, or move * with a power of two offset in the new table. * * @return the table */final Node&lt;K,V&gt;[] resize() &#123;    Node&lt;K,V&gt;[] oldTab = table;    int oldCap = (oldTab == null) ? 0 : oldTab.length;    int oldThr = threshold;    int newCap, newThr = 0;    if (oldCap &gt; 0) &#123;        // 超过最大限制，不进行扩容        if (oldCap &gt;= MAXIMUM_CAPACITY) &#123;            threshold = Integer.MAX_VALUE;            return oldTab;        &#125;        // 进行原始长度2倍扩容        else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)            newThr = oldThr &lt;&lt; 1; // double threshold    &#125;    // 第一次初始化    else if (oldThr &gt; 0) // initial capacity was placed in threshold        newCap = oldThr;    else &#123;               // zero initial threshold signifies using defaults        newCap = DEFAULT_INITIAL_CAPACITY;        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);    &#125;    // 第一次初始化    if (newThr == 0) &#123;        float ft = (float)newCap * loadFactor;        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?                  (int)ft : Integer.MAX_VALUE);    &#125;    // 新的最大允许元素数量值    threshold = newThr;    @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)    // 新的 table 数组     Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];    table = newTab;    if (oldTab != null) &#123;        // 遍历老数组        for (int j = 0; j &lt; oldCap; ++j) &#123;            Node&lt;K,V&gt; e;            if ((e = oldTab[j]) != null) &#123;                oldTab[j] = null;                // 直接按照原始索引放入新数组中                if (e.next == null)                    newTab[e.hash &amp; (newCap - 1)] = e;                else if (e instanceof TreeNode)                    ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);                else &#123; // preserve order                    // 遍历链表                    Node&lt;K,V&gt; loHead = null, loTail = null;                    Node&lt;K,V&gt; hiHead = null, hiTail = null;                    Node&lt;K,V&gt; next;                    do &#123;                        next = e.next;                        if ((e.hash &amp; oldCap) == 0) &#123;                            if (loTail == null)                                loHead = e;                            else                                loTail.next = e;                            loTail = e;                        &#125;                        else &#123;                            if (hiTail == null)                                hiHead = e;                            else                                hiTail.next = e;                            hiTail = e;                        &#125;                    &#125; while ((e = next) != null);                    if (loTail != null) &#123;                        loTail.next = null;                        newTab[j] = loHead;                    &#125;                    if (hiTail != null) &#123;                        hiTail.next = null;                        newTab[j + oldCap] = hiHead;                    &#125;                &#125;            &#125;        &#125;    &#125;    return newTab;&#125;\n\n线程安全HashMap 是非线程安全的，在多线程环境下对某个 HashMap 进行并行操作，可能会产生很多不可预期的情况。\n多线程 put 导致元素丢失实验代码如下：\npublic static void main(String[] args) throws InterruptedException &#123;    HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();    ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();    for (int i = 0; i &lt; 10000; i++) &#123;        list.add(i);    &#125;    list.forEach(i -&gt; map.put(i, i));    new Thread(() -&gt; &#123;        for (int i = 10000; i &lt; 20000; i++) &#123;            map.put(i, i);        &#125;    &#125;).start();    new Thread(() -&gt; &#123;        for (int i = 20000; i &lt; 30000; i++) &#123;            map.put(i, i);        &#125;    &#125;).start();    Thread.sleep(3000);    System.out.println(map.entrySet().size());&#125;\n\n输出：29402，元素少了很多。\n这里很好理解，我们看 put 的代码，假设我们的线程1和线程2同时在执行 put 方法。其中的的 key 值计算后落入了 table 的同一个位置。这个时候，两个线程同时执行p.next = newNode(hash, key, value, null);，此时两个线程的元素值就会互相覆盖掉。\nput 的同时 get 数据，可能会导致 get 的数据为 nullput 的时候，可能会产生 resize 操作，我们发现 resize 有如下代码：\nNode&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];table = newTab;\n\n这段代码会让新的 table 为空，这个时候调用 get 方法会获取到 null 数据。\nJDK7 中并发 put 会造成循环链表此问题在 JDK8 中已经解决，在这里是提醒下自己 JDK7 中的 resize 操作会产生循环链表导致死循环，毕竟之前项目中确确实实遇到了死循环的问题。\n\nJstack 使用介绍 | 笑话人生\n\n总结\n什么时候会使用 HashMap？他有什么特点？是基于 Map 接口的实现，存储键值对时，它可以接收 null 的键值，HashMap 存储着 Entry 对象。HashMap 是非线程安全的。如果需要线程安全，则使用 ConcurrentHashMap，否则使用 HashMap 就足够了。\n\n你知道 HashMap 的工作原理吗？equals() 和 hashCode() 的都有什么作用？通过对 key 的 hashCode() 计算下标 n - 1 &amp; hash，从而获得 table 下标的位置，然后用 key.equals() 方法去链表或树中去查找对应的节点。get 和 put 方法如上介绍。\n\n你知道 hash 的实现吗？为什么要这样实现？在 Java 1.8 的实现中，是通过 key.hashCode() 的高16位异或低16位实现的：(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)，主要是从速度、功效、质量来考虑的，这么做可以在 table 的长度 n 比较小的时候，也能保证考虑到高低 bit 都参与到 hash 的计算中，同时不会有太大的开销。\n\n如果 HashMap 的大小超过了负载因子(load factor)定义的容量，怎么办？如果超过了负载因子(默认0.75)，则会重新 resize 一个原来长度两倍的 HashMap，并且重新调用 hash 方法。\n\n\n感谢\nHashMap 底层实现原理 | 忆逝什么是HashMap | 小灰Java HashMap工作原理及实现 | Yikun深入解读HashMap线程安全性问题 | Mr羽墨青衫HashMap? ConcurrentHashMap? 相信看完这篇没人能难住你！ | crossoverJie\n\n\n","categories":["数据结构与算法"],"tags":["Java","数据结构与算法","HashMap","红黑树","数组","链表","线程安全","面试总结"]},{"title":"JStack 使用介绍","url":"/blog/2019/09/10/jstack/","content":"\n前言在项目中遇到一个问题，我们服务提供给外部的一个接口 queryXXX 一直返回 429 错误（Too Many Requests），接口没有返回值，而且服务越用越卡，要重启一下才能恢复。于是马上就想到是不是因为这个接口产生了死循环，导致接口无法正确返回，同时导致后台 CPU 和内存占用飙升，顺着这个思路定位下去，确实顺利的找到的问题所在。\n\n\n定位思路\n执行 free -m/free -h 查看服务的后台 CPU 和内存占用，发现服务占用的内存和 CPU 过高。\n执行 jps/ps/top 命令找到 CPU 和内存占用高的进程 ID(32033)。\n执行 top -H -p 32033，找到 %CPU 和 %MEM 占用高的 PID(60958)，转换成16进制 ee1e。\n执行 jstack -l 32033 &gt; stack.txt，打印调用栈信息。\n找到 stack.txt 日志里面的 nid=0xee1e（注意第三步的是十进制，日志里的是十六进制）对应接口服务，分析调用栈，发现 queryXXX 接口的状态一直是 RUNNING 状态，卡死。\n定位后发现代码中使用了流 API 的 parallelStream 导致的问题，原因是 parallelStream 是并行操作，我们这边使用了 HashMap，HashMap 是非线程安全的，并发插入数据在 resize() 方法中产生循环链表导致死循环（JDK8 已经解决），导致 queryXXX 接口的状态一直是 RUNNING，无返回值，CPU 和内存飙升。调用服务方在没有接受到返回的时候不断请求这个服务，于是产生了 429 错误。\n我们这边 HashMap 是局部变量，解决方法是将 parallelStream 并行流修改为 stream 串行流。如果此 HashMap 是那种全局变量，涉及并发操作，则可以改成使用 ConcurrentHashMap。\n\n关于 HashMap 的介绍可以参考：\n\n浅谈 HashMap | 笑话人生\n\n使用介绍JStack 是 java 自带的工具，在 jdk\\bin\\jstack.exe 位置。以下是 Windows 的示范，在 Linux 系统上功能更多。\nPS C:\\Program Files\\Java\\jdk-11.0.2\\bin&gt; .\\jstackUsage:    jstack [-l][-e] &lt;pid&gt;        (to connect to running process)Options:    -l  long listing. Prints additional information about locks    -e  extended listing. Prints additional information about threads    -? -h --help -help to print this help message\n\n一般常用的是以下的命令：\njstack -l [PID]jstack -F [PID]\n\n\n-l 选项会打印额外的信息，比如说锁信息。\n当进程挂起(hung)时，上面的命令可能没有响应，这时需要使用 -F 参数来强制执行 thread dump。\n\n接下来我们就可以分析打印的堆栈信息进行分析，比如我上面列举的那个问题：\n\n\n\nSection\nExample\n解释\n\n\n\n线程名字\nmain 和 Reference Handler\n可读的线程名字，这个名字可以通过 Thread 方法 setName 设定\n\n\n线程 ID\n#1\n每一个 Thread 对象的唯一 ID，这个 ID 是自动生成的，从 1 开始，通过 getId 方法获得\n\n\n是否守护线程\ndaemon\n这个标签用来标记线程是否是守护线程，如果是会有标记，如果不是这没有\n\n\n优先级\nprio=10\nJava 线程的优先级，可以通过 setPriority 方法设置\n\n\nOS 线程的优先级\nos_prio\n\n\n\nCPU 时间\ncpu=94.43ms\n线程获得 CPU 的时间\n\n\nelapsed\nelapsed=509136.51s\n线程启动后经过的 wall clock time\n\n\nAddress\ntid\nJava 线程的地址，这个地址表示的是 JNI native Thread Object 的指针地址\n\n\nOS 线程 ID\nnid\nThe unique ID of the OS thread to which the Java Thread is mapped\n\n\n线程状态\nRunning\n线程当前状态，线程状态下面就是线程的堆栈信息\n\n\n线程的运行状态：\n\nNew: 线程对象创建，不可执行。\nRunnable: 调用 thread.start() 进入 runnable，获得 CPU 时间即可执行。\nRunning: 执行状态。\nWaiting: thread.join() 或调用锁对象 wait() 进入该状态，当前线程会保持该状态直到其他线程发送通知到该对象。\nTimed_Waiting：执行 Thread.sleep(long)、thread.join(long) 或 obj.wait(long) 等就会进该状态，与 Waiting 的区别在于 Timed_Waiting 的等待有时间限制；\nBlocked: 等待锁，进入同步方法，同步代码块，如果没有获取到锁会进入该状态。该线程尝试进入一个被其他线程占用的 synchronized 块，当前线程直到锁被释放之前一直都是 blocked 状态。\nDead：执行结束，或者抛出了未捕获的异常之后。\nDeadlock: 死锁。\nWaiting on condition：等待某个资源或条件发生来唤醒自己。\nWaiting on monitor entry：在等待获取锁。\nterminated: 线程已经结束 run() 并且通知其他线程 joining。\n\n此文开头解决的问题，由于是公司项目，不方便贴上定位的过程日志和代码，所以就先记录下定位的思路和基本概念。\n感谢\njava命令–jstack 工具 | milkty每天学习一个命令：jstack 打印 Java 进程堆栈信息 | Ein VerneJava 性能调优学习笔记Using Thread Dumps | Oracle\n\n\n","categories":["Java"],"tags":["Java","JStack","调试工具"]},{"title":"两数之和","url":"/blog/2019/11/06/two-sum/","content":"\n题目描述给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。\n示例:\n\n给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1]\n\n\n\n题解使用哈希表将会使问题特别简单，首先，我们将使用一次遍历将数组中的元素加入到Map中，key是当前元素的值，value是当前元素的索引。接下来，我们进行第二次遍历，第二次遍历我们将查找当前元素的目标元素（target−nums[i]）是否在Map中，如果在，即找到目标值，返回两个元素的索引。注意一点的是，目标元素不能是当前元素！\npublic int[] twoSum(int[] nums, int target) &#123;    if (nums == null || nums.length == 0) &#123;        return new int[0];    &#125;    Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();    for (int i = 0; i &lt; nums.length; i++) &#123;        map.put(nums[i], i);    &#125;    for (int i = 0; i &lt; nums.length; i++) &#123;        int complement = target - nums[i];        if (map.containsKey(complement) &amp;&amp; map.get(complement) != i) &#123;            return new int[]&#123;i, map.get(complement)&#125;;        &#125;    &#125;    return new int[0];&#125;\n\n实际上，我们把上面的两步合成一步，只用一次遍历即可完成，当遍历到第i个值后，我们把此元素的需要的目标值保存到Map中，后续遍历，找到目标的值，即完成遍历。\npublic int[] twoSum(int[] nums, int target) &#123;    HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(nums.length);    for (int i = 0; i &lt; nums.length; i++) &#123;        if (map.containsKey(nums[i])) &#123;            return new int[]&#123;map.get(nums[i]), i&#125;;        &#125;        map.put(target - nums[i], i);    &#125;    return new int[]&#123;-1, -1&#125;;&#125;\n\n来源\n两数之和 | 力扣（LeetCode）两数之和 | 题解（LeetCode）\n\n\n","categories":["LeetCode"],"tags":["Java","LeetCode","学习笔记","数组","哈希表"]},{"title":"罗马数字转整数","url":"/blog/2019/11/07/roman-to-integer/","content":"\n题目描述罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。\n字符          数值I             1V             5X             10L             50C             100D             500M             1000\n例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做  XXVII, 即为 XX + V + II 。通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况：\n\nI 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。\nX 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 \nC 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。\n\n给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。\n示例 1:\n\n输入: “III”输出: 3\n\n示例 2:\n\n输入: “IV”输出: 4\n\n示例 3:\n\n输入: “IX”输出: 9\n\n示例 4:\n\n输入: “LVIII”输出: 58解释: L = 50, V= 5, III = 3.\n\n示例 5:\n\n输入: “MCMXCIV”输出: 1994解释: M = 1000, CM = 900, XC = 90, IV = 4.\n\n\n\n题解针对题目的对应关系我们首先构建一个Map，将罗马数字与整数的对应关系建立起来。根据题意，我们只需要将罗马字符一个一个转换成整数相加就行了。对于特例情况，当小数在大数的左边的时候，原本相加的操作，要变成相减操作。代码实现上，我们在处理当前数的时候，同时获取后面的一位数，如果大于当前数，则当前操作为减去当前的数，否则为加上当前的数。\n\n\npublic int romanToInt(String s) &#123;    HashMap&lt;Character, Integer&gt; kv = new HashMap&lt;&gt;(7);    kv.put(&#x27;I&#x27;, 1);    kv.put(&#x27;V&#x27;, 5);    kv.put(&#x27;X&#x27;, 10);    kv.put(&#x27;L&#x27;, 50);    kv.put(&#x27;C&#x27;, 100);    kv.put(&#x27;D&#x27;, 500);    kv.put(&#x27;M&#x27;, 1000);    char[] roman = s.toCharArray();    int result = 0;    for (int i = 0; i &lt; roman.length; i++) &#123;        if (i + 1 &lt; roman.length &amp;&amp; kv.get(roman[i]) &lt; kv.get(roman[i + 1])) &#123;            result -= kv.get(roman[i]);        &#125; else &#123;            result += kv.get(roman[i]);        &#125;    &#125;    return result;&#125;\n\n来源\n罗马数字转整数 | 力扣（LeetCode）罗马数字转整数 | 题解（LeetCode）\n\n\n","categories":["LeetCode"],"tags":["Java","LeetCode","学习笔记","哈希表","字符串"]},{"title":"两数相加","url":"/blog/2019/11/25/add-two-numbers/","content":"\n题目描述给出两个非空的链表用来表示两个非负的整数。其中，它们各自的位数是按照逆序的方式存储的，并且它们的每个节点只能存储一位数字。如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。您可以假设除了数字 0 之外，这两个数都不会以 0 开头。\n示例：\n\n输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807\n\n\n\n题解由于各自的位数是按照逆序的方式存储的，所以我们只要一位一位进行加法就可以了，同时考虑溢出的情况，使用进位 carry 来表示。\n\n\n对于两个相加的链表，可能出现长度不一样的情况，这个时候，我们只要处理长的链表，单独加此链表的值即可。\npublic ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123;    int carry;    ListNode l3 = new ListNode(0);    ListNode l3_res = l3;    while (l1 != null || l2 != null) &#123;        if (l1 == null) &#123;            l3.val += l2.val;            l2 = l2.next;        &#125; else if (l2 == null) &#123;            l3.val += l1.val;            l1 = l1.next;        &#125; else &#123;            l3.val += (l1.val + l2.val);            l1 = l1.next;            l2 = l2.next;        &#125;        carry = l3.val / 10;        l3.val = l3.val % 10;        if (l1 != null || l2 != null || carry == 1) &#123;            l3.next = new ListNode(carry);            l3 = l3.next;        &#125;    &#125;    return l3_res;&#125;\n\n另外一种处理两个链表长度不一样的方法就是，我们就将短的链表补0，继续与长的链表相加即可。\npublic ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123;    ListNode p = l1;    ListNode q = l2;    int carry = 0;    while (q != null) &#123;        int sum = carry + p.val + q.val;        p.val = sum % 10;        carry = sum / 10;        if (p.next == null &amp;&amp; q.next != null) &#123;            p.next = new ListNode(0);        &#125;        if (p.next != null &amp;&amp; q.next == null) &#123;            q.next = new ListNode(0);        &#125;        if (p.next == null &amp;&amp; q.next == null &amp;&amp; carry != 0) &#123;            p.next = new ListNode(carry);        &#125;        p = p.next;        q = q.next;    &#125;    return l1;&#125;\n\n复杂度分析\n时间复杂度：Ο(max(m,n))，假设 m 和 n 分别表示 l1 和 l2 的长度，上面的算法最多重复 max(m,n) 次。\n空间复杂度：Ο(max(m,n))，新列表的长度最多为 max(m,n) + 1。\n\n来源\n两数相加 | 力扣（LeetCode）两数相加 | 题解（LeetCode）\n\n\n","categories":["LeetCode"],"tags":["Java","LeetCode","学习笔记","链表","单向链表"]},{"title":"无重复字符的最长子串","url":"/blog/2019/11/26/longest-substring-without-repeating-characters/","content":"\n题目描述给定一个字符串，请你找出其中不含有重复字符的最长子串的长度。\n示例 1:\n\n输入: “abcabcbb”输出: 3解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。\n\n示例 2:\n\n输入: “bbbbb”输出: 1解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。\n\n示例 3:\n\n输入: “pwwkew”输出: 3解释: 因为无重复字符的最长子串是 “wke”，所以其长度为 3。 注意，你的答案必须是子串的长度，”pwke” 是一个子序列，不是子串。\n\n\n\n队列实现本题是计算最长的不重复子串，而子串肯定是连续的。我们肯定都能想到，要遍历下输入的字符串，那么遍历的过程中，我们需要做什么呢？既然是计算字串的长度，那么我们遍历的过程中就要将字串保存下来。同时，每次保存新的字符的时候，需要判断原有的子串中是否包含了这个字符，如果包含了，那么我们要从字串的第一个字符开始，一直删除字符，直到不存在即将要加入的字符，然后计算当前子串的长度，与之前计算的长度比较，取较大值。拿 abcdefce 举例，我们遍历到第二个c字符的时候，已有的不含有重复字符的子串是 abcdef ，当要把c加入到已有的子串的时候，需要将前面的  abc 删除，那么新的子串为 defc。由于子串有后进后出的特性，于是我们使用队列来保存子串。\npublic int lengthOfLongestSubstring1(String s) &#123;    int count = 0;    Queue&lt;Character&gt; queue = new LinkedList&lt;&gt;();    int length = s.length();    for (int i = 0; i &lt; length; i++) &#123;        char c = s.charAt(i);        while (queue.contains(c)) &#123;            queue.poll();        &#125;        queue.offer(c);        count = Math.max(queue.size(), count);    &#125;    return count;&#125;\n\n双指针实现双指针实现的思路和队列的实现一致，只不过使用两个指针i和j来指向子串的两端，判断 s.substring(i, j) 中是否包含当前的字符，若包含，则移动左指针i++，否则移动右指针j++。\npublic int lengthOfLongestSubstring(String s) &#123;    if (s.length() &lt;= 1) &#123;        return s.length();    &#125;    int maxLength = 0, i = 0, j = 1;    while (j &lt; s.length()) &#123;        if (!s.substring(i, j).contains(String.valueOf(s.charAt(j)))) &#123;            maxLength = Math.max(maxLength, j - i + 1);            j++;        &#125; else &#123;            if (i &lt; j) &#123;                i++;            &#125; else &#123;                j++;            &#125;        &#125;    &#125;    return maxLength;&#125;\n\n来源\n无重复字符的最长子串 | 力扣（LeetCode）无重复字符的最长子串 | 题解（LeetCode）\n\n\n","categories":["LeetCode"],"tags":["Java","LeetCode","学习笔记","链表","指针","双指针","队列","滑动窗口"]},{"title":"字符串转换整数","url":"/blog/2019/12/21/string-to-integer-atoi/","content":"\n题目描述请你来实现一个 atoi 函数，使其能将字符串转换成整数。首先，该函数会根据需要丢弃无用的开头空格字符，直到寻找到第一个非空格的字符为止。接下来的转化规则如下：\n\n如果第一个非空字符为正或者负号时，则将该符号与之后面尽可能多的连续数字字符组合起来，形成一个有符号整数。\n假如第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成一个整数。\n该字符串在有效的整数部分之后也可能会存在多余的字符，那么这些字符可以被忽略，它们对函数不应该造成影响。\n\n注意： 假如该字符串中的第一个非空格字符不是一个有效整数字符、字符串为空或字符串仅包含空白字符时，则你的函数不需要进行转换，即无法进行有效转换。在任何情况下，若函数不能进行有效的转换时，请返回 0 。\n提示：\n\n本题中的空白字符只包括空格字符 ‘ ‘ 。\n假设我们的环境只能存储 32 位大小的有符号整数，那么其数值范围为 [−2³¹,  2³¹ − 1]。如果数值超过这个范围，请返回  INT_MAX (2³¹ − 1) 或 INT_MIN (−2³¹) 。\n \n\n示例 1:\n\n输入: “42”输出: 42\n\n示例 2:\n\n输入: “   -42”输出: -42解释: 第一个非空白字符为 ‘-‘, 它是一个负号。我们尽可能将负号与后面所有连续出现的数字组合起来，最后得到 -42 。\n\n示例 3:\n\n输入: “4193 with words”输出: 4193解释: 转换截止于数字 ‘3’ ，因为它的下一个字符不为数字。\n\n示例 4:\n\n输入: “words and 987”输出: 0解释: 第一个非空字符是 ‘w’, 但它不是数字或正、负号。因此无法执行有效的转换。\n\n示例 5:\n\n输入: “-91283472332”输出: -2147483648解释: 数字 “-91283472332” 超过 32 位有符号整数范围。因此返回 INT_MIN (−2³¹) 。\n\n\n\n正常遍历正常遍历字符串，首先去掉空格，然后用flag记录正负，接下来遍历字符串中的数字，不断的转换为整数，直到遍历到无用字符为止。考虑到溢出的情况。我们在计算result的时候，先判断计算后的值是否对int行溢出了，使用表达式 (Integer.MAX_VALUE - (c - &#39;0&#39;)) * 1.0 / 10 &gt;= result 判断即可。\npublic int myAtoi(String str) &#123;    str = str.trim();    boolean flag = false;    int result = 0;    if (str.isEmpty()) &#123;        return 0;    &#125; else if (str.charAt(0) == &#x27;-&#x27;) &#123;        flag = true;    &#125; else if (Character.isDigit(str.charAt(0))) &#123;        result += str.charAt(0) - &#x27;0&#x27;;    &#125; else if (str.charAt(0) != &#x27;+&#x27;) &#123;        return 0;    &#125;    for (int i = 1; i &lt; str.length(); i++) &#123;        char c = str.charAt(i);        if (Character.isDigit(c)) &#123;            if ((Integer.MAX_VALUE - (c - &#x27;0&#x27;)) * 1.0 / 10 &gt;= result) &#123;                result = result * 10 + c - &#x27;0&#x27;;            &#125; else &#123;                return flag ? Integer.MIN_VALUE : Integer.MAX_VALUE;            &#125;        &#125; else &#123;            break;        &#125;    &#125;    return flag ? -result : result;&#125;\n\n复杂度分析\n时间复杂度：O(n)，其中 n 为字符串的长度。我们只需要依次处理所有的字符，处理每个字符需要的时间为 O(1)。\n空间复杂度：Ο(1)。\n\n有限状态机针对有限状态机的学习还需要深入，先参考下官方的解答：字符串转换整数 | 题解\n2020-09-04 更新时隔这么久，终于静下心来研究了下有限状态机的解法。有限状态机在遇到类似“判断一个字符串，是否满足某种规则”这种问题的时候，可以非常有条理的去解决。有限状态机的主要思想是，在程序运行的时候有一个状态 state，我们从当前输入中取出一个字符，根据当前字符的类型，转移到下一个状态。我们还需要定义一个初始状态和结束状态，这样我们只要建立一个覆盖所有状态的表格，就可以解决本题的问题。先看下官方题解的状态机：\n\n\n我们建立的表格如下（为了配合下面自己的代码，我把上面的状态做了微小修改）：\n\n\n\n状态\\字符类型\nspace\n+/-\nnumber\nother\n\n\n\nspace\nspace\nsign\nnumber\nend\n\n\nsign\nend\nend\nnumber\nend\n\n\nnumber\nend\nend\nnumber\nend\n\n\nend\nend\nend\nend\nend\n\n\n接下来我们写代码只要构造这个 stateTable ，然后遍历字符串并不断更新状态即可。对于本题，我们要在遇到数字的时候进行计算，遇到符号的时候记录正负。\n// 记录当前状态，初始为空格状态State state = State.SPACE;int sign = 1;long ans = 0;// 构造表格，记录当前状态遇到某个类型字符可以转移到的下一个状态Map&lt;State, Map&lt;CharType, State&gt;&gt; stateTable = new HashMap&lt;&gt;();&#123;    Map&lt;CharType, State&gt; spaceMap = new HashMap&lt;CharType, State&gt;() &#123;&#123;        put(CharType.SPACE, State.SPACE);        put(CharType.SIGN, State.SIGN);        put(CharType.NUMBER, State.NUMBER);        put(CharType.OTHER, State.END);    &#125;&#125;;    Map&lt;CharType, State&gt; signMap = new HashMap&lt;CharType, State&gt;() &#123;&#123;        put(CharType.SPACE, State.END);        put(CharType.SIGN, State.END);        put(CharType.NUMBER, State.NUMBER);        put(CharType.OTHER, State.END);    &#125;&#125;;    Map&lt;CharType, State&gt; numberMap = new HashMap&lt;CharType, State&gt;() &#123;&#123;        put(CharType.SPACE, State.END);        put(CharType.SIGN, State.END);        put(CharType.NUMBER, State.NUMBER);        put(CharType.OTHER, State.END);    &#125;&#125;;    Map&lt;CharType, State&gt; otherMap = new HashMap&lt;CharType, State&gt;() &#123;&#123;        put(CharType.SPACE, State.END);        put(CharType.SIGN, State.END);        put(CharType.NUMBER, State.END);        put(CharType.OTHER, State.END);    &#125;&#125;;    stateTable.put(State.SPACE, spaceMap);    stateTable.put(State.SIGN, signMap);    stateTable.put(State.NUMBER, numberMap);    stateTable.put(State.END, otherMap);&#125;public int myAtoi(String str) &#123;    for (char c : str.toCharArray()) &#123;        changeState(c);    &#125;    return (int)ans * sign;&#125;public void changeState(char c) &#123;    state = stateTable.get(state).get(getCharType(c));    if (state == State.NUMBER) &#123;        ans = ans * 10 + (c - &#x27;0&#x27;);        ans = sign == 1 ? Math.min(ans, Integer.MAX_VALUE) : Math.min(ans, -(long) Integer.MIN_VALUE);    &#125; else if (state == State.SIGN) &#123;        sign = c == &#x27;-&#x27; ? -sign : sign;    &#125;&#125;public CharType getCharType(char c) &#123;    if (c == &#x27; &#x27;) &#123;        return CharType.SPACE;    &#125; else if (c == &#x27;+&#x27; || c == &#x27;-&#x27;) &#123;        return CharType.SIGN;    &#125; else if (Character.isDigit(c)) &#123;        return CharType.NUMBER;    &#125; else &#123;        return CharType.OTHER;    &#125;&#125;enum State &#123;    SPACE,    SIGN,    NUMBER,    END&#125;enum CharType &#123;    SPACE,    SIGN,    NUMBER,    OTHER&#125;\n\n复杂度分析\n时间复杂度：O(n)，其中 n 为字符串的长度。我们只需要依次处理所有的字符，处理每个字符需要的时间为 O(1)。\n空间复杂度：Ο(1)，自动机的状态只需要常数空间存储。\n\n来源\n字符串转换整数 | 力扣（LeetCode）字符串转换整数 | 题解（LeetCode）\n\n\n","categories":["LeetCode"],"tags":["Java","LeetCode","学习笔记","字符串","整数","有限状态机"]},{"title":"Z 字形变换","url":"/blog/2019/12/30/zigzag-conversion/","content":"\n题目描述将一个给定字符串根据给定的行数，以从上往下、从左到右进行 Z 字形排列。比如输入字符串为 “LEETCODEISHIRING” 行数为 3 时，排列如下：\nL   C   I   RE T O E S I I GE   D   H   N\n之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如：”LCIRETOESIIGEDHN”。\n示例 1:\n\n输入: s = “LEETCODEISHIRING”, numRows = 3输出: “LCIRETOESIIGEDHN”\n\n示例 2:\n\n输入: s = “LEETCODEISHIRING”, numRows = 4输出: “LDREOEIIECIHNTSG”\n\n解释:\nL     D     RE   O E   I IE C   I H   NT     S     G\n\n\n\n题解首先我们可以知道numRows为行数，输出的时候我们只要把每行的字符按顺序输出即可，其实上面的输出，为了美观，使用了空格，当我们把空格拿掉，就转换成了下面的输出。\nL C I RE T O E S I I GE D H N\n那么我们只要知道第i个字符，要放到哪一行即可。\npublic String convert(String s, int numRows) &#123;    if (numRows &lt;= 1) &#123;        return s;    &#125;    List&lt;List&lt;Character&gt;&gt; zList = new ArrayList&lt;&gt;(numRows);    for (int i = 0; i &lt; numRows; i++) &#123;        zList.add(new ArrayList&lt;&gt;());    &#125;    int j; // 判断字符放到哪一行    for (int i = 0; i &lt; s.length(); i++) &#123;        char c = s.charAt(i);        // 多少字母为一个循环        int cycle = numRows + numRows - 2;        j = i % cycle;        j = Math.min(cycle - j, j);        zList.get(j).add(c);    &#125;    StringBuilder sBuilder = new StringBuilder();    for (int i = 0; i &lt; numRows; i++) &#123;        zList.get(i).forEach(sBuilder::append);    &#125;    return sBuilder.toString();&#125;\n\n官方解法和我的思路差不多，只不过他细节上处理的比我好，行数是 numRows 和 len(s) 的较小值，其每行数据没有使用List&lt;Character&gt;，而是使用StringBuilder，另外使用了方向变量goingDown来判断此时在哪一行。以下是官方解法：\n我们可以使用 min(numRows, len(s)) 个列表来表示 Z 字形图案中的非空行。从左到右迭代 s，将每个字符添加到合适的行。可以使用当前行和当前方向这两个变量对合适的行进行跟踪。只有当我们向上移动到最上面的行或向下移动到最下面的行时，当前方向才会发生改变。\npublic String convert(String s, int numRows) &#123;    if (numRows == 1)        return s;    List&lt;StringBuilder&gt; rows = new ArrayList&lt;&gt;();    for (int i = 0; i &lt; Math.min(numRows, s.length()); i++)        rows.add(new StringBuilder());    int curRow = 0;    boolean goingDown = false;    for (char c : s.toCharArray()) &#123;        rows.get(curRow).append(c);        if (curRow == 0 || curRow == numRows - 1)            goingDown = !goingDown;        curRow += goingDown ? 1 : -1;    &#125;    StringBuilder ret = new StringBuilder();    for (StringBuilder row : rows)        ret.append(row);    return ret.toString();&#125;\n\n来源\nZ 字形变换 | 力扣（LeetCode）Z 字形变换 | 题解（LeetCode）\n\n\n","categories":["LeetCode"],"tags":["Java","LeetCode","学习笔记","字符串","指针"]},{"title":"整数反转","url":"/blog/2020/01/04/reverse-integer/","content":"\n题目描述给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。\n示例 1:\n\n输入: 123输出: 321\n\n示例 2:\n\n输入: -123输出: -321\n\n示例 3:\n\n输入: 120输出: 21\n\n注意:假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−2³¹,  2³¹ − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。\n\n\n题解根据题意，我们定义返回值为res，初始为0，我们对入参不断的进行 x % 10 操作，这样就会倒序取得每一位数，同时做 x /= 10 操作更新x的值，针对res，我们每次需要做 res * 10 + x % 10 操作，这样就对x进行了反转。考虑到溢出的情况，我们这边投机取巧，将res定义为long类型，这样int类型的整数就不会溢出。最后判断反转的值是否对int型数溢出即可。\npublic int reverse(int x) &#123;    long res = 0;    while (x != 0) &#123;        res = res * 10 + x % 10;        x /= 10;    &#125;    if (res &gt; Integer.MAX_VALUE || res &lt; Integer.MIN_VALUE) &#123;        return 0;    &#125;    return (int) res;&#125;\n\n如果res使用int型，那么我们需要在处理 res = res * 10 + x % 10;之前判断整数是否溢出。通过判断 (Integer.MAX_VALUE - x % 10) * 1.0 / 10 &gt;= res即可，针对负数同理。\n复杂度分析\n时间复杂度：O(logn)，对于每次迭代，我们会将输入除以 10，因此时间复杂度为 O(logn)，也可以理解为输入的整数的位数。\n空间复杂度：Ο(1)。\n\n来源\n整数反转 | 力扣（LeetCode）整数反转 | 题解（LeetCode）\n\n\n","categories":["LeetCode"],"tags":["Java","LeetCode","学习笔记","整数"]},{"title":"回文数","url":"/blog/2020/01/10/palindrome-number/","content":"\n题目描述判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。\n示例 1:\n\n输入: 121输出: true\n\n示例 2:\n\n输入: -121输出: false解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。\n\n示例 3:\n\n输入: 10输出: false解释: 从右向左读, 为 01 。因此它不是一个回文数。\n\n\n\n针对输入是负数的情况下，一定不是回文数，因为没有整数是以负号结尾的。接下来考虑，既然回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。那么我们将整数反转，判断反转后的数和原来的数是否相等，就可以判断此整数是否是回文数。关于整数反转的操作，可以参考另外一道Leetcode题目：整数反转\npublic boolean isPalindrome(int x) &#123;    if (x &lt; 0) &#123;        return false;    &#125;    int origin = x;    // 使用long防止整数反转溢出    long result = 0;    while (x != 0) &#123;        result = result * 10 + x % 10;        x = x / 10;    &#125;    // 若反转后的值溢出，则一定不是回文数    if (result &gt; Integer.MAX_VALUE || result &lt; Integer.MIN_VALUE) &#123;        return false;    &#125;    return (int) result == origin;&#125;\n\n考虑到反转溢出的情况，若整数反转后溢出，那么肯定原来的值和反转后的值不相等，也就是说其实我们上面并不需要特意的去判断反转后的整数是否溢出，于是代码优化如下：\npublic boolean isPalindrome(int x) &#123;    if (x &lt; 0) &#123;        return false;    &#125;    int origin = x;    int result = 0;    while (x != 0) &#123;        result = result * 10 + x % 10;        x = x / 10;    &#125;    return result == origin;&#125;\n\n复杂度分析\n时间复杂度：O(logn)，对于每次迭代，我们会将输入除以 10，因此时间复杂度为 O(logn)，也可以理解为输入的整数的位数。\n空间复杂度：Ο(1)。\n\n来源\n回文数 | 力扣（LeetCode）回文数 | 题解（LeetCode）\n\n\n","categories":["LeetCode"],"tags":["Java","LeetCode","学习笔记","整数"]},{"title":"盛最多水的容器","url":"/blog/2020/01/16/container-with-most-water/","content":"\n题目描述给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。\n说明： 你不能倾斜容器，且 n 的值至少为 2。\n\n\n图中垂直线代表输入数组 [1, 8, 6, 2, 5, 4, 8, 3, 7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。\n示例：\n\n输入：[1, 8, 6, 2, 5, 4, 8, 3, 7]输出：49\n\n\n\n题解通过题目描述的图中可以容易看出来，我们既然想盛更多的水，那么我们需要让垂直x轴的两条线尽量的高，也让这两条线距离尽量的远。两条线最大的距离就是数组的长度，于是我们使用双指针 i，j 且 i &lt; j 分别指向数组的两端，作为初始的容器大小 Math.min(height[i], height[j]) * (j - i)。接下来，我们就要移动左右指针，移动哪个呢？我们直觉上，要移动指针指的值较小的一个。因为我们既然移动了指针，那么肯定会让 j - i 变小，那么如果我们想要让容器盛水更多，那么肯定要让 Math.min(height[i], height[j]) 更大才行。否则如果我们移动指针指的值较大的一个，那么最后计算出来的 Math.min(height[i], height[j]) 肯定小于等于原有的值，那么盛水也将小于等于原有的值。我们不需要这样的结果。最后，我们只要取每次指针移动后，计算值中最大的值，即为盛水的最大值。更详细的介绍可以参考Leetcode官方题解。\npublic int maxArea(int[] height) &#123;    if (height == null || height.length &lt; 2) &#123;        return 0;    &#125;    int result = 0;    int i = 0;    int j = height.length - 1;    while (i &lt; j) &#123;        result = Math.max(Math.min(height[i], height[j]) * (j - i), result);        if (height[i] &lt; height[j]) &#123;            i++;        &#125; else &#123;            j--;        &#125;    &#125;    return result;&#125;\n\n以下只是看到了有大佬写的更简单的代码，拿来学习下。\npublic int maxArea(int[] height) &#123;    if (height == null || height.length &lt; 2) &#123;        return 0;    &#125;    int result = 0;    int i = 0;    int j = height.length - 1;    while (i &lt; j) &#123;        int minH = height[i] &lt; height[j] ? height[i++] : height[j--];        result = Math.max(minH * (j - i + 1), result);    &#125;    return result;&#125;\n\n复杂度分析\n时间复杂度：O(N)，双指针总计最多遍历整个数组一次。\n空间复杂度：O(1)，只需要额外的常数级别的空间。\n\n来源\n盛最多水的容器 | 力扣（LeetCode）盛最多水的容器 | 题解（LeetCode）\n\n\n","categories":["LeetCode"],"tags":["Java","LeetCode","学习笔记","数组","指针","双指针","几何"]},{"title":"拼写单词","url":"/blog/2020/03/17/find-words-that-can-be-formed-by-characters/","content":"\n题目描述给你一份『词汇表』（字符串数组） words 和一张『字母表』（字符串） chars。假如你可以用 chars 中的『字母』（字符）拼写出 words 中的某个『单词』（字符串），那么我们就认为你掌握了这个单词。返回词汇表 words 中你掌握的所有单词的长度之和。\n注意：每次拼写（指拼写词汇表中的一个单词）时，chars 中的每个字母都只能用一次。\n示例 1：\n\n输入：words = [“cat”, “bt”, “hat”, “tree”], chars = “atach”输出：6解释：可以形成字符串 “cat” 和 “hat”，所以答案是 3 + 3 = 6。\n\n示例 2：\n\n输入：words = [“hello”, “world”, “leetcode”], chars = “welldonehoneyr”输出：10解释：可以形成字符串 “hello” 和 “world”，所以答案是 5 + 5 = 10。\n\n提示：\n\n1 &lt;= words.length &lt;= 1000\n1 &lt;= words[i].length, chars.length &lt;= 100\n所有字符串中都仅包含小写英文字母\n\n\n\n题解最简单的方法，暴力方法，我们遍历全部的word，判断word的中的所有字符是否都在chars中存在，同时我们标记下已经被记录的字符，防止重复使用。\npublic int countCharacters(String[] words, String chars) &#123;    int length = 0;    char[] charArr = chars.toCharArray();    for (String word : words) &#123;        // 判断chars中是否包含word        if (findWord(word, charArr)) &#123;            length += word.length();        &#125;    &#125;    return length;&#125;public boolean findWord(String word, char[] charArr) &#123;    boolean[] flag = new boolean[charArr.length];    char[] wordArr = word.toCharArray();    for (int i = 0; i &lt; wordArr.length; i++) &#123;        // 从chars中找到word中的字符        if (!findChar(wordArr[i], charArr, flag)) &#123;            return false;        &#125;    &#125;    return true;&#125;public boolean findChar(char c, char[] charArr, boolean[] flag) &#123;    for (int i = 0; i &lt; charArr.length; i++) &#123;        if (charArr[i] == c &amp;&amp; !flag[i]) &#123;            // 保证每个字符只用到一次            flag[i] = true;            return true;        &#125;    &#125;    return false;&#125;\n\n复杂度分析\n时间复杂度：Ο(M x N)，M为words中所有字符数，N为chars字符数。\n\n进阶显然，对于一个单词 word，只要其中的每个字母的数量都不大于 chars 中对应的字母的数量，那么就可以用 chars 中的字母拼写出 word。由于题目中的限制条件是小写英文字母，所以我们只要使用int[26]数组，分别保存字母表中的字母出现次数和word中字母出现的次数即可。\n\n\npublic int countCharacters(String[] words, String chars) &#123;    int len = 0;    // 统计字母表中字符出现的次数    int[] charNum = getCharNum(chars);    for (String word : words) &#123;        // 统计word中字符出现的次数        int[] wordNum = getCharNum(word);        if (isContain(charNum, wordNum)) &#123;            len += word.length();        &#125;    &#125;    return len;&#125;private boolean isContain(int[] charNum, int[] wordNum) &#123;    for (int i = 0; i &lt; wordNum.length; i++) &#123;        // 判断如果word中的字符数大于chars中的字符数，则无法拼写单词        if (charNum[i] &lt; wordNum[i]) &#123;            return false;        &#125;    &#125;    return true;&#125;private int[] getCharNum(String word) &#123;    int[] charNum = new int[26];    for (char c : word.toCharArray()) &#123;        charNum[c - &#x27;a&#x27;]++;    &#125;    return charNum;&#125;\n\n复杂度分析\n时间复杂度：Ο(n)，其中 n 为所有字符串的长度和。我们需要遍历每个字符串，包括 chars 以及数组 words 中的每个单词。\n空间复杂度：Ο(S)，其中 S 为字符集大小，在本题中 S 的值为 26（所有字符串仅包含小写字母）。程序运行过程中，最多同时存在两个统计字符数的数组，使用的空间均不超过字符集大小 S，因此空间复杂度为 O(S)。\n\n来源\n拼写单词 | 力扣（LeetCode）拼写单词 | 题解（LeetCode）\n\n\n","categories":["LeetCode"],"tags":["Java","LeetCode","学习笔记","数组","字符串"]},{"title":"打家劫舍","url":"/blog/2020/05/29/house-robber/","content":"\n题目描述你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。给定一个代表每个房屋存放金额的非负整数数组，计算你不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。\n示例 1：\n\n输入：[1,2,3,1]输出：4解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。偷窃到的最高金额 = 1 + 3 = 4 。\n\n示例 2：\n\n输入：[2,7,9,3,1]输出：12解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。偷窃到的最高金额 = 2 + 9 + 1 = 12 。\n\n提示：\n\n0 &lt;= nums.length &lt;= 100\n0 &lt;= nums[i] &lt;= 400\n\n\n\n递归对于此题，我们从起始位置，第一家开始出发，有两种情况，偷第一家，跳过第二家，然后从第三家开始继续选择（偷第三家或者第四家）；或者偷第二家，然后从第四家开始选择（偷第四家或者第五家）。选择两种情况的最大值。之后递归处理。\npublic int rob(int[] nums) &#123;    if (nums == null || nums.length == 0) &#123;        return 0;    &#125; else if (nums.length == 1) &#123;        return nums[0];    &#125;    return Math.max(nums[0] + rob(nums, 2), nums[1] + rob(nums, 3));&#125;public int rob(int[] nums, int index) &#123;    if (index == nums.length - 1) &#123;        return nums[index];    &#125; else if (index &gt; nums.length - 1) &#123;        return 0;    &#125; else &#123;        return Math.max(nums[index] + rob(nums, index + 2), nums[index + 1] + rob(nums, index + 3));    &#125;&#125;\n\n上面是一个最容易理解的解法，但是会超时，原因是，描述中我们可以发现，两种情况都会计算从第四家开始偷的情况。后面递归也是一样的，导致了大量的重复计算。于是我们进行优化，使用 int[] money 数组表示从第i家计算能偷的最大值，递归的时候，同时记录递归中间值，这样我们当有重复计算的时候，比如上面所说的第二种情况偷第四家的时候，可以使用第一种情况计算好的从第四家开始偷的最大值。避免了重复递归计算。\nint[] money = null;public int rob(int[] nums) &#123;    if (nums == null || nums.length == 0) &#123;        return 0;    &#125; else if (nums.length == 1) &#123;        return nums[0];    &#125;    money = new int[nums.length];    Arrays.fill(money, -1);    return Math.max(nums[0] + rob(nums, 2), nums[1] + rob(nums, 3));&#125;public int rob(int[] nums, int index) &#123;    if (index == nums.length - 1) &#123;        return nums[index];    &#125; else if (index &gt; nums.length - 1) &#123;        return 0;    &#125; else &#123;        money[index] = money[index] == -1 ? nums[index] + rob(nums, index + 2) : money[index];        money[index + 1] = money[index + 1] == -1 ? nums[index + 1] + rob(nums, index + 3) : money[index + 1];        return Math.max(money[index], money[index + 1]);    &#125;&#125;\n\n动态规划首先考虑最简单的情况。如果只有一间房屋，则偷窃该房屋，可以偷窃到最高总金额。如果只有两间房屋，则由于两间房屋相邻，不能同时偷窃，只能偷窃其中的一间房屋，因此选择其中金额较高的房屋进行偷窃，可以偷窃到最高总金额。如果房屋数量大于两间，应该如何计算能够偷窃到的最高总金额呢？对于第 k (k &gt; 2) 间房屋，有两个选项：\n\n偷窃第 k 间房屋，那么就不能偷窃第 k−1 间房屋，偷窃总金额为前 k−2 间房屋的最高总金额与第 k 间房屋的金额之和。\n不偷窃第 k 间房屋，偷窃总金额为前 k−1 间房屋的最高总金额。\n\n在两个选项中选择偷窃总金额较大的选项，该选项对应的偷窃总金额即为前 k 间房屋能偷窃到的最高总金额。用 dp[i] 表示前 i 间房屋能偷窃到的最高总金额，那么就有如下的状态转移方程：\n\ndp[i] = max(dp[i − 2] + nums[i], dp[i − 1])\n\n边界条件为：\n\ndp[0]=nums[0] 只有一间房屋，则偷窃该房屋dp[1]=max(nums[0], nums[1]) 只有两间房屋，选择其中金额较高的房屋进行偷窃\n\n最终的答案即为 dp[n − 1]，其中 n 是数组的长度。\npublic int rob(int[] nums) &#123;    if (nums == null || nums.length == 0) &#123;        return 0;    &#125;    int length = nums.length;    if (length == 1) &#123;        return nums[0];    &#125;    int[] dp = new int[length];    dp[0] = nums[0];    dp[1] = Math.max(nums[0], nums[1]);    for (int i = 2; i &lt; length; i++) &#123;        dp[i] = Math.max(dp[i - 2] + nums[i], dp[i - 1]);    &#125;    return dp[length - 1];&#125;\n\n上述方法使用了数组存储结果。考虑到每间房屋的最高总金额只和该房屋的前两间房屋的最高总金额相关，因此可以使用滚动数组，在每个时刻只需要存储前两间房屋的最高总金额。\npublic int rob(int[] nums) &#123;    if (nums == null || nums.length == 0) &#123;        return 0;    &#125;    int length = nums.length;    if (length == 1) &#123;        return nums[0];    &#125;    int first = nums[0], second = Math.max(nums[0], nums[1]);    for (int i = 2; i &lt; length; i++) &#123;        int temp = second;        second = Math.max(first + nums[i], second);        first = temp;    &#125;    return second;&#125;\n\n来源\n打家劫舍 | 力扣（LeetCode）打家劫舍 | 题解（LeetCode）\n\n\n","categories":["LeetCode"],"tags":["Java","LeetCode","学习笔记","递归","记忆化","动态规划","滚动数组"]},{"title":"根据身高重建队列","url":"/blog/2020/04/09/queue-reconstruction-by-height/","content":"\n题目描述假设有打乱顺序的一群人站成一个队列。 每个人由一个整数对(h, k)表示，其中h是这个人的身高，k是排在这个人前面且身高大于或等于h的人数。 编写一个算法来重建这个队列。\n注意： 总人数少于1100人。\n示例\n\n输入: [[7, 0], [4, 4], [7, 1], [5, 0], [6, 1], [5, 2]]输出: [[5, 0], [7, 0], [5, 2], [6, 1], [4, 4], [7, 1]]\n\n\n\n题解让我们从最简单的情况下思考，当队列中所有人的 (h, k) 都是相同的高度 h，只有 k 不同时，解决方案很简单：每个人在队列的索引 index = k。\n\n\n即使不是所有人都是同一高度，这个策略也是可行的。因为个子矮的人相对于个子高的人是 “看不见” 的，所以可以先安排个子高的人。下图中我们先安排身高为 7 的人，将它放置在与 k 值相等的索引上；再安排身高为 6 的人，同样的将它放置在与 k 值相等的索引上。\n\n\n该策略可以递归进行：\n\n将最高的人按照 k 值升序排序，然后将它们放置到输出队列中与 k 值相等的索引位置上。\n按降序取下一个高度，同样按 k 值对该身高的人升序排序，然后逐个插入到输出队列中与 k 值相等的索引位置上。\n直到完成为止。\n\npublic int[][] reconstructQueue(int[][] people) &#123;    // 按照高度降序排列，同高度的人，按照k值升序排列。    Arrays.sort(people, (o1, o2) -&gt; o1[0] == o2[0] ? o1[1] - o2[1] : o2[0] - o1[0]);    LinkedList&lt;int[]&gt; list = new LinkedList&lt;&gt;();    // 逐个地把它们放在输出队列中，索引等于它们的 k 值。    for (int[] person : people) &#123;        list.add(person[1], person);    &#125;    return list.toArray(new int[list.size()][]);&#125;\n\n复杂度分析\n时间复杂度：O(N²)，排序使用了 O(NlogN) 的时间，每个人插入到输出队列中需要 O(k) 的时间，其中 k 是当前输出队列的元素个数。总共的时间复杂度为O(N²)。\n空间复杂度：O(N)，输出队列使用的空间。\n\n来源\n根据身高重建队列 | 力扣（LeetCode）根据身高重建队列 | 题解（LeetCode）\n\n\n","categories":["LeetCode"],"tags":["Java","LeetCode","学习笔记","数组","链表","贪心算法","排序"]},{"title":"三数之和","url":"/blog/2020/05/30/three-sum/","content":"\n题目描述给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c，使得 a + b + c = 0？请你找出所有满足条件且不重复的三元组。\n注意：答案中不可以包含重复的三元组。\n示例:\n\n给定数组 nums = [-1, 0, 1, 2, -1, -4]，满足要求的三元组集合为：[[-1, 0, 1], [-1, -1, 2]]\n\n\n\n题解 之前做过两数之和这道题，所以第一想法就是转化成两次两数之和解决，思路就是先求 b + c 两数之和 z，再求 a + z 两数之和等于0，也就是相反数。\n  public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123;    List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();    for (int i = 0; i &lt; nums.length; i++) &#123;        // 求出两数之和的组合，和为-nums[i]        List&lt;List&lt;Integer&gt;&gt; twoSumList = twoSum(nums, i + 1, -nums[i]);        for (List&lt;Integer&gt; list : twoSumList) &#123;            list.add(nums[i]);            Collections.sort(list);            result.add(list);        &#125;    &#125;    return result.stream().distinct().collect(Collectors.toList());&#125;public List&lt;List&lt;Integer&gt;&gt; twoSum(int[] nums, int index, int target) &#123;    Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();    List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();    for (int i = index; i &lt; nums.length; i++) &#123;        map.put(nums[i], i);    &#125;    for (int i = index; i &lt; nums.length; i++) &#123;        int complement = target - nums[i];        if (map.containsKey(complement) &amp;&amp; map.get(complement) != i) &#123;            List&lt;Integer&gt; list = new ArrayList&lt;&gt;();            list.add(nums[i]);            list.add(nums[map.get(complement)]);            result.add(list);            // 去重，防止重复执行超时            map.remove(nums[i]);            map.remove(complement);        &#125;    &#125;    return result;&#125;\n\n 其实这道题有更好的解法，受之前两数之和的影响，两数之和的那道题，是没法给数组排序的，因为输出是数组下标，而这道题，输出是三元组，可以进行数组排序的，以下是来自LeetCode的题解：\n\n首先对数组进行排序，排序后固定一个数 nums[i]，再使用左右指针指向 nums[i] 后面的两端，数字分别为 nums[L] 和 nums[R]，计算三个数的和 sum 判断是否满足为 0，满足则添加进结果集。\n\n如果 nums[i]大于 0，则三数之和必然无法等于 0，结束循环。\n\n如果 nums[i] == nums[i−1]，则说明该数字重复，会导致结果重复，所以应该跳过。\n\n当 sum == 0 时，nums[L] == nums[L+1] 则会导致结果重复，应该跳过，L++。\n\n当 sum == 0 时，nums[R] == nums[R−1] 则会导致结果重复，应该跳过，R−−。\npublic List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123;   List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();   int len = nums.length;   if (nums == null || len &lt; 3)       return res;   Arrays.sort(nums);   for (int i = 0; i &lt; len; i++) &#123;       if (nums[i] &gt; 0)           break; // 如果当前数字大于0，则三数之和一定大于0，所以结束循环       if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1])           continue; // 去重       int L = i + 1;       int R = len - 1;       while (L &lt; R) &#123;           int sum = nums[i] + nums[L] + nums[R];           if (sum == 0) &#123;               res.add(Arrays.asList(nums[i], nums[L], nums[R]));               while (L &lt; R &amp;&amp; nums[L] == nums[L + 1])                   L++; // 去重               while (L &lt; R &amp;&amp; nums[R] == nums[R - 1])                   R--; // 去重               L++;               R--;           &#125; else if (sum &lt; 0)               L++;           else if (sum &gt; 0)               R--;       &#125;   &#125;   return res;&#125;\n\n\n\n来源\n三数之和 | 力扣（LeetCode）三数之和 | 题解（LeetCode）\n\n\n","categories":["LeetCode"],"tags":["Java","LeetCode","学习笔记","数组","双指针","排序"]},{"title":"拥有最多糖果的孩子","url":"/blog/2020/06/01/kids-with-the-greatest-number-of-candies/","content":"\n题目描述给你一个数组 candies 和一个整数 extraCandies ，其中 candies[i] 代表第 i 个孩子拥有的糖果数目。对每一个孩子，检查是否存在一种方案，将额外的 extraCandies 个糖果分配给孩子们之后，此孩子有最 的糖果。注意： 允许有多个孩子同时拥有最多的糖果数目。\n示例 1：\n\n输入：candies = [2, 3, 5, 1, 3], extraCandies = 3输出：[true, true, true, false, true]解释：孩子 1 有 2 个糖果，如果他得到所有额外的糖果（3个），那么他总共有 5 个糖果，他将成为拥有最多糖果的孩子。孩子 2 有 3 个糖果，如果他得到至少 2 个额外糖果，那么他将成为拥有最多糖果的孩子。孩子 3 有 5 个糖果，他已经是拥有最多糖果的孩子。孩子 4 有 1 个糖果，即使他得到所有额外的糖果，他也只有 4 个糖果，无法成为拥有糖果最多的孩子。孩子 5 有 3 个糖果，如果他得到至少 2 个额外糖果，那么他将成为拥有最多糖果的孩子。\n\n示例 2：\n\n输入：candies = [4, 2, 1, 1, 2], extraCandies = 1输出：[true, false, false, false, false]解释：只有 1 个额外糖果，所以不管额外糖果给谁，只有孩子 1 可以成为拥有糖果最多的孩子。\n\n示例 3：\n\n输入：candies = [12, 1, 12], extraCandies = 10输出：[true, false, true]\n\n提示：\n\n2 &lt;= candies.length &lt;= 100\n1 &lt;= candies[i] &lt;= 100\n1 &lt;= extraCandies &lt;= 50\n\n\n\n题解我们只要先遍历一遍小朋友拥有的糖果数，找出最大值，然后再遍历一次小朋友的糖果数，加上额外的糖果，是否大于等于之前求出的最大值即可。\npublic List&lt;Boolean&gt; kidsWithCandies(int[] candies, int extraCandies) &#123;    OptionalInt max = Arrays.stream(candies).max();    List&lt;Boolean&gt; result = new LinkedList&lt;&gt;();    for (int num : candies) &#123;        result.add(num + extraCandies &gt;= max.getAsInt());    &#125;    return result;&#125;\n\n此题使用了Java流API Arrays.stream(candies).max()，可以很方便的处理集合或者数组相关的问题，比如数组求和，求最大值等等。关于流API的介绍可以参考：\n\nJava 8 的 Lambda 表达式和 Stream API\n\n另外此题是六一儿童节LeetCode的每日一题，官方是想让我们过一个快乐的六一啊，在这里也祝各位大孩子们六一儿童节快乐^o^/\n复杂度分析\n时间复杂度：O(n)，我们首先使用 O(n) 的时间预处理出所有小朋友拥有的糖果数目最大值。对于每一个小朋友，我们需要 O(1) 的时间判断这个小朋友是否可以拥有最多的糖果，故渐进时间复杂度为 O(n)。\n空间复杂度：Ο(1)。\n\n来源\n拥有最多糖果的孩子 | 力扣（LeetCode）拥有最多糖果的孩子 | 题解（LeetCode）\n\n\n","categories":["LeetCode"],"tags":["Java","LeetCode","学习笔记","流API","数组","链表"]},{"title":"求1-n的和","url":"/blog/2020/06/03/qiu-12n-lcof/","content":"\n题目描述求 1+2+…+n ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。\n示例 1：\n\n输入: n = 3输出: 6\n\n示例 2：\n\n输入: n = 9输出: 45\n\n限制：\n\n1 &lt;= n &lt;= 10000\n\n\n\n递归由于题目限制了很多，其中比较常用的for循环方法也被禁用，那么不用for循环，最容易想到的就是递归，于是我们很容易就能写出递归的版本\npublic int sumNums(int n) &#123;    return n == 0 ? 0 : n + sumNums(n - 1);&#125;\n\n但是题目要求不允许使用条件判断语句，那么我们是否能使用别的办法来确定递归出口呢？答案就是逻辑运算符的短路性质。以逻辑运算符 &amp;&amp; 为例，对于 A &amp;&amp; B 这个表达式，如果 A 表达式返回 false ，那么 A &amp;&amp; B 已经确定为 false ，此时不会去执行表达式 B。同理，对于逻辑运算符 ||， 对于 A || B 这个表达式，如果 A 表达式返回 true ，那么 A || B 已经确定为 true ，此时不会去执行表达式 B。\n利用这一特性，我们可以将判断是否为递归的出口看作 A &amp;&amp; B 表达式中的 A 部分，递归的主体函数看作 B 部分。如果不是递归出口，则返回 true，并继续执行表达式 B 的部分，否则递归结束。当然，你也可以用逻辑运算符 || 给出类似的实现，这里我们只提供结合逻辑运算符 &amp;&amp; 的递归实现。\npublic int sumNums(int n) &#123;    boolean flag = n &gt; 0 &amp;&amp; (n += sumNums(n - 1)) &gt; 0;    return n;&#125;\n\n复杂度分析\n时间复杂度：O(n)，递归函数递归 n 次，每次递归中计算时间复杂度为 O(1)，因此总时间复杂度为 O(n)。\n空间复杂度：Ο(n)，递归函数的空间复杂度取决于递归调用栈的深度，这里递归函数调用栈深度为 O(n)，因此空间复杂度为 O(n)。\n\nJava流API其实这种数学计算，包含求和，求大小等等操作，Java引入很多方便的方法，此题使用了Java流API IntStream.range(1, n + 1).sum()，求指定范围的整数和。关于流API的介绍可以参考：\n\nJava 8 的 Lambda 表达式和 Stream API\n\npublic int sumNums2(int n) &#123;    return IntStream.range(1, n + 1).sum();&#125;\n\n来源\n求1-n的和 | 力扣（LeetCode）求1-n的和 | 题解（LeetCode）\n\n\n","categories":["LeetCode"],"tags":["Java","LeetCode","学习笔记","流API","递归","剑指Offer"]},{"title":"顺时针打印矩阵","url":"/blog/2020/06/05/shun-shi-zhen-da-yin-ju-zhen-lcof/","content":"\n题目描述输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。\n示例 1：\n\n输入：matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]输出：[1, 2, 3, 6, 9, 8, 7, 4, 5]\n\n示例 2：\n\n输入：matrix = [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]输出：[1, 2, 3, 4, 8, 12, 11, 10, 9, 5, 6, 7]\n\n限制：\n\n0 &lt;= matrix.length &lt;= 1000 &lt;= matrix[i].length &lt;= 100\n\n\n\n题解可以模拟打印矩阵的路径。初始位置是矩阵的左上角，初始方向是向右，当路径超出界限或者进入之前访问过的位置时，则顺时针旋转，进入下一个方向。判断路径是否进入之前访问过的位置需要使用一个与输入矩阵大小相同的辅助矩阵 visited，其中的每个元素表示该位置是否被访问过。当一个元素被访问时，将 visited 中的对应位置的元素设为已访问。\n如何判断路径是否结束？由于矩阵中的每个元素都被访问一次，因此路径的长度即为矩阵中的元素数量，当路径的长度达到矩阵中的元素数量时即为完整路径，将该路径返回。\npublic int[] spiralOrder(int[][] matrix) &#123;    if (matrix == null || matrix.length == 0 || matrix[0].length == 0) &#123;        return new int[0];    &#125;    int rows = matrix.length;    int columns = matrix[0].length;    // 判断路径是否被访问过    boolean[][] visited = new boolean[rows][columns];    int total = rows * columns;    // 总路径长度为矩阵的元素数量    int[] order = new int[total];    int row = 0;    int column = 0;    // 移动的方向    int[][] directions = &#123;&#123;0, 1&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;-1, 0&#125;&#125;;    int directionIndex = 0;    for (int i = 0; i &lt; total; i++) &#123;        order[i] = matrix[row][column];        visited[row][column] = true;        int nextRow = row + directions[directionIndex][0];        int nextColumn = column + directions[directionIndex][1];        if (nextRow &lt; 0 || nextRow &gt;= rows || nextColumn &lt; 0 || nextColumn &gt;= columns                || visited[nextRow][nextColumn]) &#123;            directionIndex = (directionIndex + 1) % 4;        &#125;        row += directions[directionIndex][0];        column += directions[directionIndex][1];    &#125;    return order;&#125;\n\n复杂度分析\n时间复杂度：O(mn)，其中 m 和 n 分别是输入矩阵的行数和列数。矩阵中的每个元素都要被访问一次。\n空间复杂度：O(mn)。需要创建一个大小为 m × n 的矩阵 visited 记录每个位置是否被访问过。\n\n来源\n顺时针打印矩阵 | 力扣（LeetCode）顺时针打印矩阵 | 题解（LeetCode）\n\n\n","categories":["LeetCode"],"tags":["Java","LeetCode","学习笔记","数组","指针","记忆化","剑指Offer","回溯算法","矩阵"]},{"title":"最长公共前缀","url":"/blog/2020/06/15/longest-common-prefix/","content":"\n题目描述编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 “”。\n示例 1:\n\n输入: [“flower”, “flow”, “flight”]输出: “fl”\n\n示例 2:\n\n输入: [“dog”, “racecar”, “car”]输出: “”解释: 输入不存在公共前缀。\n\n说明:\n\n所有输入只包含小写字母 a-z 。\n\n\n\n横向扫描我们求所有字符串的最长公共前缀，可以发现，对于字符串S₁……Sn，我们只要依次遍历每个字符串，对于每个遍历到的字符串，更新当前的最长公共前缀，遍历所有的字符串以后，即可得到字符串数组中的最长公共前缀。下面是给了递归和遍历两种方式代码。如果在尚未遍历完所有的字符串时，最长公共前缀已经是空串，则最长公共前缀一定是空串，因此不需要继续遍历剩下的字符串，直接返回空串即可。\npublic String longestCommonPrefix(String[] strs) &#123;    if (strs == null || strs.length == 0) &#123;        return &quot;&quot;;    &#125; else if (strs.length == 1) &#123;        return strs[0];    &#125; else &#123;        return longestCommonPrefixTwoStr(strs[0], longestCommonPrefix(strs, 1));    &#125;&#125;public String longestCommonPrefix(String[] strs, int index) &#123;    if (index == strs.length - 1) &#123;        return strs[index];    &#125;    // 递归处理当前字符串和(后续所有字符传最长公共前缀)的最长公共前缀。    return longestCommonPrefixTwoStr(strs[index], longestCommonPrefix(strs, index + 1));&#125;public String longestCommonPrefixTwoStr(String str1, String str2) &#123;    int len = Math.min(str1.length(), str2.length());    int index = 0;    while (index &lt; len &amp;&amp; str1.charAt(index) == str2.charAt(index)) &#123;        index++;    &#125;    return str1.substring(0, index);&#125;\n\npublic String longestCommonPrefix(String[] strs) &#123;    if (strs == null || strs.length == 0) &#123;        return &quot;&quot;;    &#125;    String prefix = strs[0];    for (int i = 1; i &lt; strs.length; i++) &#123;        prefix = longestCommonPrefixTwoStr(prefix, strs[i]);        if (prefix.length() == 0) &#123;            break;        &#125;    &#125;    return prefix;&#125;public String longestCommonPrefixTwoStr(String str1, String str2) &#123;    int len = Math.min(str1.length(), str2.length());    int index = 0;    while (index &lt; len &amp;&amp; str1.charAt(index) == str2.charAt(index)) &#123;        index++;    &#125;    return str1.substring(0, index);&#125;\n\n复杂度分析\n时间复杂度：O(mn)，其中 m 是字符串数组中的字符串的平均长度，n 是字符串的数量。最坏情况下，字符串数组中的每个字符串的每个字符都会被比较一次。\n空间复杂度：遍历是O(1)，只需要额外的常数级别的空间。递归是O(n)，其中 n 是字符串的数量。\n\n纵向扫描前面的方法是横向扫描，依次遍历每个字符串，更新最长公共前缀。另一种方法是纵向扫描。纵向扫描时，从前往后遍历所有字符串的每一列，比较相同列上的字符是否相同，如果相同则继续对下一列进行比较，如果不相同则当前列不再属于公共前缀，当前列之前的部分为最长公共前缀。\n\n\npublic String longestCommonPrefix(String[] strs) &#123;    if (strs == null || strs.length == 0) &#123;        return &quot;&quot;;    &#125;    int length = strs[0].length();    for (int i = 0; i &lt; length; i++) &#123;        char c = strs[0].charAt(i);        for (int j = 1; j &lt; strs.length; j++) &#123;            if (i == strs[j].length() || strs[j].charAt(i) != c) &#123;                return strs[0].substring(0, i);            &#125;        &#125;    &#125;    return strs[0];&#125;\n\n复杂度分析\n时间复杂度：O(mn)，其中 m 是字符串数组中的字符串的平均长度，n 是字符串的数量。最坏情况下，字符串数组中的每个字符串的每个字符都会被比较一次。\n空间复杂度：O(1)，只需要额外的常数级别的空间。\n\n分治法针对横向扫描的方法，我们可以发现，可以使用分治法得到字符串的最长公共前缀，我们可以将字符串数组一分为二，分别求分开的两个字符串数组的最长公共前缀，并不断递归处理，最后合并求出子问题的最长公共前缀。\n\n\npublic String longestCommonPrefix(String[] strs) &#123;    if (strs == null || strs.length == 0) &#123;        return &quot;&quot;;    &#125; else &#123;        return longestCommonPrefix(strs, 0, strs.length - 1);    &#125;&#125;public String longestCommonPrefix(String[] strs, int start, int end) &#123;    if (start == end) &#123;        return strs[start];    &#125; else &#123;        int mid = (end - start) / 2 + start;        String left = longestCommonPrefix(strs, start, mid);        String right = longestCommonPrefix(strs, mid + 1, end);        return longestCommonPrefixTwoStr(left, right);    &#125;&#125;public String longestCommonPrefixTwoStr(String str1, String str2) &#123;    int len = Math.min(str1.length(), str2.length());    int index = 0;    while (index &lt; len &amp;&amp; str1.charAt(index) == str2.charAt(index)) &#123;        index++;    &#125;    return str1.substring(0, index);&#125;\n\n复杂度分析\n时间复杂度：O(mn)，其中 m 是字符串数组中的字符串的平均长度，n 是字符串的数量。时间复杂度的递推式是 T(n)=2⋅T(n/2)+O(m)，通过计算可得 T(n)=O(mn)。\n空间复杂度：O(mlogn)，其中 m 是字符串数组中的字符串的平均长度，n 是字符串的数量。空间复杂度主要取决于递归调用的层数，层数最大为 logn，每层需要 m 的空间存储返回结果。\n\n来源\n最长公共前缀 | 力扣（LeetCode）最长公共前缀 | 题解（LeetCode）\n\n\n","categories":["LeetCode"],"tags":["Java","LeetCode","学习笔记","数组","字符串","指针","双指针","递归","分治法"]},{"title":"删除链表的倒数第N个节点","url":"/blog/2020/06/16/remove-nth-node-from-end-of-list/","content":"\n题目描述给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。\n示例：\n\n给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.\n\n说明：\n\n给定的 n 保证是有效的。\n\n进阶：\n\n你能尝试使用一趟扫描实现吗？\n\n\n\n两次遍历最简单的思路，我们发现其实是删除从列表开头数起的第 (L - n + 1) 个结点，其中 L 是列表的长度。只要我们找到列表的长度 L，这个问题就很容易解决。我们先遍历一次链表，求出链表的长度 L，然后再遍历一次链表，删除倒数第 n 个节点即可。需要注意的是如果 L = n，那么要直接返回 head.next。\n\n\npublic ListNode removeNthFromEnd(ListNode head, int n) &#123;    int len = 0;    ListNode node = head;    do &#123;        len++;        node = node.next;    &#125; while (node != null);    if (len == n) &#123;        return head.next;    &#125;    int index = 0;    node = head;    do &#123;        if (++index == len - n) &#123;            node.next = node.next.next;            return head;        &#125;        node = node.next;    &#125; while (node != null);    return head;&#125;public class ListNode &#123;    int val;    ListNode next;    ListNode(int x) &#123;        val = x;    &#125;&#125;\n\n复杂度分析\n时间复杂度：O(L)，该算法对列表进行了两次遍历，首先计算了列表的长度 L 其次找到第 L - n 个结点。 操作执行了 2L - n 步，时间复杂度为 O(L)。\n空间复杂度：O(1)，只需要额外的常数级别的空间。\n\n一次遍历上述算法可以优化为只使用一次遍历。我们可以使用两个指针而不是一个指针。第一个指针从列表的开头向前移动 n + 1 步，而第二个指针将从列表的开头出发。现在，这两个指针被 n 个结点分开。我们通过同时移动两个指针向前来保持这个恒定的间隔，直到第一个指针到达最后一个结点。此时第二个指针将指向从最后一个结点数起的第 n 个结点。我们重新链接第二个指针所引用的结点的 next 指针指向该结点的下下个结点。\n\n\npublic ListNode removeNthFromEnd(ListNode head, int n) &#123;    ListNode dummy = new ListNode(0);    dummy.next = head;    ListNode first = dummy;    ListNode second = dummy;    for (int i = 1; i &lt;= n + 1; i++) &#123;        first = first.next;    &#125;    while (first != null) &#123;        first = first.next;        second = second.next;    &#125;    second.next = second.next.next;    return dummy.next;&#125;public class ListNode &#123;    int val;    ListNode next;    ListNode(int x) &#123;        val = x;    &#125;&#125;\n\n\n复杂度分析\n时间复杂度：O(L)，该算法对含有 L 个结点的列表进行了一次遍历。因此时间复杂度为 O(L)。\n空间复杂度：O(1)，只需要额外的常数级别的空间。\n\n来源\n删除链表的倒数第N个节点 | 力扣（LeetCode）删除链表的倒数第N个节点 | 题解（LeetCode）\n\n\n","categories":["LeetCode"],"tags":["Java","LeetCode","学习笔记","链表","指针","双指针","滑动窗口"]},{"title":"验证回文串","url":"/blog/2020/06/19/valid-palindrome/","content":"\n题目描述给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。说明： 本题中，我们将空字符串定义为有效的回文串。\n示例 1:\n\n输入: “A man, a plan, a canal: Panama”输出: true\n\n示例 2:\n\n输入: “race a car”输出: false\n\n\n\n题解我们先假设，字符串中仅包含英文字母，那么判断是否是回文串，我们只需要使用两个指针i和j，同时指向字符串的首尾，然后判断i和j指向的字母是否相等，然后同时进行 i++ 和 j-- 操作，直到 i == j。用这个思路解决此题，由于字符串中包含很多非英文字母，那么我们就需要多一步处理，如果i和j指向的字符不是英文字母，那么我们就不断的进行 i++ 和 j-- 操作，直到i和j指向的字符是英文字母，然后进行比较即可。\npublic boolean isPalindrome(String s) &#123;    int i = 0;    int j = s.length() - 1;    while (i &lt; j) &#123;        while (i &lt; j &amp;&amp; !Character.isLetterOrDigit(s.charAt(i))) &#123;            i++;        &#125;        while (i &lt; j &amp;&amp; !Character.isLetterOrDigit(s.charAt(j))) &#123;            j--;        &#125;        if (i &lt; j &amp;&amp; Character.toLowerCase(s.charAt(i)) != Character.toLowerCase(s.charAt(j))) &#123;            return false;        &#125;        i++;        j--;    &#125;    return true;&#125;\n\n复杂度分析\n时间复杂度：O(n)，其中 n 是字符串的长度。\n空间复杂度：O(1)，只需要额外的常数级别的空间。\n\n来源\n验证回文串 | 力扣（LeetCode）验证回文串 | 题解（LeetCode）\n\n\n","categories":["LeetCode"],"tags":["Java","LeetCode","学习笔记","字符串","指针","双指针"]},{"title":"另一个树的子树","url":"/blog/2020/06/22/subtree-of-another-tree/","content":"\n题目描述给定两个非空二叉树 s 和 t，检验 s 中是否包含和 t 具有相同结构和节点值的子树。s 的一个子树包括 s 的一个节点和这个节点的所有子孙。s 也可以看做它自身的一棵子树。\n示例 1:\n给定的树 s:     3    / \\   4   5  / \\ 1   2给定的树 t：   4  / \\ 1   2返回 true，因为 t 与 s 的一个子树拥有相同的结构和节点值。\n\n示例 2:\n给定的树 s：     3    / \\   4   5  / \\ 1   2    /   0给定的树 t：   4  / \\ 1   2返回 false。\n\n\n\n题解首先我们需要一个可以判断二叉树是否是相同树的方法，使用递归方式处理，递归的结束条件就是 t1 或者 t2 为空，如下：\npublic boolean isEqual(TreeNode t1, TreeNode t2) &#123;    if (t1 == null || t2 == null) &#123;        return t1 == null &amp;&amp; t2 == null;    &#125; else &#123;        return t1.val == t2.val &amp;&amp; isEqual(t1.left, t2.left) &amp;&amp; isEqual(t1.right, t2.right);    &#125;&#125;\n\n接下来，回到原题，判断树 t 是否是树 s 的子树，同样使用递归，不断的判断树 s 的左子树和右子树，是否包含子树 t，递归的结束条件就是树 s 为空，或者树 s 与树 t 相等。\npublic boolean isSubtree(TreeNode s, TreeNode t) &#123;    if (s == null) &#123;        return false;    &#125;    if (isEqual(s, t)) &#123;        return true;    &#125;    return isSubtree(s.left, t) || isSubtree(s.right, t);&#125;\n\n来源\n另一个树的子树 | 力扣（LeetCode）另一个树的子树 | 题解（LeetCode）\n\n\n","categories":["LeetCode"],"tags":["Java","LeetCode","学习笔记","递归","树","二叉树","深度优先搜索"]},{"title":"用两个栈实现队列","url":"/blog/2020/06/30/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/","content":"\n题解用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )\n示例 1：\n\n输入：[“CQueue”, “appendTail”, “deleteHead”, “deleteHead”][[], [3], [], []]输出：[null, null, 3, -1]\n\n示例 2：\n\n输入：[“CQueue”, “deleteHead”, “appendTail”, “appendTail”, “deleteHead”, “deleteHead”][[], [], [5], 2, [], []]输出：[null, -1, null, null, 5, 2]\n\n提示：\n\n1 &lt;= values &lt;= 10000\n最多会对 appendTail、deleteHead 进行 10000 次调用\n\n\n\n题解队列的特性是先进先出，栈的特性是后进先出。维护两个栈，第一个栈支持插入操作，第二个栈支持删除操作。\n根据栈先进后出的特性，我们每次往第一个栈里插入元素后，第一个栈的底部元素是最后插入的元素，第一个栈的顶部元素是下一个待删除的元素。为了维护队列先进先出的特性，我们引入第二个栈，用第二个栈维护待删除的元素，在执行删除操作的时候我们首先看下第二个栈是否为空。如果为空，我们将第一个栈里的元素一个个弹出插入到第二个栈里，这样第二个栈里元素的顺序就是待删除的元素的顺序，要执行删除操作的时候我们直接弹出第二个栈的元素返回即可。\n\n\nStack&lt;Integer&gt; st1;Stack&lt;Integer&gt; st2;public CQueue() &#123;    st1 = new Stack&lt;&gt;();    st2 = new Stack&lt;&gt;();&#125;public void appendTail(int value) &#123;    st1.push(value);&#125;public int deleteHead() &#123;    if (st2.isEmpty()) &#123;        while (!st1.isEmpty()) &#123;            st2.push(st1.pop());        &#125;    &#125;    return st2.isEmpty() ? -1 : st2.pop();&#125;\n\n复杂度分析\n时间复杂度：对于插入和删除操作，时间复杂度均为 O(1)。插入不多说，对于删除操作，虽然看起来是 O(n) 的时间复杂度，但是仔细考虑下每个元素只会「至多被插入和弹出 st2 一次」，因此均摊下来每个元素被删除的时间复杂度仍为 O(1)。\n空间复杂度：O(n)。需要使用两个栈存储已有的元素。\n\n来源\n用两个栈实现队列 | 力扣（LeetCode）用两个栈实现队列 | 题解（LeetCode）\n\n\n","categories":["LeetCode"],"tags":["Java","LeetCode","学习笔记","队列","剑指Offer","栈"]},{"title":"最长重复子数组","url":"/blog/2020/07/01/maximum-length-of-repeated-subarray/","content":"\n题目描述给两个整数数组 A 和 B ，返回两个数组中公共的、长度最长的子数组的长度。\n示例：\n\n输入：A: [1, 2, 3, 2, 1]B: [3, 2, 1, 4, 7]输出：3解释：长度最长的公共子数组是 [3, 2, 1] 。\n\n提示：\n\n1 &lt;= len(A), len(B) &lt;= 1000\n0 &lt;= A[i], B[i] &lt; 100\n\n\n\n暴力方法最简单的方法，暴力方法，我们知道最长公共子数组长度最大值为数组A和B中长度较小值。我们先固定最长值为min(len(A), len(B))，然后遍历A和B，判断此长度是否有公共子数组，找到，则返回此值。\npublic int findLength(int[] A, int[] B) &#123;    int len = Math.min(A.length, B.length);    int res_len = len;    while (res_len &gt; 0) &#123;        for (int ai = 0; ai + res_len &lt;= len; ai++) &#123;            for (int bi = 0; bi + res_len &lt;= len; bi++) &#123;                // 判断固定长度的子数组是否相等                if (subArrayIsSame(A, B, ai, bi, res_len)) &#123;                    return res_len;                &#125;            &#125;        &#125;        // 如果不相等，最大长度减一        res_len--;    &#125;    return res_len;&#125;public boolean subArrayIsSame(int[] A, int[] B, int ai, int bi, int len) &#123;    for (int i = 0; i &lt; len; i++) &#123;        if (A[ai + i] != B[bi + i]) &#123;            return false;        &#125;    &#125;    return true;&#125;\n\n复杂度分析\n时间复杂度：Ο(N³)，因为要遍历A、B和公共子数组。\n空间复杂度：Ο(1)。\n\n滑动窗口以题目为例，它们的最长重复子数组是 [3, 2, 1]，在 A 与 B 中的开始位置不同。但如果我们知道了开始位置，我们就可以根据它们将 A 和 B 进行「对齐」，即：\nA = [1, 2, 3, 2, 1]B =       [3, 2, 1, 4, 7]           ↑  ↑  ↑\n\n此时，最长重复子数组在 A 和 B 中的开始位置相同，我们就可以对这两个数组进行一次遍历，得到子数组的长度。我们可以枚举 A 和 B 所有的对齐方式。对齐的方式有两类：第一类为 A 不变，B 的首元素与 A 中的某个元素对齐；第二类为 B 不变，A 的首元素与 B 中的某个元素对齐。对于每一种对齐方式，我们计算它们相对位置相同的重复子数组即可。\n\n\npublic int findLength(int[] A, int[] B) &#123;    int lenA = A.length;    int lenB = B.length;    int ret = 0;    for (int i = 0; i &lt; lenA; i++) &#123;        int len = Math.min(lenA - i, lenB);        int maxLen = maxLength(A, B, i, 0, len);        ret = Math.max(ret, maxLen);    &#125;    for (int i = 0; i &lt; lenB; i++) &#123;        int len = Math.min(lenB - i, lenA);        int maxLen = maxLength(A, B, 0, i, len);        ret = Math.max(ret, maxLen);    &#125;    return ret;&#125;// 对齐后计算最长公共子数组public int maxLength(int[] A, int[] B, int indexA, int indexB, int len) &#123;    int ret = 0;    int maxLen = 0;    for (int i = 0; i &lt; len; i++) &#123;        if (A[indexA + i] == B[indexB + i]) &#123;            maxLen++;        &#125; else &#123;            maxLen = 0;        &#125;        ret = Math.max(ret, maxLen);    &#125;    return ret;&#125;\n\n复杂度分析\n时间复杂度： Ο((M + N) × min(M, N))。\n空间复杂度： Ο(1)。\nM 表示数组 A 的长度，N 表示数组 B 的长度。\n\n\n\n动态规划我们使用A[i]，B[j]分别表示两个数组对应下标的值。如果 A[i] == B[j]，那么我们知道 A[i:] 与 B[j:] 的最长公共前缀为 A[i + 1:] 与 B[j + 1:] 的最长公共前缀的长度加一，否则我们知道 A[i:] 与 B[j:] 的最长公共前缀为零。这样我们就可以提出动态规划的解法：令 dp[i][j] 表示 A[i:] 和 B[j:] 的最长公共前缀，那么答案即为所有 dp[i][j] 中的最大值。如果 A[i] == B[j]，那么 dp[i][j] = dp[i + 1][j + 1] + 1，否则 dp[i][j] = 0。考虑到这里 dp[i][j] 的值从 dp[i + 1][j + 1] 转移得到，所以我们需要倒过来，首先计算 dp[len(A) - 1][len(B) - 1]，最后计算 dp[0][0]。\npublic int findLength(int[] A, int[] B) &#123;    int n = A.length, m = B.length;    int[][] dp = new int[n + 1][m + 1];    int ret = 0;    for (int i = n - 1; i &gt;= 0; i--) &#123;        for (int j = m - 1; j &gt;= 0; j--) &#123;            dp[i][j] = A[i] == B[j] ? dp[i + 1][j + 1] + 1 : 0;            ret = Math.max(ret, dp[i][j]);        &#125;    &#125;    return ret;&#125;\n\n复杂度分析\n时间复杂度： O(M × N)。\n空间复杂度： O(M × N)。\nN 表示数组 A 的长度，M 表示数组 B 的长度。\n\n\n\n来源\n最长重复子数组 | 力扣（LeetCode）最长重复子数组 | 题解（LeetCode）\n\n\n","categories":["LeetCode"],"tags":["Java","LeetCode","学习笔记","数组","滑动窗口","动态规划"]},{"title":"路经总和","url":"/blog/2020/07/06/path-sum/","content":"\n题目描述给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。说明: 叶子节点是指没有子节点的节点。\n示例: \n给定如下二叉树，以及目标和 sum = 22        5       / \\      4   8     /   / \\    11  13  4   /  \\      \\  7    2      1返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5-&gt;4-&gt;11-&gt;2。\n\n\n\n题解此题使用递归解决思路就会比较清晰，针对 root 节点，我们求其左右两棵子树的路径和是否为 root.val - sum，针对左右子树，同样递归解决。递归的结束条件就是遍历到叶子节点，直接判断 sum 是否等于 val 即可。因为到达叶子节点的时候，sum 的值已经被减去走过的路径的值了。需要注意的是给定的 root 可能为空。同样的，递归的结束条件也要判断节点是否为空。\nclass Solution &#123;    public boolean hasPathSum(TreeNode root, int sum) &#123;        if (root == null) &#123;            return false;        &#125;        if (root.left == null &amp;&amp; root.right == null) &#123;            return sum == root.val;        &#125;        return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);    &#125;&#125;public class TreeNode &#123;    int val;    TreeNode left;    TreeNode right;    TreeNode(int x) &#123;        val = x;    &#125;&#125;\n\n复杂度分析\n时间复杂度：Ο(N)，其中 N 是树的节点数。对每个节点访问一次。\n空间复杂度：Ο(H)，其中 H 是树的高度。空间复杂度主要取决于递归时栈空间的开销，最坏情况下，树呈现链状，空间复杂度为 Ο(N)。平均情况下树的高度与节点数的对数正相关，空间复杂度为 Ο(logN)。\n\n来源\n路径总和 | 力扣（LeetCode）路径总和 | 题解（LeetCode）\n\n\n","categories":["LeetCode"],"tags":["Java","LeetCode","学习笔记","递归","树","二叉树","深度优先搜索","中序遍历"]},{"title":"路径总和 II","url":"/blog/2020/07/07/path-sum-ii/","content":"\n题目描述给定一个二叉树和一个目标和，找到所有从根节点到叶子节点路径总和等于给定目标和的路径。说明: 叶子节点是指没有子节点的节点。\n示例:\n给定如下二叉树，以及目标和 sum = 22，      5     / \\    4   8   /   / \\  11  13  4 /  \\    / \\7    2  5   1返回:[   [5,4,11,2],   [5,8,4,5]]\n\n\n\n题解做此题之前，可以先做一道简单版的路径总和，简单版的只要遍历全部节点，遇到满足条件的路径返回 true 即可，而此题不仅要遍历全部节点，还要记录满足条件的路径。此题是典型的回溯算法，思路就是，先声明一个LinkedList&lt;Integer&gt; path保存路径，List&lt;List&lt;Integer&gt;&gt; ans保存所有路径，我们每遍历到一个节点，就将这个节点的值保存在 path 中，当判断到子节点，如果此节点的值满足 sum 等于 val，则将 path 加入到 ans 中，否则继续进行递归遍历左右子树。注意入参 root 可能为空，另外递归的结束条件也包含节点为空。当递归回溯的时候，我们就删除最后加入到 path 中的节点。\nList&lt;List&lt;Integer&gt;&gt; ans = new LinkedList&lt;&gt;();LinkedList&lt;Integer&gt; path = new LinkedList&lt;&gt;();public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int sum) &#123;    if (root == null) &#123;        return ans;    &#125;    path.add(root.val);    if (root.left == null &amp;&amp; root.right == null) &#123;        if (sum == root.val) &#123;            // 此处new LinkedList&lt;&gt;(path)新建一个链表            // 因为如果直接add(path)，ans中的路径和path是相同的引用，后面操作path后，ans中的路径也将一起被修改。            ans.add(new LinkedList&lt;&gt;(path));            // 此处无需return，因为后续pathSum递归的时候root.left和root.right都为空，满足递归结束条件。        &#125;    &#125;    pathSum(root.left, sum - root.val);    pathSum(root.right, sum - root.val);    // 递归回溯的时候删除最后一个节点，此处使用LinkedList提升效率    path.removeLast();    return ans;&#125;public class TreeNode &#123;    int val;    TreeNode left;    TreeNode right;    TreeNode(int x) &#123;        val = x;    &#125;&#125;\n\n来源\n路径总和 II | 力扣（LeetCode）路径总和 II | 题解（LeetCode）\n\n\n","categories":["LeetCode"],"tags":["Java","LeetCode","学习笔记","递归","回溯算法","树","二叉树","深度优先搜索","中序遍历"]},{"title":"跳水板","url":"/blog/2020/07/08/diving-board-lcci/","content":"\n题目描述你正在使用一堆木板建造跳水板。有两种类型的木板，其中长度较短的木板长度为shorter，长度较长的木板长度为longer。你必须正好使用k块木板。编写一个方法，生成跳水板所有可能的长度。返回的长度需要从小到大排列。\n示例 1：\n\n输入：shorter = 1longer = 2k = 3输出： [3, 4, 5, 6]解释：可以使用 3 次 shorter，得到结果 3；使用 2 次 shorter 和 1 次 longer，得到结果 4 。以此类推，得到最终结果。\n\n提示：\n\n0 &lt; shorter &lt;= longer\n0 &lt;= k &lt;= 100000\n\n\n\n题解考虑两种情况，如果k为0，那么不会建造任何跳水板，直接返回空数组。另外一种情况，如果shorter与longer相等，那么跳水板的长度是唯一的，就是 shorter * k ，于是返回长度为 1 的数组，数组中的元素为 shorter ∗ k。\n当shorter不等于longer的情况，我们考虑跳水板最短的情况，就是全是短木板，此时的长度是 shorter * k，我们每次增加一块长木板，减少一块短木板，由于共有 k 块木板，于是共有 k + 1 种长度 k + 1 种组合。每次木板的长度变化是 longer - shorter。\npublic int[] divingBoard(int shorter, int longer, int k) &#123;    if (k == 0) &#123;        return new int[0];    &#125;    int min = shorter * k;    int difference = longer - shorter;    if (difference == 0) &#123;        return new int[]&#123;min&#125;;    &#125;    int[] ans = new int[k + 1];    ans[0] = min;    for (int i = 1; i &lt;= k; i++) &#123;        ans[i] = ans[i - 1] + difference;    &#125;    return ans;&#125;\n\n复杂度分析\n时间复杂度：O(k)，其中 k 是木板数量。短木板和长木板一共使用 k 块，一共有 k + 1 种组合，对于每种组合都要计算跳水板的长度。\n空间复杂度：O(1)，只需要额外的常数级别的空间。\n\n来源\n跳水板 | 力扣（LeetCode）跳水板 | 题解（LeetCode）\n\n\n","categories":["LeetCode"],"tags":["Java","LeetCode","学习笔记","数组","程序员面试金典","数学"]},{"title":"恢复空格","url":"/blog/2020/07/09/re-space-lcci/","content":"\n题目描述哦，不！你不小心把一个长篇文章中的空格、标点都删掉了，并且大写也弄成了小写。像句子”I reset the computer. It still didn’t boot!”已经变成了”iresetthecomputeritstilldidntboot”。在处理标点符号和大小写之前，你得先把它断成词语。当然了，你有一本厚厚的词典dictionary，不过，有些词没在词典里。假设文章用sentence表示，设计一个算法，把文章断开，要求未识别的字符最少，返回未识别的字符数。\n示例：\n\n输入：dictionary = [“looked”, “just”, “like”, “her”, “brother”]sentence = “jesslookedjustliketimherbrother”输出： 7解释： 断句后为”jess looked just like tim her brother”，共7个未识别字符。\n\n提示：\n\n0 &lt;= len(sentence) &lt;= 1000\ndictionary中总字符数不超过 150000。\n你可以认为dictionary和sentence中只包含小写字母。\n\n\n\n动态规划这里采用动态规划，创建一个数组 dp 用来记录结果。句子从前往后看，其中 dp[0]=0 表示句子是空字符串时没有未识别的字符，dp[i] 表示句子前 i 个字符中最少的未识别字符数。然后来找状态转移方程。对于前 i 个字符，即句子字符串的 [0,i)，它可能是由最前面的 [0,j) 子字符串加上一个字典匹配的单词得到，也就是 dp[i]=dp[j], j &lt; i；也可能没找到字典中的单词，可以用它前 i - 1 个字符的结果加上一个没有匹配到的第 i 个字符，即 dp[i] = dp[i-1] + 1。要注意的是，即使前面存在匹配的单词，也不能保证哪一种剩下的字符最少，所以每轮都要比较一次最小值。\npublic int respace(String[] dictionary, String sentence) &#123;    List&lt;String&gt; dic = Arrays.asList(dictionary);    int len = sentence.length();    // dp[i]表示sentence前i个字符所得结果    int[] dp = new int[len + 1];    for (int i = 1; i &lt;= len; i++) &#123;        dp[i] = dp[i - 1] + 1;  // 先假设当前字符作为单词不在字典中        for (int j = 0; j &lt; i; j++) &#123;            if (dic.contains(sentence.substring(j, i))) &#123;                dp[i] = Math.min(dp[i], dp[j]);            &#125;        &#125;    &#125;    return dp[len];&#125;\n\n复杂度分析\n时间复杂度：Ο(n²)，其中 n 是字符串长度。\n空间复杂度：O(n)，其中 n 是字符串长度，保存dp的中间值。\n\n字典树这里重点讲述Trie字典树的解法。首先看一个字典树的例子：\n\n\n该树包含的单词集合为 {“at”, “bee”, “ben”, “bt”, “q”}。每一个节点保存一个字符，因为题目说只包含小写字母，所以一个节点最多可以有 26 个子节点。每次查找单词都从空白的根节点开始，比如查找单词 “cat”，第一个字符 ‘c’ 就不存在，直接返回 false；查找单词 “bee”，根节点下有 b，b 的子节点有 e，下面还有 e 所以查到了。但是如果查找单词”be”,同样的方法 ‘b’ 和 ‘e’ 都存在，但是字典里没有 “be” 这个单词，所以在树里还需要一个 boolean 变量表示当前节点是不是一个单词的结尾，如图绿色表示。如果往字典中插入一个 “be” 单词，此时 b 节点下的 e 节点也应该标绿，此时再查找 “be”，在 e 节点发现它是个单词，所以返回 true。\n使用字典树可利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较。\npublic int respace(String[] dictionary, String sentence) &#123;    root = new TrieNode();    makeTrie(dictionary);   //创建字典树    int n = sentence.length();    int[] dp = new int[n + 1];    //这里从sentence最后一个字符开始    for (int i = n - 1; i &gt;= 0; i--) &#123;        dp[i] = n - i;    //初始默认后面全不匹配        TrieNode node = root;        for (int j = i; j &lt; n; j++) &#123;            int c = sentence.charAt(j) - &#x27;a&#x27;;            if (node.childs[c] == null) &#123;                //例如&quot;abcde&quot;,i=1,j=2 可找出长度关系                dp[i] = Math.min(dp[i], j - i + 1 + dp[j + 1]);                break;            &#125;            if (node.childs[c].isWord) &#123;                dp[i] = Math.min(dp[i], dp[j + 1]);            &#125; else &#123;                dp[i] = Math.min(dp[i], j - i + 1 + dp[j + 1]);            &#125;            node = node.childs[c];        &#125;    &#125;    return dp[0];&#125;public void makeTrie(String[] dictionary) &#123;    for (String str : dictionary) &#123;        TrieNode node = root;        for (int k = 0; k &lt; str.length(); k++) &#123;            int i = str.charAt(k) - &#x27;a&#x27;;            if (node.childs[i] == null) &#123;                node.childs[i] = new TrieNode();            &#125;            node = node.childs[i];        &#125;        node.isWord = true; //单词的结尾    &#125;&#125;/** * 自定义一个TrieNode类型。 * 这里不用建一个变量来存当前节点表示的字符， * 因为只要该节点不为null，就说明存在这个字符 */class TrieNode &#123;    TrieNode[] childs;    boolean isWord;    public TrieNode() &#123;        childs = new TrieNode[26];        isWord = false;    &#125;&#125;\n\n来源\n恢复空格 | 力扣（LeetCode）恢复空格 | 题解（LeetCode）\n\n\n","categories":["LeetCode"],"tags":["Java","LeetCode","学习笔记","字符串","动态规划","程序员面试金典","字典树"]},{"title":"三角形最小路径和","url":"/blog/2020/07/14/triangle/","content":"\n题目描述给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。相邻的结点，在这里指的是下标与上一层结点下标相同或者等于上一层结点下标 + 1 的两个结点。\n例如，给定三角形：\n[     [2],    [3, 4],   [6, 5, 7],  [4, 1, 8, 3]]\n自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。\n\n\n递归给定的三角形的行数为 n，并且第 i 行（从 0 开始编号）包含了 i + 1 个数。如果将每一行的左端对齐，那么会形成一个等腰直角三角形，如下所示：\n[2],[3, 4],[6, 5, 7],[4, 1, 8, 3]\n\n这样，我们可以从顶点自上而下递归处理最小路径和，首先从顶点开始，他的最小路径和是顶点的数2加上下面的以3为顶点的最短路径和，或者顶点2加上下面以4为顶点的最短路径和，取其中的最小值，并不断递归处理。这里需要注意的一点是，对于第二行的顶点3和4，计算他们下一层的最短路径和的时候，会计算两遍第三行的以5为顶点的三角形最短路径和。所以我们在递归的同时，记录下计算过的路径和，防止重复计算。\npublic int minimumTotal(List&lt;List&lt;Integer&gt;&gt; triangle) &#123;    if (triangle == null || triangle.isEmpty() || triangle.get(0).isEmpty()) &#123;        return 0;    &#125;    // 用来保存某个顶点计算过的最短路径和    int[][] minValue = new int[triangle.size() + 1][triangle.size() + 1];    for (int i = 0; i &lt; minValue.length; i++) &#123;        Arrays.fill(minValue[i], Integer.MAX_VALUE);    &#125;    int value = triangle.get(0).get(0);    int leftValue = value + minimumTotal(triangle, 1, 0, minValue);    int rightValue = value + minimumTotal(triangle, 1, 1, minValue);    return Math.min(leftValue, rightValue);&#125;public int minimumTotal(List&lt;List&lt;Integer&gt;&gt; triangle, int row, int column, int[][] minValue) &#123;    if (row &gt;= triangle.size() || column &gt;= triangle.get(row).size()) &#123;        return 0;    &#125;    int value = triangle.get(row).get(column);    int leftValue = value + (minValue[row + 1][column] &lt; Integer.MAX_VALUE ? minValue[row + 1][column]            : minimumTotal(triangle, row + 1, column, minValue));    int rightValue = value + (minValue[row + 1][column + 1] &lt; Integer.MAX_VALUE ? minValue[row + 1][column + 1]            : minimumTotal(triangle, row + 1, column + 1, minValue));    return minValue[row][column] = Math.min(leftValue, rightValue);&#125;\n\n复杂度分析\n时间复杂度：O(n²)，其中 n 是三角形的行数。\n空间复杂度：O(n²)，我们需要一个 n ∗ n 的二维数组存放记录的值。\n\n动态规划-自顶向下我们用 f[i][j] 表示从三角形顶部走到位置 (i, j) 的最小路径和。这里的位置 (i, j) 指的是三角形中第 i 行第 j 列（均从 0 开始编号）的位置。由于每一步只能移动到下一行「相邻的节点」上，因此要想走到位置 (i, j)，上一步就只能在位置 (i - 1, j - 1) 或者位置 (i - 1, j)。我们在这两个位置中选择一个路径和较小的来进行转移，状态转移方程为：\n\nf[i][j] = min(f[i − 1][j − 1], f[i − 1][j]) + c[i][j]\n\n其中 c[i][j] 表示位置 (i, j) 对应的元素值。注意第 i 行有 i + 1 个元素，它们对应的 j 的范围为 [0, i]。当 j = 0 或 j = i 时，上述状态转移方程中有一些项是没有意义的。例如当 j = 0 时，f[i − 1][j − 1] 没有意义，因此状态转移方程为：\n\nf[i][0] = f[i − 1][0] + c[i][0]\n\n即当我们在第 i 行的最左侧时，我们只能从第 i − 1 行的最左侧移动过来。当 j = i 时，f[i - 1][j] 没有意义，因此状态转移方程为：\n\nf[i][i] = f[i − 1][i − 1] + c[i][i]\n\n即当我们在第 i 行的最右侧时，我们只能从第 i − 1 行的最右侧移动过来。最终的答案即为 f[n − 1][0] 到 f[n − 1][n − 1] 中的最小值，其中 n 是三角形的行数。边界条件为：\n\nf[0][0] = c[0][0]\n\n即在三角形的顶部时，最小路径和就等于对应位置的元素值。这样一来，我们从 1 开始递增地枚举 i，并在 [0, i] 的范围内递增地枚举 j，就可以完成所有状态的计算。\npublic int minimumTotal(List&lt;List&lt;Integer&gt;&gt; triangle) &#123;    int n = triangle.size();    int[][] dp = new int[n][n];    dp[0][0] = triangle.get(0).get(0);    for (int i = 1; i &lt; n; i++) &#123;        dp[i][0] = dp[i - 1][0] + triangle.get(i).get(0);        for (int j = 1; j &lt; i; j++) &#123;            dp[i][j] = Math.min(dp[i - 1][j - 1], dp[i - 1][j]) + triangle.get(i).get(j);        &#125;        dp[i][i] = dp[i - 1][i - 1] + triangle.get(i).get(i);    &#125;    int minTotal = dp[n - 1][0];    for (int i = 1; i &lt; n; ++i) &#123;        minTotal = Math.min(minTotal, dp[n - 1][i]);    &#125;    return minTotal;&#125;\n\n复杂度分析\n时间复杂度：O(n²)，其中 n 是三角形的行数。\n空间复杂度：O(n²)，我们需要一个 n ∗ n 的二维数组存放所有的状态。\n\n动态规划-自底向上跟上述的方法一致，只不过我们采用自底向上的方法，状态转移方程为：\n\ndp[i][j] = min(dp[i + 1][j], dp[i + 1][j + 1]) + c[i][j]\n\npublic int minimumTotal(List&lt;List&lt;Integer&gt;&gt; triangle) &#123;    int n = triangle.size();    // 多申请1空间防止越界    int[][] dp = new int[n + 1][n + 1];    for (int i = n - 1; i &gt;= 0; i--) &#123;        for (int j = 0; j &lt;= i; j++) &#123;            dp[i][j] = Math.min(dp[i + 1][j], dp[i + 1][j + 1]) + triangle.get(i).get(j);        &#125;    &#125;    return dp[0][0];&#125;\n\n复杂度分析\n时间复杂度：O(n²)，其中 n 是三角形的行数。\n空间复杂度：O(n²)，我们需要一个 n ∗ n 的二维数组存放所有的状态。\n\n动态规划-空间优化在上述代码中，我们定义了一个 N 行 N 列 的 dp 数组（N 是三角形的行数）。但是在实际递推中我们发现，计算 dp[i][j] 时，只用到了下一行的 dp[i + 1][j] 和 dp[i + 1][j + 1]。因此 dp 数组不需要定义 N 行，只要定义 1 行就行。所以我们稍微修改一下上述代码，将 i 所在的维度去掉（如下），就可以将 O(N²) 的空间复杂度优化成 O(N)。\npublic int minimumTotal(List&lt;List&lt;Integer&gt;&gt; triangle) &#123;    int n = triangle.size();    int[] dp = new int[n + 1];    for (int i = n - 1; i &gt;= 0; i--) &#123;        for (int j = 0; j &lt;= i; j++) &#123;            dp[j] = Math.min(dp[j], dp[j + 1]) + triangle.get(i).get(j);        &#125;    &#125;    return dp[0];&#125;\n\n复杂度分析\n时间复杂度：O(n²)，其中 n 是三角形的行数。\n空间复杂度：O(n)，我们需要一个 n 的一维数组存放所有的状态。\n\n来源\n三角形最小路径和 | 力扣（LeetCode）三角形最小路径和 | 题解（LeetCode）\n\n\n","categories":["LeetCode"],"tags":["Java","LeetCode","学习笔记","数组","递归","记忆化","动态规划","滚动数组","深度优先搜索"]},{"title":"二叉搜索树的第k大节点","url":"/blog/2020/07/15/kda-jie-dian-lcof/","content":"\n题目描述给定一棵二叉搜索树，请找出其中第k大的节点。\n示例 1:\n输入: root = [3, 1, 4, null, 2], k = 1   3  / \\ 1   4  \\   2输出: 4\n\n示例 2:\n输入: root = [5, 3, 6, 2, 4, null, null, 1], k = 3       5      / \\     3   6    / \\   2   4  / 1输出: 4\n\n限制：1 ≤ k ≤ 二叉搜索树元素个数\n\n\n题解二叉搜索树的中序遍历是递增序列，那么倒序就是递减序列。\n\n中序遍历为“左、根、右”的顺序中序遍历的倒序为“右、根、左”的顺序\n\n// 打印中序遍历void dfs(TreeNode root) &#123;    if(root == null) return;    dfs(root.left); // 左    System.out.println(root.val); // 根    dfs(root.right); // 右&#125;\n\n所以我们只要求出二叉搜索树的中序遍历倒序的第k个节点即可。\n递归解析：\n\n递归的终止条件：当节点为空的时候，越过了叶子节点，则直接返回;\n递归右子树：dfs(root.right);\n递归操作：先进行k - 1，然后判断 k 是否等于0，是则找到第k大的节点，将节点的值返回。\n递归左子树：dfs(root.left);\n\n\n\nint k;int res;public int kthLargest(TreeNode root, int k) &#123;    this.k = k;    dfs(root);    return res;&#125;public void dfs(TreeNode t) &#123;    if (t == null) &#123;        return;    &#125;    dfs(t.right);    if (k == 0) &#123;        return;    &#125;    if (--k == 0) &#123;        res = t.val;        return;    &#125;    dfs(t.left);&#125;public class TreeNode &#123;    int val;    TreeNode left;    TreeNode right;    TreeNode(int x) &#123;        val = x;    &#125;&#125;\n\n复杂度分析\n时间复杂度 Ο(N) ： 当树退化为链表时（全部为右子节点），无论 k 的值大小，递归深度都为 N ，占用 Ο(N) 时间。\n空间复杂度 Ο(N) ： 当树退化为链表时（全部为右子节点），系统使用 Ο(N) 大小的栈空间。\n\n来源\n二叉搜索树的第k大节点 | 力扣（LeetCode）二叉搜索树的第k大节点 | 题解（LeetCode）\n\n\n","categories":["LeetCode"],"tags":["Java","LeetCode","学习笔记","递归","剑指Offer","树","二叉树","深度优先搜索","中序遍历","二叉搜索树"]},{"title":"验证二叉搜索树","url":"/blog/2020/07/15/validate-binary-search-tree/","content":"\n题目描述给定一个二叉树，判断其是否是一个有效的二叉搜索树。假设一个二叉搜索树具有如下特征：\n\n节点的左子树只包含小于当前节点的数。\n节点的右子树只包含大于当前节点的数。\n所有左子树和右子树自身必须也是二叉搜索树。\n\n示例 1:\n输入:    2   / \\  1   3输出: true\n\n示例 2:\n输入:    5   / \\  1   4     / \\    3   6输出: false解释: 输入为: [5, 1, 4, null, null, 3, 6]。根节点的值为 5 ，但是其右子节点值为 4 。\n\n\n\n递归由题目给出的信息我们可以知道：如果该二叉树的左子树不为空，则左子树上所有节点的值均小于它的根节点的值；若它的右子树不空，则右子树上所有节点的值均大于它的根节点的值；它的左右子树也为二叉搜索树。\n于是我们设计一个递归函数 isValidBST(root, lower, upper) 来递归判断，函数表示考虑以 root 为根的子树，判断子树中所有节点的值是否都在 (l, r) 的范围内（注意是开区间）。如果 root 节点的值 val 不在 ((l, r) 的范围内说明不满足条件直接返回，否则我们要继续递归调用检查它的左右子树是否满足，如果都满足才说明这是一棵二叉搜索树。\n那么根据二叉搜索树的性质，在递归调用左子树时，我们需要把上界 upper 改为 root.val，即调用 isValidBST(root.left, lower, root.val)，因为左子树里所有节点的值均小于它的根节点的值。同理递归调用右子树时，我们需要把下界 lower 改为 root.val，即调用 isValidBST(root.right, root.val, upper)。函数递归调用的入口为 isValidBST(root, -inf, +inf)， inf 表示一个无穷大的值。\npublic boolean isValidBST(TreeNode root) &#123;    // 无穷大和无穷小用null表示，这里不能用Integer.MAX_VALUE和Integer.MIN_VALUE    return isValidBST(root, null, null);&#125;public boolean isValidBST(TreeNode node, Integer lower, Integer upper) &#123;    if (node == null) &#123;        return true;    &#125;    int val = node.val;    if (lower != null &amp;&amp; val &lt;= lower) &#123;        return false;    &#125;    if (upper != null &amp;&amp; val &gt;= upper) &#123;        return false;    &#125;    if (!isValidBST(node.right, val, upper)) &#123;        return false;    &#125;    if (!isValidBST(node.left, lower, val)) &#123;        return false;    &#125;    return true;&#125;public class TreeNode &#123;    int val;    TreeNode left;    TreeNode right;    TreeNode(int x) &#123;        val = x;    &#125;&#125;\n\n复杂度分析\n时间复杂度：O(n)，其中 n 为二叉树的节点个数。在递归调用的时候二叉树的每个节点最多被访问一次，因此时间复杂度为 O(n)。\n空间复杂度：O(n)，其中 n 为二叉树的节点个数。递归函数在递归过程中需要为每一层递归函数分配栈空间，所以这里需要额外的空间且该空间取决于递归的深度，即二叉树的高度。最坏情况下二叉树为一条链，树的高度为 n ，递归最深达到 n 层，故最坏情况下空间复杂度为 O(n) 。\n\n中序遍历我们知道二叉搜索树「中序遍历」得到的值构成的序列一定是升序的，中序遍历是二叉树的一种遍历方式，它先遍历左子树，再遍历根节点，最后遍历右子树。而我们二叉搜索树保证了左子树的节点的值均小于根节点的值，根节点的值均小于右子树的值，因此中序遍历以后得到的序列一定是升序序列。这启示我们在中序遍历的时候实时检查当前节点的值是否大于前一个中序遍历到的节点的值即可。如果均大于说明这个序列是升序的，整棵树是二叉搜索树，否则不是。\nlong pre = Long.MIN_VALUE;public boolean isValidBST(TreeNode root) &#123;    if (root == null) &#123;        return true;    &#125;    // 访问左子树    if (!isValidBST(root.left)) &#123;        return false;    &#125;    // 访问当前节点：如果当前节点小于等于中序遍历的前一个节点，说明不满足BST，返回 false；否则继续遍历。    if (root.val &lt;= pre) &#123;        return false;    &#125;    pre = root.val;    // 访问右子树    return isValidBST(root.right);&#125;public static class TreeNode &#123;    int val;    TreeNode left;    TreeNode right;    TreeNode(int x) &#123;        val = x;    &#125;&#125;\n\n复杂度分析\n时间复杂度：O(n)，其中 n 为二叉树的节点个数。在递归调用的时候二叉树的每个节点最多被访问一次，因此时间复杂度为 O(n)。\n空间复杂度：O(n)，其中 n 为二叉树的节点个数。递归函数在递归过程中需要为每一层递归函数分配栈空间，所以这里需要额外的空间且该空间取决于递归的深度，即二叉树的高度。最坏情况下二叉树为一条链，树的高度为 n ，递归最深达到 n 层，故最坏情况下空间复杂度为 O(n) 。\n\n来源\n验证二叉搜索树 | 力扣（LeetCode）验证二叉搜索树 | 题解（LeetCode）\n\n\n","categories":["LeetCode"],"tags":["Java","LeetCode","学习笔记","递归","树","二叉树","深度优先搜索","中序遍历","二叉搜索树"]},{"title":"反转链表","url":"/blog/2020/07/16/reverse-linked-list/","content":"\n题目描述反转一个单链表。\n示例:\n\n输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL\n\n进阶:\n\n你可以迭代或递归地反转链表。你能否用两种方法解决这道题？\n\n\n\n迭代假设存在链表 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL，我们想要把它改成 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL。在遍历列表时，将当前节点的 next 指针改为指向前一个元素。由于节点没有引用其上一个节点，因此必须事先存储其前一个元素。在更改引用之前，还需要另一个指针来存储下一个节点。不要忘记在最后返回新的头引用！\npublic ListNode reverseList(ListNode head) &#123;    ListNode prev = null;    ListNode curr = head;    while (curr != null) &#123;        ListNode next = curr.next;        curr.next = prev;        prev = curr;        curr = next;    &#125;    return prev;&#125;public class ListNode &#123;    int val;    ListNode next;    ListNode(int x) &#123;        val = x;    &#125;&#125;\n\n复杂度分析\n时间复杂度：Ο(N)，其中 N 是列表的长度。\n空间复杂度：Ο(1)。\n\n递归假设节点n后面的链表均被反转，那么我需要将n的下一个节点指向n，于是有 n.next.next = n ，然后将n的下一个节点指向null，既 n.next = null。\npublic ListNode reverseList(ListNode head) &#123;    if (head == null || head.next == null) &#123;        return head;    &#125;    ListNode res = reverseList(head.next);    head.next.next = head;    head.next = null;    return res;&#125;public class ListNode &#123;    int val;    ListNode next;    ListNode(int x) &#123;        val = x;    &#125;&#125;\n\n复杂度分析\n时间复杂度：Ο(N)，其中 N 是列表的长度。\n空间复杂度：Ο(N)。由于使用递归，将会使用隐式栈空间。递归深度可能会达到 N 层。\n\n来源\n反转链表 | 力扣（LeetCode）反转链表 | 题解（LeetCode）\n\n\n","categories":["LeetCode"],"tags":["Java","LeetCode","学习笔记","链表","递归"]},{"title":"最小路径和","url":"/blog/2020/07/23/minimum-path-sum/","content":"\n题目描述给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。\n说明： 每次只能向下或者向右移动一步。\n示例:\n输入:[  [1,3,1],  [1,5,1],  [4,2,1]]输出: 7解释: 因为路径 1→3→1→1→1 的总和最小。\n\n\n\n动态规划此题是典型的动态规划问题，由于路径的方向只能是向下或向右，因此网格的第一行的每个元素只能从左上角元素开始向右移动到达，网格的第一列的每个元素只能从左上角元素开始向下移动到达，此时的路径是唯一的，因此每个元素对应的最小路径和即为对应的路径上的数字总和。对于不在第一行和第一列的元素，可以从其上方相邻元素向下移动一步到达，或者从其左方相邻元素向右移动一步到达，元素对应的最小路径和等于其上方相邻元素与其左方相邻元素两者对应的最小路径和中的最小值加上当前元素的值。\n创建二维数组 dp，与原始网格的大小相同，dp[i][j] 表示从左上角出发到 (i, j) 位置的最小路径和。显然，dp[0][0]=grid[0][0]。对于 dp 中的其余元素，通过以下状态转移方程计算元素值。\n\n当 i &gt; 0 且 j = 0 时，dp[i][0] = dp[i − 1][0] + grid[i][0]。\n当 i = 0 且 j &gt; 0 时，dp[0][j] = dp[0][j − 1] + grid[0][j]。\n当 i &gt; 0 且 j &gt; 0 时，dp[i][j] = min(dp[i − 1][j], dp[i][j − 1]) + grid[i][j]。\n\n最后得到 dp[m − 1][n − 1] 的值即为从网格左上角到网格右下角的最小路径和。\npublic int minPathSum(int[][] grid) &#123;    if (grid == null || grid.length == 0 || grid[0].length == 0) &#123;        return 0;    &#125;    int row = grid.length;    int col = grid[0].length;    int[][] dp = new int[row][col];    dp[0][0] = grid[0][0];    for (int i = 1; i &lt; row; i++) &#123;        dp[i][0] = grid[i][0] + dp[i - 1][0];    &#125;    for (int j = 1; j &lt; col; j++) &#123;        dp[0][j] = grid[0][j] + dp[0][j - 1];    &#125;    for (int i = 1; i &lt; row; i++) &#123;        dp[i][0] = dp[i - 1][0] + grid[i][0];        for (int j = 1; j &lt; col; j++) &#123;            dp[i][j] = grid[i][j] + Math.min(dp[i - 1][j], dp[i][j - 1]);        &#125;    &#125;    return dp[row - 1][col - 1];&#125;\n\n复杂度分析\n时间复杂度：Ο(mn)，其中 m 和 n 分别是网格的行数和列数。需要对整个网格遍历一次，计算 dp 的每个元素的值。\n空间复杂度：O(mn)，其中 m 和 n 分别是网格的行数和列数。创建一个二维数组 dp，和网格大小相同。空间复杂度可以优化，例如每次只存储上一行的 dp 值，则可以将空间复杂度优化到 O(n)。\n\n递归在我不会动态规划之前，其实第一次想到的会是递归处理，不过现在会了，还是动态规划香哈哈哈，在这里我仅仅说一下递归解题思路。\n我们从 [0, 0] 坐标出发，最短路径是 f[0][0] + min(f[0][1], f[1][0]) ，针对 f[0][1] 和 f[1][0] 继续进行递归处理。这里需要注意的一点是，我们在计算 f0 和 f[1][0] 的时候，会重复计算 f[0][1]，所以我们使用一个 min[i][j] 数组保存 [i, j] 坐标到右下角的最小路径，这样就避免的重复计算。\n来源\n最小路径和 | 力扣（LeetCode）最小路径和 | 题解（LeetCode）\n\n\n","categories":["LeetCode"],"tags":["Java","LeetCode","学习笔记","数组","递归","记忆化","动态规划","深度优先搜索"]},{"title":"除数博弈","url":"/blog/2020/07/24/divisor-game/","content":"\n题目描述爱丽丝和鲍勃一起玩游戏，他们轮流行动。爱丽丝先手开局。最初，黑板上有一个数字 N 。在每个玩家的回合，玩家需要执行以下操作：\n\n选出任一 x，满足 0 &lt; x &lt; N 且 N % x == 0 。\n用 N - x 替换黑板上的数字 N 。\n\n如果玩家无法执行这些操作，就会输掉游戏。只有在爱丽丝在游戏中取得胜利时才返回 True，否则返回 False。假设两个玩家都以最佳状态参与游戏。\n示例 1：\n\n输入：2输出：true解释：爱丽丝选择 1，鲍勃无法进行操作。\n\n示例 2：\n\n输入：3输出：false解释：爱丽丝选择 1，鲍勃也选择 1，然后爱丽丝无法进行操作。\n\n提示：\n\n1 &lt;= N &lt;= 1000\n\n\n\n归纳法博弈类的问题常常让我们摸不着头脑。当我们没有解题思路的时候，不妨试着写几项试试：\n\nN = 1 的时候，区间 (0, 1) 中没有整数是 n 的因数，所以此时 Alice 败。\nN = 2 的时候，Alice 只能拿 1，N 变成 1，Bob 无法继续操作，故 Alice 胜。\nN = 3 的时候，Alice 只能拿 1，N 变成 2，根据 N = 2 的结论，我们知道此时 Bob 会获胜，Alice 败。\nN = 4 的时候，Alice 能拿 1 或 2，如果 Alice 拿 1，根据 N = 3 的结论，Bob 会失败，Alice 会获胜。\nN = 5 的时候，Alice 只能拿 1，根据 N = 4 的结论，Alice 会失败。\n……\n\n写到这里，也许你有了一些猜想。没关系，请大胆地猜想，在这种情况下大胆地猜想是 AC 的第一步。也许你会发现这样一个现象：N 为奇数的时候 Alice（先手）必败，N 为偶数的时候 Alice 必胜。 这个猜想是否正确呢？下面我们来想办法证明它。\n证明\n\nN = 1 和 N = 2 时结论成立。\nN &gt; 2 时，假设 N ≤ k 时该结论成立，则 N = k + 1 时：\n\n\n如果 k 为偶数，则 k + 1 为奇数，x 是 k + 1 的因数，只可能是奇数，而奇数减去奇数等于偶数，且 k + 1 - x ≤ k，故轮到 Bob 的时候都是偶数。而根据我们的猜想假设 N ≤ k 的时候偶数的时候先手必胜，故此时无论 Alice 拿走什么，Bob 都会处于必胜态，所以 Alice 处于必败态。\n如果 k 为奇数，则 k + 1 为偶数，x 可以是奇数也可以是偶数，若 Alice 减去一个奇数，那么 k + 1 - x 是一个小于等于 k 的奇数，此时 Bob 占有它，处于必败态，则 Alice 处于必胜态。\n\n综上所述，这个猜想是正确的。\nbool divisorGame(int N) &#123;    return N % 2 == 0;&#125;\n\n复杂度分析\n时间复杂度：Ο(1)。\n空间复杂度：O(1)。\n\n递推上述方法中，我们写出了前面几项的答案，在这个过程中我们发现，Alice 处在 N = k 的状态时，他（她）做一步操作，必然使得 Bob 处于 N = m (m &lt; k) 的状态。因此我们只要看是否存在一个 m 是必败的状态，那么 Alice 直接执行对应的操作让当前的数字变成 m，Alice 就必胜了，如果没有任何一个是必败的状态的话，说明 Alice 无论怎么进行操作，最后都会让 Bob 处于必胜的状态，此时 Alice 是必败的。\n结合以上我们定义 f[i] 表示当前数字 i 的时候先手是处于必胜态还是必败态，true 表示先手必胜，false 表示先手必败，从前往后递推，根据我们上文的分析，枚举 i 在 (0, i) 中 i 的因数 j，看是否存在 f[i-j] 为必败态即可。\npublic boolean divisorGame(int N) &#123;    boolean[] dp = new boolean[N + 2];    dp[1] = false;    dp[2] = true;    for (int i = 3; i &lt;= N; i++) &#123;        for (int j = 1; j &lt; i; j++) &#123;            if ((i % j == 0) &amp;&amp; !dp[i - j]) &#123;                dp[i] = true;                break;            &#125;        &#125;    &#125;    return dp[N];&#125;\n\n复杂度分析\n时间复杂度：Ο(n²)，递推的时候一共有 n 个状态要计算，每个状态需要 O(n) 的时间枚举因数。\n空间复杂度：O(n)，我们需要 O(n) 的空间存储递推数组 f 的值。\n\n来源\n除数博弈 | 力扣（LeetCode）除数博弈 | 题解（LeetCode）\n\n\n","categories":["LeetCode"],"tags":["Java","LeetCode","学习笔记","数学归纳法"]},{"title":"判断子序列","url":"/blog/2020/07/27/is-subsequence/","content":"\n题目描述给定字符串 s 和 t ，判断 s 是否为 t 的子序列。你可以认为 s 和 t 中仅包含英文小写字母。字符串 t 可能会很长（长度 ≈ 500,000），而 s 是个短字符串（长度 &lt;= 100）。\n字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，”ace”是”abcde”的一个子序列，而”aec”不是）。\n示例 1:\n\ns = “abc”, t = “ahbgdc”返回 true.\n\n示例 2:\n\ns = “axc”, t = “ahbgdc”返回 false.\n\n\n\n双指针我们使用双指针i和j分别指向短的字符串和长的字符串，移动规则是，当s[i] == t[j]的时候，同时移动i和j，否则，我们不断的移动j指针，直到找到s[i] == t[j]，然后同时移动i和j，直到遍历完字符串s。最后，如果s是t的子串，那么j一定小于t.length。\npublic boolean isSubsequence(String s, String t) &#123;    char[] sArr = s.toCharArray();    char[] tArr = t.toCharArray();    int i = 0, j = 0;    for (; i &lt; sArr.length; i++, j++) &#123;        while (j &lt; tArr.length &amp;&amp; sArr[i] != tArr[j]) &#123;            j++;        &#125;    &#125;    // 题目中在for循环中同时操作i++和j++，所以此处是小于等于的关系    return j &lt;= tArr.length;&#125;\n\n复杂度分析\n时间复杂度：O(n + m)，其中 n 为 s 的长度，m 为 t 的长度。每次无论是匹配成功还是失败，都有至少一个指针发生右移，两指针能够位移的总距离为 n + m。\n空间复杂度：O(1)。\n\n来源\n判断子序列 | 力扣（LeetCode）判断子序列 | 题解（LeetCode）\n\n\n","categories":["LeetCode"],"tags":["Java","LeetCode","学习笔记","字符串","指针","双指针"]},{"title":"有效的括号","url":"/blog/2020/07/27/valid-parentheses/","content":"\n题目描述给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。有效字符串需满足：\n\n左括号必须用相同类型的右括号闭合。\n左括号必须以正确的顺序闭合。\n\n注意： 空字符串可被认为是有效字符串。\n示例 1:\n\n输入: “()”输出: true\n\n示例 2:\n\n输入: “()[]{}”输出: true\n\n示例 3:\n\n输入: “(]”输出: false\n\n示例 4:\n\n输入: “([)]”输出: false\n\n示例 5:\n\n输入: “{[]}”输出: true\n\n\n\n题解括号匹配是典型的代码分析问题，我们遍历字符串，每次处理一个括号，使用栈来保存这个括号。同时我们使用一个map来保存三种括号的开括号和闭括号。每次处理当前括号的时候，我们判断当前栈顶的元素是否是此括号对应的开括号，是的话，我们将弹出栈顶元素。否则我们将当前括号入栈。最后，如果栈的元素为空，那么可知此字符串是有效的字符串。\npublic boolean isValid(String s) &#123;    if (s == null || s.length() == 0) &#123;        return true;    &#125;    Stack&lt;Character&gt; parenthesesStack = new Stack&lt;&gt;();    HashMap&lt;Character, Character&gt; parenthesesMap = new HashMap&lt;&gt;();    parenthesesMap.put(&#x27;(&#x27;, &#x27;)&#x27;);    parenthesesMap.put(&#x27;[&#x27;, &#x27;]&#x27;);    parenthesesMap.put(&#x27;&#123;&#x27;, &#x27;&#125;&#x27;);    for (char parentheses : s.toCharArray()) &#123;        if (!parenthesesStack.isEmpty() &amp;&amp; Character.valueOf(parentheses)                .equals(parenthesesMap.get(parenthesesStack.peek()))) &#123;            parenthesesStack.pop();        &#125; else &#123;            parenthesesStack.push(parentheses);        &#125;    &#125;    return parenthesesStack.isEmpty();&#125;\n\n复杂度分析\n时间复杂度：O(n)，因为我们一次只遍历给定的字符串中的一个字符并在栈上进行 O(1) 的推入和弹出操作。\n空间复杂度：O(n)，当我们将所有的开括号都推到栈上时以及在最糟糕的情况下，我们最终要把所有括号推到栈上。例如 ((((((((((。\n\n来源\n有效的括号 | 力扣（LeetCode）有效的括号 | 题解（LeetCode）\n\n\n","categories":["LeetCode"],"tags":["Java","LeetCode","学习笔记","字符串","栈"]},{"title":"二叉树的最大深度","url":"/blog/2020/07/28/maximum-depth-of-binary-tree/","content":"\n题目描述给定一个二叉树，找出其最大深度。二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。\n说明: 叶子节点是指没有子节点的节点。\n示例：\n给定二叉树 [3, 9, 20, null, null, 15, 7]，    3   / \\  9  20    /  \\   15   7返回它的最大深度 3 。\n\n\n\n深度优先搜索我们可以发现，给定一个二叉树t，它的最大深度是左子树l和右子树r的最大深度中的较大值加一，针对左子树和右子树，同样进行递归处理。递归的终止条件是访问到空节点，此时返回深度0。\npublic int maxDepth(TreeNode root) &#123;    if (root == null) &#123;        return 0;    &#125;    return Math.max(maxDepth(root.left), maxDepth(root.right)) + 1;&#125;public class TreeNode &#123;    int val;    TreeNode left;    TreeNode right;    TreeNode(int x) &#123;        val = x;    &#125;&#125;\n\n复杂度分析\n时间复杂度：O(n)，其中 n 为二叉树节点的个数。每个节点在递归中只被遍历一次。\n空间复杂度：O(h)，其中 h 表示二叉树的高度。递归函数需要栈空间，而栈空间取决于递归的深度，因此空间复杂度等价于二叉树的高度。\n\n广度优先搜索我们也可以用「广度优先搜索」的方法来解决这道题目，但我们需要对其进行一些修改，此时我们广度优先搜索的队列里存放的是「当前层的所有节点」。每次拓展下一层的时候，不同于广度优先搜索的每次只从队列里拿出一个节点，我们需要将队列里的所有节点都拿出来进行拓展，这样能保证每次拓展完的时候队列里存放的是当前层的所有节点，即我们是一层一层地进行拓展，最后我们用一个变量 ans 来维护拓展的次数，该二叉树的最大深度即为 ans。\npublic int maxDepth(TreeNode root) &#123;    if (root == null) &#123;        return 0;    &#125;    Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;();    queue.offer(root);    int ans = 0;    while (!queue.isEmpty()) &#123;        int size = queue.size();        while (size &gt; 0) &#123;            TreeNode node = queue.poll();            if (node.left != null) &#123;                queue.offer(node.left);            &#125;            if (node.right != null) &#123;                queue.offer(node.right);            &#125;            size--;        &#125;        ans++;    &#125;    return ans;&#125;public class TreeNode &#123;    int val;    TreeNode left;    TreeNode right;    TreeNode(int x) &#123;        val = x;    &#125;&#125;\n\n复杂度分析\n时间复杂度：O(n)，其中 n 为二叉树节点的个数。每个节点只会被访问一次。\n空间复杂度：O(n)，此方法空间的消耗取决于队列存储的元素数量，其在最坏情况下会达到 O(n)。\n\n来源\n二叉树的最大深度 | 力扣（LeetCode）二叉树的最大深度 | 题解（LeetCode）\n\n\n","categories":["LeetCode"],"tags":["Java","LeetCode","学习笔记","队列","递归","树","二叉树","深度优先搜索","广度优先搜索"]},{"title":"扫雷游戏","url":"/blog/2020/07/28/minesweeper/","content":"\n題目描述让我们一起来玩扫雷游戏！\n给定一个代表游戏板的二维字符矩阵。 ‘M’ 代表一个未挖出的地雷，’E’ 代表一个未挖出的空方块，’B’ 代表没有相邻（上，下，左，右，和所有4个对角线）地雷的已挖出的空白方块，数字（’1’ 到 ‘8’）表示有多少地雷与这块已挖出的方块相邻，’X’ 则表示一个已挖出的地雷。现在给出在所有未挖出的方块中（’M’或者’E’）的下一个点击位置（行和列索引），根据以下规则，返回相应位置被点击后对应的面板：\n\n如果一个地雷（’M’）被挖出，游戏就结束了- 把它改为 ‘X’。\n如果一个没有相邻地雷的空方块（’E’）被挖出，修改它为（’B’），并且所有和其相邻的未挖出方块都应该被递归地揭露。\n如果一个至少与一个地雷相邻的空方块（’E’）被挖出，修改它为数字（’1’到’8’），表示相邻地雷的数量。\n如果在此次点击中，若无更多方块可被揭露，则返回面板。\n\n示例 1：\n输入:[[&#x27;E&#x27;, &#x27;E&#x27;, &#x27;E&#x27;, &#x27;E&#x27;, &#x27;E&#x27;], [&#x27;E&#x27;, &#x27;E&#x27;, &#x27;M&#x27;, &#x27;E&#x27;, &#x27;E&#x27;], [&#x27;E&#x27;, &#x27;E&#x27;, &#x27;E&#x27;, &#x27;E&#x27;, &#x27;E&#x27;], [&#x27;E&#x27;, &#x27;E&#x27;, &#x27;E&#x27;, &#x27;E&#x27;, &#x27;E&#x27;]]Click : [3,0]输出:[[&#x27;B&#x27;, &#x27;1&#x27;, &#x27;E&#x27;, &#x27;1&#x27;, &#x27;B&#x27;], [&#x27;B&#x27;, &#x27;1&#x27;, &#x27;M&#x27;, &#x27;1&#x27;, &#x27;B&#x27;], [&#x27;B&#x27;, &#x27;1&#x27;, &#x27;1&#x27;, &#x27;1&#x27;, &#x27;B&#x27;], [&#x27;B&#x27;, &#x27;B&#x27;, &#x27;B&#x27;, &#x27;B&#x27;, &#x27;B&#x27;]]\n\n解释:\n\n\n示例 2：\n输入:[[&#x27;B&#x27;, &#x27;1&#x27;, &#x27;E&#x27;, &#x27;1&#x27;, &#x27;B&#x27;], [&#x27;B&#x27;, &#x27;1&#x27;, &#x27;M&#x27;, &#x27;1&#x27;, &#x27;B&#x27;], [&#x27;B&#x27;, &#x27;1&#x27;, &#x27;1&#x27;, &#x27;1&#x27;, &#x27;B&#x27;], [&#x27;B&#x27;, &#x27;B&#x27;, &#x27;B&#x27;, &#x27;B&#x27;, &#x27;B&#x27;]]Click : [1,2]输出:[[&#x27;B&#x27;, &#x27;1&#x27;, &#x27;E&#x27;, &#x27;1&#x27;, &#x27;B&#x27;], [&#x27;B&#x27;, &#x27;1&#x27;, &#x27;X&#x27;, &#x27;1&#x27;, &#x27;B&#x27;], [&#x27;B&#x27;, &#x27;1&#x27;, &#x27;1&#x27;, &#x27;1&#x27;, &#x27;B&#x27;], [&#x27;B&#x27;, &#x27;B&#x27;, &#x27;B&#x27;, &#x27;B&#x27;, &#x27;B&#x27;]]\n\n解释:\n\n\n注意：\n\n输入矩阵的宽和高的范围为 [1, 50]。\n点击的位置只能是未被挖出的方块 (‘M’ 或者 ‘E’)，这也意味着面板至少包含一个可点击的方块。\n输入面板不会是游戏结束的状态（即有地雷已被挖出）。\n简单起见，未提及的规则在这个问题中可被忽略。例如，当游戏结束时你不需要挖出所有地雷，考虑所有你可能赢得游戏或标记方块的情况。\n\n\n\n题解根据题意，我们点击某个方块后，如果是地雷 M，则直接修改为 X 返回。否则我们计算以当前点击的方块为中心的九宫格内地雷的数量，如果没有地雷，则我们将当前节点标记为 B 并递归处理当前节点九宫格内的其他节点。否则我们将当前节点标记为周围地雷的数量，并结束递归。\npublic char[][] updateBoard(char[][] board, int[] click) &#123;    if (board[click[0]][click[1]] == &#x27;M&#x27;) &#123;        board[click[0]][click[1]] = &#x27;X&#x27;;        return board;    &#125; else &#123;        checkBoard(board, click[0], click[1]);    &#125;    return board;&#125;private void checkBoard(char[][] board, int x, int y) &#123;    int row = board.length;    int col = board[0].length;    if (board[x][y] != &#x27;M&#x27; &amp;&amp; board[x][y] != &#x27;E&#x27;) &#123;        return;    &#125;    board[x][y] = 0;    // 计算点击节点的九宫格内地雷数量    for (int i = x - 1; i &lt;= x + 1; i++) &#123;        for (int j = y - 1; j &lt;= y + 1; j++) &#123;            if (i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; i &lt; row &amp;&amp; j &lt; col) &#123;                board[x][y] += (board[i][j] == &#x27;M&#x27; ? 1 : 0);            &#125;        &#125;    &#125;    // 如果点击节点九宫格内没有地雷，则递归处理九宫格内其他的节点    if (board[x][y] == 0) &#123;        board[x][y] = &#x27;B&#x27;;        for (int i = x - 1; i &lt;= x + 1; i++) &#123;            for (int j = y - 1; j &lt;= y + 1; j++) &#123;                if (i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; i &lt; row &amp;&amp; j &lt; col) &#123;                    checkBoard(board, i, j);                &#125;            &#125;        &#125;    &#125; else &#123;        board[x][y] += &#x27;0&#x27;;    &#125;&#125;\n\n来源\n扫雷游戏 | 力扣（LeetCode）扫雷游戏 | 题解（LeetCode）\n\n\n","categories":["LeetCode"],"tags":["Java","LeetCode","学习笔记","数组","递归","矩阵","深度优先搜索"]},{"title":"黄金矿工","url":"/blog/2020/07/30/path-with-maximum-gold/","content":"\n题目描述你要开发一座金矿，地质勘测学家已经探明了这座金矿中的资源分布，并用大小为 m * n 的网格 grid 进行了标注。每个单元格中的整数就表示这一单元格中的黄金数量；如果该单元格是空的，那么就是 0。为了使收益最大化，矿工需要按以下规则来开采黄金：\n\n每当矿工进入一个单元，就会收集该单元格中的所有黄金。\n矿工每次可以从当前位置向上下左右四个方向走。\n每个单元格只能被开采（进入）一次。\n不得开采（进入）黄金数目为 0 的单元格。\n矿工可以从网格中任意一个有黄金的单元格出发或者是停止。\n\n示例 1：\n输入：grid = [[0, 6, 0], [5, 8, 7], [0, 9, 0]]输出：24解释：[[0, 6, 0], [5, 8, 7], [0, 9, 0]]一种收集最多黄金的路线是：9 -&gt; 8 -&gt; 7。\n\n示例 2：\n输入：grid = [[1, 0, 7], [2, 0, 6], [3, 4, 5], [0, 3, 0], [9, 0, 20]]输出：28解释：[[1, 0, 7], [2, 0, 6], [3, 4, 5], [0, 3, 0], [9, 0, 20]]一种收集最多黄金的路线是：1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6 -&gt; 7。\n\n提示：\n\n1 &lt;= grid.length, grid[i].length &lt;= 15\n0 &lt;= grid[i][j] &lt;= 100\n最多 25 个单元格中有黄金。\n\n\n\n题解首先矿工可以从网格中任意一个有黄金的单元格出发或者是停止。于是我们将循环遍历网格全部的有黄金的点，作为起点。接下来，我们进行递归处理，每次递归的时候记录 gold 的值，传到下一次递归中，同时有一个全局变量 max 记录最大的黄金数，每次递归的总黄金数就是 gold + grid[i][j]。递归终止的时候，我们用 gold 值来更新 max 值。现在的问题是，我们如何处理递归的终止条件。这里，我们同时使用回溯算法，定义 boolean 型的二维数组 visit，每次递归的时候，我们将当前节点置为 true 表示当前节点已经访问，递归回溯的时候，我们置为 false，表示当前节点没有被访问。于是我们得到递归的终止条件如下：\n\ni &lt; 0 || i &gt;= grid.length\nj &lt; 0 || j &gt;= grid[0].length\ngrid[i][j] == 0\nvisit[i][j] == true\n\n所有节点为起点，进行深度优先搜索，最终的 max 值就是最大黄金数。\nint max = 0;public int getMaximumGold(int[][] grid) &#123;    boolean[][] visit = new boolean[grid.length][grid[0].length];    for (int i = 0; i &lt; grid.length; i++) &#123;        for (int j = 0; j &lt; grid[0].length; j++) &#123;            if (grid[i][j] &gt; 0) &#123;                dfsGetMaximumGold(grid, i, j, 0, visit);            &#125;        &#125;    &#125;    return max;&#125;public void dfsGetMaximumGold(int[][] grid, int i, int j, int gold, boolean[][] visit) &#123;    if ((i &lt; 0 || i &gt;= grid.length) || (j &lt; 0 || j &gt;= grid[0].length) || grid[i][j] == 0 || visit[i][j]) &#123;        max = Math.max(max, gold);        return;    &#125;    gold += grid[i][j];    visit[i][j] = true;    dfsGetMaximumGold(grid, i + 1, j, gold, visit);    dfsGetMaximumGold(grid, i - 1, j, gold, visit);    dfsGetMaximumGold(grid, i, j + 1, gold, visit);    dfsGetMaximumGold(grid, i, j - 1, gold, visit);    visit[i][j] = false;&#125;\n\n来源\n黄金矿工 | 力扣（LeetCode）黄金矿工 | 题解（LeetCode）\n\n\n","categories":["LeetCode"],"tags":["Java","LeetCode","学习笔记","数组","递归","回溯算法","深度优先搜索"]},{"title":"字符串相加","url":"/blog/2020/08/03/add-strings/","content":"\n题目描述给定两个字符串形式的非负整数 num1 和 num2 ，计算它们的和。\n提示：\n\nnum1 和 num2 的长度都小于 5100\nnum1 和 num2 都只包含数字 0-9\nnum1 和 num2 都不包含任何前导零\n你不能使用任何內建 BigInteger 库，也不能直接将输入的字符串转换为整数形式\n\n\n\n题解我们只需要对两个大整数模拟「竖式加法」的过程。竖式加法就是我们平常学习生活中常用地对两个整数相加的方法，回想一下我们在纸上对两个整数相加的操作，是不是如下图将相同数位对齐，从低到高逐位相加，如果当前位和超过 10，则向高位进一位？因此我们只要将这个过程用代码写出来即可。我们使用两个变量分别指向两个数的末尾，进行加法操作，同时使用 carry 保存进位，若两个字符串不一样长，我们两个字符串遍历完成后，要继续遍历未计算的字符串，最后，别忘了，如果进位是 1 的话，要把进位加到最终的结果中。\n\n\npublic String addStrings(String num1, String num2) &#123;    int index1 = num1.length() - 1;    int index2 = num2.length() - 1;    StringBuilder res = new StringBuilder();    int carry = 0;    while (index1 &gt;=0 &amp;&amp; index2 &gt;= 0) &#123;        int n1 = num1.charAt(index1) - &#x27;0&#x27;;        int n2 = num2.charAt(index2) - &#x27;0&#x27;;        carry = addNum(n1, n2, carry, res);        index1--;        index2--;    &#125;    while (index1 &gt;= 0) &#123;        int n1 = num1.charAt(index1) - &#x27;0&#x27;;        carry = addNum(n1, 0, carry, res);        index1--;    &#125;    while (index2 &gt;= 0) &#123;        int n2 = num2.charAt(index2) - &#x27;0&#x27;;        carry = addNum(0, n2, carry, res);        index2--;    &#125;    if (carry &gt; 0) &#123;        res.append(carry);    &#125;    return res.reverse().toString();&#125;public int addNum(int n1, int n2, int carry, StringBuilder res) &#123;    int sum = n1 + n2 + carry;    res.append(sum % 10);    return sum / 10;&#125;\n\n这里，我们其实不需要这么长的代码，判断最后哪个字符串更长，针对短的字符串，我们进行补 0 操作即可。也不需要判断是否有进位，最后还要记得加上去。我们可以简化代码如下。\npublic String addStrings(String num1, String num2) &#123;    int index1 = num1.length() - 1;    int index2 = num2.length() - 1;    int carry = 0;    StringBuilder res = new StringBuilder();    while (index1 &gt;= 0 || index2 &gt;= 0 || carry != 0) &#123;        int x = index1 &gt;= 0 ? num1.charAt(index1) - &#x27;0&#x27; : 0;        int y = index2 &gt;= 0 ? num2.charAt(index2) - &#x27;0&#x27; : 0;        int sum = x + y + carry;        res.append(sum % 10);        carry = sum / 10;        index1--;        index2--;    &#125;    return res.reverse().toString();&#125;\n\n复杂度分析\n时间复杂度：Ο(max(m, n))，其中 m 和 n 分别是两个字符串的长度。竖式加法的次数取决于较大数的位数。\n空间复杂度：O(n)。除答案外我们只需要常数空间存放若干的变量。但是解法中使用到了 StringBuilder，空间复杂度为 O(n)。\n\n来源\n字符串相加 | 力扣（LeetCode）字符串相加 | 题解（LeetCode）\n\n\n","categories":["LeetCode"],"tags":["Java","LeetCode","学习笔记","字符串"]},{"title":"魔术索引","url":"/blog/2020/08/04/magic-index-lcci/","content":"\n题目描述魔术索引。 在数组 A[0…n-1] 中，有所谓的魔术索引，满足条件 A[i] = i 。给定一个有序整数数组，编写一种方法找出魔术索引，若有的话，在数组 A 中找出一个魔术索引，如果没有，则返回 -1。若有多个魔术索引，返回索引值最小的一个。\n示例1:\n\n输入: nums = [0, 2, 3, 4, 5]输出: 0说明: 0 下标的元素为 0\n\n示例2:\n\n输入: nums = [1, 1, 1]输出: 1\n\n说明:\n\nnums 长度在 [1, 1000000] 之间\n\n\n\n遍历最简单的方法，我们只要从头遍历整个数组，找到最小的 A[i] = i 返回即可。\npublic int findMagicIndex(int[] nums) &#123;    for (int i = 0; i &lt; nums.length; i++) &#123;        if (nums[i] == i) &#123;            return i;        &#125;    &#125;    return -1;&#125;\n\n复杂度分析\n时间复杂度：O(n)，其中 n 为数组的长度。\n空间复杂度：O(1)。\n\n二分查找剪枝本方法我们是进行一定程度的优化，在一些情况下会达到较优的时间复杂度，在最差情况下仍会退化成线性的时间复杂度。现在我们假设，题目中的魔术索引仅有一个，我们假设这个答案为 i，那么意味着 [0…i−1] 的值均小于自身的下标，[i+1…n−1] 的值均大于自身的下标【不理解的同学用反证法即可证明】。那么我们只要使用二分法查找数组中的元素，在 O(log n) 的时间内找到答案 A[i] = i 所在的下标。但是题目中魔术索引可能有多个，我们就需要对二分查找做一些处理。针对二分查找做一下剪枝，策略如下：\n\n每次我们选择数组中间的元素，如果当前中间元素左半部分有满足条件的答案，那么这个位置往后的右半边元素我们都不再考虑，只要寻找左半部分满足条件的答案即可。\n接下来我们继续查看左半部分是否有满足条件的答案，否则如果没有的话我们仍然需要在右半边寻找，使用的策略同上。\n\n显然，此剪枝策略在 [−1, 0, 1, 2, 4] 这种答案为数组的最后一个元素的情况下会退化成线性的时间复杂度，但是在一些情况下会有不错的表现。\npublic int findMagicIndex(int[] nums) &#123;    return findMagicIndex(nums, 0, nums.length - 1);&#125;public int findMagicIndex(int[] nums, int start, int end) &#123;    if (start == end) &#123;        return nums[start] == start ? start : -1;    &#125;    int mid = start + ((end - start) &gt;&gt; 1);    int index = findMagicIndex(nums, start, mid);    if (index != -1) &#123;        return index;    &#125;    return findMagicIndex(nums, mid + 1, end);&#125;\n\n复杂度分析\n时间复杂度：最坏情况下会达到 O(n) 的时间复杂度，其中 n 为数组的长度。\n空间复杂度：递归函数的空间取决于调用的栈深度，而最坏情况下我们会递归 n 层，即栈深度为 O(n)，因此空间复杂度最坏情况下为 O(n)。\n\n来源\n魔术索引 | 力扣（LeetCode）魔术索引 | 题解（LeetCode）\n\n\n","categories":["LeetCode"],"tags":["Java","LeetCode","学习笔记","数组","递归","程序员面试金典","二分查找"]},{"title":"相同的树","url":"/blog/2020/08/07/same-tree/","content":"\n题目描述给定两个二叉树，编写一个函数来检验它们是否相同。如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。\n示例 1:\n输入:    1         1   / \\       / \\  2   3     2   3[1, 2, 3], [1, 2, 3]输出: true\n\n示例 2:\n输入:   1          1  /           \\ 2             2[1, 2],  [1, null, 2]输出: false\n\n示例 3:\n输入:    1         1   / \\       / \\  2   1     1   2[1, 2, 1], [1, 1, 2]输出: false\n\n\n\n题解此题是另外一道题的一个子解题步骤：另一个树的子树，根据题目描述，我们可以使用深度优先搜索，首先判断如果两个二叉树都为空，则两个二叉树相同。如果两个二叉树中有且只有一个为空，则两个二叉树一定不相同【这也是递归的终止条件】。然后判断两个树的根节点值是否相同，接下来递归的方式处理两个树的左子树和右子树，如果都相同，则为相同的树。\npublic boolean isSameTree(TreeNode p, TreeNode q) &#123;    if (p == null || q == null) &#123;        return p == null &amp;&amp; q == null;    &#125; else &#123;        return p.val == q.val &amp;&amp; isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right);    &#125;&#125;public class TreeNode &#123;    int val;    TreeNode left;    TreeNode right;    TreeNode() &#123;    &#125;    TreeNode(int val) &#123;        this.val = val;    &#125;    TreeNode(int val, TreeNode left, TreeNode right) &#123;        this.val = val;        this.left = left;        this.right = right;    &#125;&#125;\n\n复杂度分析\n时间复杂度：O(min(m, n))，其中 m 和 n 分别是两个二叉树的节点数。对两个二叉树同时进行深度优先搜索，只有当两个二叉树中的对应节点都不为空时才会访问到该节点，因此被访问到的节点数不会超过较小的二叉树的节点数。\n空间复杂度：O(min(m, n))，其中 m 和 n 分别是两个二叉树的节点数。空间复杂度取决于递归调用的层数，递归调用的层数不会超过较小的二叉树的最大高度，最坏情况下，二叉树的高度等于节点数。\n\n来源\n相同的树 | 力扣（LeetCode）相同的树 | 题解（LeetCode）\n\n\n","categories":["LeetCode"],"tags":["Java","LeetCode","学习笔记","递归","树","二叉树","深度优先搜索"]},{"title":"课程表","url":"/blog/2020/08/05/course-schedule/","content":"\n题目描述你这个学期必须选修 numCourse 门课程，记为 0 到 numCourse - 1 。在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们：[0, 1]。给定课程总量以及它们的先决条件，请你判断是否可能完成所有课程的学习？\n示例 1:\n\n输入: 2, [[1, 0]]输出: true解释: 总共有 2 门课程。学习课程 1 之前，你需要完成课程 0。所以这是可能的。\n\n示例 2:\n\n输入: 2, [[1, 0], [0, 1]]输出: false解释: 总共有 2 门课程。学习课程 1 之前，你需要先完成​课程 0；并且学习课程 0 之前，你还应先完成课程 1。这是不可能的。\n\n\n\n题解本题是一道经典的「拓扑排序」问题。给定一个包含 n 个节点的有向图 G，我们给出它的节点编号的一种排列，如果满足：\n\n对于图 G 中的任意一条有向边 (u, v)，u 在排列中都出现在 v 的前面。那么称该排列是图 G 的「拓扑排序」。\n\n根据上述的定义，我们可以得出两个结论：\n\n如果图 G 中存在环（即图 G 不是「有向无环图」），那么图 G 不存在拓扑排序。这是因为假设图中存在环 x₁，x₂，x₃，……xn，x₁，那么 x₁ 在排列中必须出现在 xn 的前面，但是 xn 同时也出现在 x₁ 前面，因此不存在一个满足要求的排列，也就不存在拓扑排序。\n如果图 G 是有向无环图，那么它的拓扑排序可能不止一种。举一个最极端的例子，如果图 G 值包含 n 个节点却没有任何边，那么任意一种编号的排列都可以作为拓扑排序。\n\n有了上述的简单分析，我们就可以将本题建模成一个求拓扑排序的问题了：\n\n我们将每一门课程看成一个节点；\n如果想要学习课程 A 之前必须完成课程 B，那么我们从 B 到 A 连接一条有向边。这样以来，在拓扑排序中，B 一定出现在 A 的前面。\n\n深度优先搜索对于图中的任意一个节点，它在搜索的过程中有三种状态，即：\n\n「未搜索」：我们还没有搜索到这个节点；\n「搜索中」：我们搜索过这个节点，但还没有回溯到该节点，即该节点还没有入栈，还有相邻的节点没有搜索完成）；\n「已完成」：我们搜索过并且回溯过这个节点，即该节点已经入栈，并且所有该节点的相邻节点都出现在栈的更底部的位置，满足拓扑排序的要求。\n\n通过上述的三种状态，我们就可以给出使用深度优先搜索得到拓扑排序的算法流程，在每一轮的搜索搜索开始时，我们任取一个「未搜索」的节点开始进行深度优先搜索。\n\n我们将当前搜索的节点 u 标记为「搜索中」，遍历该节点的每一个相邻节点 v：\n如果 v 为「未搜索」，那么我们开始搜索 v，待搜索完成回溯到 u；\n如果 v 为「搜索中」，那么我们就找到了图中的一个环，因此是不存在拓扑排序的；\n如果 v 为「已完成」，那么说明 v 已经在栈中了，而 u 还不在栈中，因此 u 无论何时入栈都不会影响到 (u, v) 之前的拓扑关系，以及不用进行任何操作。\n当 u 的所有相邻节点都为「已完成」时，我们将 u 放入栈中，并将其标记为「已完成」。\n\n在整个深度优先搜索的过程结束后，如果我们没有找到图中的环，那么栈中存储这所有的 n 个节点，从栈顶到栈底的顺序即为一种拓扑排序。\nList&lt;List&lt;Integer&gt;&gt; edges;int[] visited;boolean valid = true;public boolean canFinish(int numCourses, int[][] prerequisites) &#123;    edges = new ArrayList&lt;&gt;();    for (int i = 0; i &lt; numCourses; ++i) &#123;        edges.add(new ArrayList&lt;&gt;());    &#125;    visited = new int[numCourses];    for (int[] info : prerequisites) &#123;        edges.get(info[1]).add(info[0]);    &#125;    for (int i = 0; i &lt; numCourses &amp;&amp; valid; i++) &#123;        if (visited[i] == 0) &#123;            dfsCourse(i);        &#125;    &#125;    return valid;&#125;public void dfsCourse(int u) &#123;    visited[u] = 1;    for (int v : edges.get(u)) &#123;        if (visited[v] == 0) &#123;            dfsCourse(v);            if (!valid) &#123;                return;            &#125;        &#125; else if (visited[v] == 1) &#123;            valid = false;            return;        &#125;    &#125;    visited[u] = 2;&#125;\n\n复杂度分析\n时间复杂度: O(n + m)，其中 n 为课程数，m 为先修课程的要求数。这其实就是对图进行深度优先搜索的时间复杂度。\n空间复杂度: O(n + m)。题目中是以列表形式给出的先修课程关系，为了对图进行深度优先搜索，我们需要存储成邻接表的形式，空间复杂度为 O(n + m)。在深度优先搜索的过程中，我们需要最多 O(n) 的栈空间（递归）进行深度优先搜索，因此总空间复杂度为 O(n + m)。\n\n广度优先搜索拓扑排序也可以使用广度优先搜索实现。我们考虑拓扑排序中最前面的节点，该节点一定不会有任何入边，也就是它没有任何的先修课程要求。当我们将一个节点加入答案中后，我们就可以移除它的所有出边，代表着它的相邻节点少了一门先修课程的要求。如果某个相邻节点变成了「没有任何入边的节点」，那么就代表着这门课可以开始学习了。按照这样的流程，我们不断地将没有入边的节点加入答案，直到答案中包含所有的节点（得到了一种拓扑排序）或者不存在没有入边的节点（图中包含环）。\n我们使用一个队列来进行广度优先搜索。初始时，所有入度为 0 的节点都被放入队列中，它们就是可以作为拓扑排序最前面的节点，并且它们之间的相对顺序是无关紧要的。在广度优先搜索的每一步中，我们取出队首的节点 u：\n\n我们将 u 放入答案中；\n我们移除 u 的所有出边，也就是将 u 的所有相邻节点的入度减少 1。如果某个相邻节点 v 的入度变为 0，那么我们就将 v 放入队列中。\n\n在广度优先搜索的过程结束后。如果答案中包含了这 n 个节点，那么我们就找到了一种拓扑排序，否则说明图中存在环，也就不存在拓扑排序了。\npublic boolean canFinish(int numCourses, int[][] prerequisites) &#123;    List&lt;List&lt;Integer&gt;&gt; edges = new ArrayList&lt;&gt;();    int[] degree = new int[numCourses];    for (int i = 0; i &lt; numCourses; i++) &#123;        edges.add(new ArrayList&lt;&gt;());    &#125;    for (int[] courseRelation : prerequisites) &#123;        edges.get(courseRelation[1]).add(courseRelation[0]);        degree[courseRelation[0]]++;    &#125;    Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();    for (int i = 0; i &lt; degree.length; i++) &#123;        if (degree[i] == 0) &#123;            queue.offer(i);        &#125;    &#125;    int visited = 0;    while (!queue.isEmpty()) &#123;        visited++;        int beforeCourse = queue.poll();        for (int afterCourse : edges.get(beforeCourse)) &#123;            if (--degree[afterCourse] == 0) &#123;                queue.offer(afterCourse);            &#125;        &#125;    &#125;    return visited == numCourses;&#125;\n\n复杂度分析\n时间复杂度: O(n + m)，其中 n 为课程数，m 为先修课程的要求数。这其实就是对图进行广度优先搜索的时间复杂度。\n空间复杂度: O(n + m)。题目中是以列表形式给出的先修课程关系，为了对图进行广度优先搜索，我们需要存储成邻接表的形式，空间复杂度为 O(n + m)。在广度优先搜索的过程中，我们需要最多 O(n) 的队列空间（迭代）进行广度优先搜索。因此总空间复杂度为 O(n + m)。\n\n来源\n课程表 | 力扣（LeetCode）课程表 | 题解（LeetCode）\n\n\n","categories":["LeetCode"],"tags":["Java","LeetCode","学习笔记","数组","递归","回溯算法","深度优先搜索","广度优先搜索","图","拓扑排序"]},{"title":"计数二进制子串","url":"/blog/2020/08/10/count-binary-substrings/","content":"\n题目描述给定一个字符串 s，计算具有相同数量0和1的非空(连续)子字符串的数量，并且这些子字符串中的所有0和所有1都是组合在一起的。重复出现的子串要计算它们出现的次数。\n示例 1:\n\n输入: “00110011”输出: 6解释: 有 6 个子串具有相同数量的连续1和0：“0011”，“01”，“1100”，“10”，“0011” 和 “01”。请注意，一些重复出现的子串要计算它们出现的次数。另外，“00110011”不是有效的子串，因为所有的0（和1）没有组合在一起。\n\n示例 2:\n\n输入: “10101”输出: 4解释: 有4个子串：“10”，“01”，“10”，“01”，它们具有相同数量的连续1和0。\n\n注意：\n\ns.length 在1到50,000之间。s 只包含“0”或“1”字符。\n\n\n\n题解刚开始看到，可能没什么思路，但是我们仔细阅读题目，可以慢慢找到规律，首先针对一个满足题意的子串，假如是“000111”，那么满足题意的子串就同时有三种，“000111”和“0011”和“01”。可以发现，满足条件的子串，是以01为中心，左边不断补0，右边不断补1而成，每补一次，就多一个满足条件的子串。针对以10为中心同理。所以我们只要找到位置 i 的字符串和位置 i + 1 的字符串不等，并以此为中心左右扩展，左边的字符等于位置 i 的字符，右边的字符等于位置 i + 1 的字符。扩展一次，满足条件的子串次数就加一。遍历完全部字符后，就能得到答案。\npublic int countBinarySubstrings(String s) &#123;    char[] sArr = s.toCharArray();    int ans = 0;    for (int i = 0; i &lt; sArr.length - 1; i++) &#123;        if (sArr[i] != sArr[i + 1]) &#123;            int m = i;            int n = i + 1;            while (m &gt;= 0 &amp;&amp; n &lt; sArr.length &amp;&amp; sArr[m--] == sArr[i] &amp;&amp; sArr[n++] == sArr[i + 1]) &#123;                ans++;            &#125;        &#125;    &#125;    return ans;&#125;\n\n复杂度分析\n时间复杂度：O(n)。\n空间复杂度：O(n)。这里使用 s.toCharArray() 仅仅是为了效率，其实可以使用 s.charAt()，这样空间复杂度就是 O(1) 了。\n\n来源\n计数二进制子串 | 力扣（LeetCode）计数二进制子串 | 题解（LeetCode）\n\n\n","categories":["LeetCode"],"tags":["Java","LeetCode","学习笔记","字符串","双指针"]},{"title":"Hexo 博客和 NexT 主题版本升级","url":"/blog/2020/08/10/update-hexo-next/","content":"\n前言使用 Hexo 搭建博客也有4年之久，也是一直使用 NexT 主题，NexT 的简洁大方美观，特别符合我的审美。最近 Hexo 更新到 5.0.0 版本了，也是临时起意，想要更新下 Hexo 的版本，同时也一起更新下 NexT 主题，毕竟从4年前开始使用后，就再也没有升级过这两个的版本了。经常看到很多的同学都升级到新版本的 NexT 主题，界面展示和功能都有较大提升。NexT 主题不仅由之前的 5.1.x 更新至 7.x，主仓库也从 iissnan 名下迁移至 theme-next 组织。\n\n\nHexo 搭建个人博客在这里可能有些小伙伴是第一次接触 Hexo 和 NexT，先给大家一些参考文档，助力大家搭建一个属于自己的博客。\n\nHexo + Git 搭建免费的个人博客 | 笑话人生分类：Hexo | 笑话人生\n\n升级 HexoHexo 版本升级可以通过 npm 实现，相关命令如下：\n\n全局升级 hexo-cli\nnpm install hexo-cli -g\n\n检查系统中的插件是否有升级的，可以看到自己前面都安装了那些插件\nnpm install -g npm-checknpm-check\n\n升级系统中的插件\nnpm install -g npm-upgradenpm-upgrade\n\n更新全局包\nnpm update -g\n\n更新生产环境依赖包\nnpm update --save\n\n查看 Hexo 版本\n$ hexo vhexo: 5.0.2 # 升级到 5.0.2版本hexo-cli: 4.2.0os: Windows_NT 10.0.18362 win32 x64node: 14.7.0v8: 8.4.371.19-node.12uv: 1.38.1zlib: 1.2.11brotli: 1.0.7ares: 1.16.0modules: 83nghttp2: 1.41.0napi: 6llhttp: 2.0.4openssl: 1.1.1gcldr: 37.0icu: 67.1tz: 2020aunicode: 13.0\n\n查看 package.json\n&#123;  &quot;name&quot;: &quot;hexo-site&quot;,  &quot;version&quot;: &quot;0.0.0&quot;,  &quot;private&quot;: true,  &quot;hexo&quot;: &#123;    &quot;version&quot;: &quot;5.0.2&quot;  &#125;,  &quot;dependencies&quot;: &#123;    &quot;hexo&quot;: &quot;^5.0.2&quot;,    &quot;hexo-admin&quot;: &quot;^2.3.0&quot;,    &quot;hexo-deployer-git&quot;: &quot;^2.1.0&quot;,    &quot;hexo-generator-archive&quot;: &quot;^1.0.0&quot;,    &quot;hexo-generator-baidu-sitemap&quot;: &quot;^0.1.9&quot;,    &quot;hexo-generator-category&quot;: &quot;^1.0.0&quot;,    &quot;hexo-generator-feed&quot;: &quot;^3.0.0&quot;,    &quot;hexo-generator-index&quot;: &quot;^2.0.0&quot;,    &quot;hexo-generator-searchdb&quot;: &quot;^1.3.2&quot;,    &quot;hexo-generator-sitemap&quot;: &quot;^2.1.0&quot;,    &quot;hexo-generator-tag&quot;: &quot;^1.0.0&quot;,    &quot;hexo-renderer-ejs&quot;: &quot;^1.0.0&quot;,    &quot;hexo-renderer-marked&quot;: &quot;^3.0.0&quot;,    &quot;hexo-renderer-stylus&quot;: &quot;^1.1.0&quot;,    &quot;hexo-server&quot;: &quot;^2.0.0&quot;,    &quot;hexo-wordcount&quot;: &quot;^6.0.1&quot;,    &quot;particles.js&quot;: &quot;^2.0.0&quot;  &#125;&#125;\n\n\n\n升级 NexTNexT 主题升级从 v5 升级到 v7，跨度很大，但是官方提供了升级指导：从 NexT v5.1.x 更新，这里我把我的升级过程分享给大家，也是自己摸索的一种比较方便的升级方式，同时也方便后面继续进行升级。\n\n克隆新的仓库到任一异于 next 的目录（如 next-reloaded）：\n$ git clone https://github.com/cylong1016/hexo-theme-next themes/next-reloaded\n如此，你可以在不修改原有的 NexT v5.1.x 目录的同时使用 next-reloaded 目录中的新版本主题。这里，我是 Fork 了主仓库 theme-next/hexo-theme-next ，方便自己后续进行定制化修改，需要更新的时候，直接从主仓库拉取最新代码即可。\n\n在 Hexo 的主配置文件中设置主题：\ntheme: next-reloaded\n如此，你的 next-reloaded 主题将在生成站点时被加载。如果你遇到了任何错误、或只是不喜欢这一新版本，你可以随时切换回旧的 v5.1.x 版本。\n\n更新语言配置从 v6.0.3 版本起，zh-Hans 改名为 zh-CN：https://github.com/theme-next/hexo-theme-next/releases/tag/v6.0.3升级到 v6.0.3 及以后版本的用户，需要显式修改 Hexo 主配置文件 _config.yml 里的 language 配置，否则语言显示不正确。\n\n修改主题的 _config.yml 文件这里，我们不直接修改主题的_config.yml 文件，因为这样操作，后续 git pull 更新的时候，需要解决冲突问题，即使是手动下载 release 版本，也要手动合并 _config.yml 文件。所以我们选择 NexT 提供的方式2，创建自己单独的 next.yml 进行配置：\n\n数据文件\n\n\n我大概花了几个小时时间将之前全部的配置搞定了，大家可以参考：\n\nhttps://github.com/cylong1016/HexoBlog/blob/master/source/_data/next.yml\n\n\n\n最后至此花了半天时间，把 Hexo 和 NexT 主题全部升级完成，主要还是刚开始用的时候不太熟悉，后续也过了4年都没更新，所以这次花了比较多的时间，相信后面熟悉后，紧随版本，更新就会很快了。\n感谢升级博客Hexo版本和Next主题版本踩坑记录 | 叹逍遥的博客Hexo版本升级和Next主题升级之坑 | HJ_彼岸升级Hexo及NexT主题及添加评论和阅读数 | tangbao’s Blog\n\n","categories":["Hexo"],"tags":["Hexo","Next"]},{"title":"被围绕的区域","url":"/blog/2020/08/11/surrounded-regions/","content":"\n题目描述给定一个二维的矩阵，包含 ‘X’ 和 ‘O’（字母 O）。找到所有被 ‘X’ 围绕的区域，并将这些区域里所有的 ‘O’ 用 ‘X’ 填充。\n示例:\n输入：X X X XX O O XX X O XX O X X运行你的函数后，矩阵变为：X X X XX X X XX X X XX O X X\n解释: 被围绕的区间不会存在于边界上，换句话说，任何边界上的 ‘O’ 都不会被填充为 ‘X’。 任何不在边界上，或不与边界上的 ‘O’ 相连的 ‘O’ 最终都会被填充为 ‘X’。如果两个元素在水平或垂直方向相邻，则称它们是“相连”的。\n\n\n深度优先搜索遇到矩阵的问题，无非就是广度优先搜索或者深度优先搜索，我个人比较喜欢使用递归方式的深度优先搜索，也是比较容易理解的一种方式。本题要求将所有被字母 ‘X’ 包围的字母 ‘O’ 都变为字母 ‘X’ ，但很难判断哪些 ‘O’ 是被包围的，哪些 ‘O’ 不是被包围的。但是我们注意题目中的一句话：任何边界上的 ‘O’ 都不会被填充为 ‘X’。与边界上的 ‘O’ 相连的 ‘O’ 也都不会被填充为 ‘X’。根据这个思路，我们只要遍历矩阵的边界上的 ‘O’，以边界上的所有 ‘O’ 此为起点，找到所有与边界相连的字母 ‘O’，最后我们遍历整个矩阵，针对每个字母，如果这个字母被标记了，那么就保持原来的 ‘O’，如果没有被标记，那么就置为 ‘X’ 即可。\npublic void solve(char[][] board) &#123;    if (board == null || board.length == 0 || board[0].length == 0) &#123;        return;    &#125;    int rowLen = board.length;    int colLen = board[0].length;    int[][] direct = new int[][]&#123;&#123;0, 1&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;-1, 0&#125;&#125;;    int directIndex = 0;    int row = 0;    int col = 0;    boolean[][] visited = new boolean[rowLen][colLen];    // 顺时针遍历矩阵的边界    for (int i = 0; i &lt;= ((rowLen + colLen) &lt;&lt; 1) - 4; i++) &#123;        updateBoard(board, row, col, visited);        int nextRow = row + direct[directIndex][0];        int nextCol = col + direct[directIndex][1];        if (nextRow &lt; 0 || nextRow &gt;= rowLen || nextCol &lt; 0 || nextCol &gt;= colLen) &#123;            directIndex = (directIndex + 1) % 4;        &#125;        row += direct[directIndex][0];        col += direct[directIndex][1];    &#125;    // 针对每个字母，如果这个字母被标记了，那么就保持原来的 &#x27;O&#x27;，如果没有被标记，那么就置为 &#x27;X&#x27;。    for (int i = 0; i &lt; rowLen; i++) &#123;        for (int j = 0; j &lt; colLen; j++) &#123;            board[i][j] = visited[i][j] ? &#x27;O&#x27; : &#x27;X&#x27;;        &#125;    &#125;&#125;public void updateBoard(char[][] board, int x, int y, boolean[][] visited) &#123;    if (x &lt; 0 || y &lt; 0 || x &gt;= board.length || y &gt;= board[0].length || visited[x][y] || board[x][y] == &#x27;X&#x27;) &#123;        return;    &#125;    visited[x][y] = true;    updateBoard(board, x + 1, y, visited);    updateBoard(board, x, y + 1, visited);    updateBoard(board, x - 1, y, visited);    updateBoard(board, x, y - 1, visited);&#125;\n\n这里使用了 visited[x][y] 表示是否被标记，其实可以遍历到 ‘O’ 的时候，将此位置的字符改成任何其他字符，比如 ‘#’，之后遍历整个矩阵的时候，我们将其还原为 ‘O’ 即可，这样就不用使用额外的空间来标记了。另外遍历矩阵的边界，我使用的是从 board[0][0] 开始顺时针遍历矩阵的边界，其实不用这么麻烦，只要分别遍历矩阵的第一行，最后一行，第一列，最后一列即可，我这样做主要是为了复习下之前的一道题：\n\n顺时针打印矩阵 | 笑话人生\n\n复杂度分析\n时间复杂度：O(n × m)，其中 n 和 m 分别为矩阵的行数和列数。深度优先搜索过程中，每一个点至多只会被标记一次。\n空间复杂度：O(n × m)，其中 n 和 m 分别为矩阵的行数和列数。主要为深度优先搜索的栈的开销。\n\n来源\n被围绕的区域 | 力扣（LeetCode）被围绕的区域 | 题解（LeetCode）\n\n\n","categories":["LeetCode"],"tags":["Java","LeetCode","学习笔记","递归","回溯算法","矩阵","深度优先搜索","广度优先搜索"]},{"title":"字符串相乘","url":"/blog/2020/08/13/multiply-strings/","content":"\n题目描述给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。\n示例 1:\n\n输入: num1 = “2”, num2 = “3”输出: “6”\n\n示例 2:\n\n输入: num1 = “123”, num2 = “456”输出: “56088”\n\n说明：\n\nnum1 和 num2 的长度小于 110。\nnum1 和 num2 只包含数字 0-9。\nnum1 和 num2 均不以零开头，除非是数字 0 本身。\n不能使用任何标准库的大数类型（比如 BigInteger）或直接将输入转换为整数来处理。\n\n\n\n竖式乘法第一种方式比较简单，我们只要回想起我们平时计算乘法的方法。如果 num1 和 num2 之一是 0，则直接返回 0 即可。如果 num1 和 num2 都不是 0，则可以通过模拟「竖式乘法」的方法计算乘积。从右往左遍历乘数，将乘数的每一位与被乘数相乘得到对应的结果，再将每次得到的结果累加。需要注意的是，num2 除了最低位以外，其余的每一位的运算结果都需要补 0。\n\n\n关于字符串相加的代码，可以参考：字符串相加 | 笑话人生\npublic String multiply(String num1, String num2) &#123;    if (&quot;0&quot;.equals(num1) || &quot;0&quot;.equals(num2)) &#123;        return &quot;0&quot;;    &#125;    String result = &quot;0&quot;;    for (int i = num2.length() - 1; i &gt;= 0; i--) &#123;        int n1 = num2.charAt(i) - &#x27;0&#x27;;        int carry = 0;        StringBuilder tmpResult = new StringBuilder();        for (int j = num2.length() - 1; j &gt; i; j--) &#123;            tmpResult.append(0);        &#125;        for (int j = num1.length() - 1; j &gt;= 0; j--) &#123;            int n2 = num1.charAt(j) - &#x27;0&#x27;;            int tmp = n1 * n2 + carry;            carry = tmp / 10;            tmpResult.append(tmp % 10);        &#125;        if (carry &gt; 0) &#123;            tmpResult.append(carry);        &#125;        result = addString(result, tmpResult.reverse().toString());    &#125;    return result;&#125;public String addString(String num1, String num2) &#123;    int index1 = num1.length() - 1;    int index2 = num2.length() - 1;    int carry = 0;    StringBuilder res = new StringBuilder();    while (index1 &gt;= 0 || index2 &gt;= 0 || carry != 0) &#123;        int x = index1 &gt;= 0 ? num1.charAt(index1) - &#x27;0&#x27; : 0;        int y = index2 &gt;= 0 ? num2.charAt(index2) - &#x27;0&#x27; : 0;        int sum = x + y + carry;        res.append(sum % 10);        carry = sum / 10;        index1--;        index2--;    &#125;    return res.reverse().toString();&#125;\n\n复杂度分析\n时间复杂度：O(mn + n²)，其中 m 和 n 分别是 num1 和 num2 的长度。需要从右往左遍历 num2，对于 num2 的每一位，都要和 num1 的每一位计算乘积，因此计算乘积的总数是 mn，字符串相加操作共有 n 次，相加的字符串长度最长为 m + n，因此字符串相加的时间复杂度是O(mn + n²)。总时间复杂度是O(mn + n²)。\n空间复杂度：O(m + n)，其中 m 和 n 分别是 num1 和 num2 的长度。空间复杂度取决于存储中间状态的字符串，由于乘积的最大长度为 m + n，因此存储中间状态的字符串的长度不会超过 m + n。\n\n直接做乘积上一个方法从右往左遍历乘数，将乘数的每一位与被乘数相乘得到对应的结果，再将每次得到的结果累加，整个过程中涉及到较多字符串相加的操作。如果使用数组代替字符串存储结果，则可以减少对字符串的操作。令 m 和 n 分别表示 num1 和 num2 的长度，并且它们均不为 0，则 num1 和 num2 的乘积的长度为 m + n - 1 或 m + n。\n由于 num1 和 num2 的乘积的最大长度为 m + n，因此创建长度为 m + n 的数组 ansArr 用于存储乘积。对于任意 0 ≤ i &lt; m 和 0 ≤ j &lt; n，num1[i] × num2[j] 的结果位于 ansArr[i + j + 1]，如果 ansArr[i + j + 1] ≥ 10，则将进位部分加到ansArr[i + j]。最后，将数组 ansArr 转成字符串，如果最高位是 0 则舍弃最高位。\npublic String multiply(String num1, String num2) &#123;    if (&quot;0&quot;.equals(num1) || &quot;0&quot;.equals(num2)) &#123;        return &quot;0&quot;;    &#125;    int m = num1.length();    int n = num2.length();    int[] ansArr = new int[m + n];    for (int i = m - 1; i &gt;= 0; i--) &#123;        int x = num1.charAt(i) - &#x27;0&#x27;;        for (int j = n - 1; j &gt;= 0; j--) &#123;            int y = num2.charAt(j) - &#x27;0&#x27;;            ansArr[i + j + 1] += x * y;        &#125;    &#125;    for (int i = m + n - 1; i &gt; 0; i--) &#123;        ansArr[i - 1] += ansArr[i] / 10;        ansArr[i] %= 10;    &#125;    StringBuilder ans = new StringBuilder();    for (int i = ansArr[0] == 0 ? 1 : 0; i &lt; m + n; i++) &#123;        ans.append(ansArr[i]);    &#125;    return ans.toString();&#125;\n\n复杂度分析\n时间复杂度：O(mn)，其中 m 和 n 分别是 num1 和 num2 的长度。需要计算 num1 的每一位和 num2 的每一位的乘积。\n空间复杂度：O(m + n)，其中 m 和 n 分别是 num1 和 num2 的长度。需要创建一个长度为 m + n 的数组存储乘积。\n\n来源\n字符串相乘 | 力扣（LeetCode）字符串相乘 | 题解（LeetCode）\n\n\n","categories":["LeetCode"],"tags":["Java","LeetCode","学习笔记","数组","字符串","数学"]},{"title":"区间列表的交集","url":"/blog/2020/08/15/interval-list-intersections/","content":"\n题目描述给定两个由一些闭区间组成的列表，每个区间列表都是成对不相交的，并且已经排序。返回这两个区间列表的交集。（形式上，闭区间 [a, b]（其中 a &lt;= b）表示实数 x 的集合，而 a &lt;= x &lt;= b。两个闭区间的交集是一组实数，要么为空集，要么为闭区间。例如，[1, 3] 和 [2, 4] 的交集为 [2, 3]。）\n示例：\n\n\n\n输入：A = [[0, 2], [5, 10], [13, 23], [24, 25]], B = [[1, 5], [8, 12], [15, 24], [25, 26]]输出：[[1, 2], [5, 5], [8, 10], [15, 23], [24, 24], [25, 25]]\n\n提示：\n\n0 &lt;= A.length &lt; 1000\n0 &lt;= B.length &lt; 1000\n0 &lt;= A[i].start, A[i].end, B[i].start, B[i].end &lt; 10^9\n\n\n\n题解最开始我的想法是使用一个指针 start 扫描两个闭区间的值，判断当前 start 的值是否在 A[indexA] 和 B[indexB] 的区间内，发现进入到区间后，那么我们再引入 end 指针，值为 start 的值，然后移动 end 指针，直到出了 A[indexA] 或者 B[indexB] 的区间范围，那么 start 和 end - 1 的值就是两个区间的交集。然后将 end 的值赋值给 start 并判断 start ，如果超出了 A[indexA] 或者 B[indexB] 的区间，则分别进行 indexA++ 或者 indexB++ 的操作。代码如下：\npublic int[][] intervalIntersection(int[][] A, int[][] B) &#123;    if (A == null || B == null) &#123;        return new int[0][];    &#125;    List&lt;int[]&gt; ans = new ArrayList&lt;&gt;();    int indexA = 0;    int indexB = 0;    int start = 0;    int[] common = new int[2];    while (indexA &lt; A.length &amp;&amp; indexB &lt; B.length) &#123;        if (A[indexA][0] &lt;= start &amp;&amp; start &lt;= A[indexA][1] &amp;&amp; B[indexB][0] &lt;= start &amp;&amp; start &lt;= B[indexB][1]) &#123;            common[0] = start;            int end = start;            while (A[indexA][0] &lt;= end &amp;&amp; end &lt;= A[indexA][1] &amp;&amp; B[indexB][0] &lt;= end &amp;&amp; end &lt;= B[indexB][1]) &#123;                end++;            &#125;            common[1] = end - 1;            ans.add(common.clone());            start = end;        &#125; else &#123;            start++;        &#125;        if (start &gt; A[indexA][1]) &#123;            indexA++;        &#125;        if (start &gt; B[indexB][1]) &#123;            indexB++;        &#125;    &#125;    return ans.toArray(new int[0][]);&#125;\n\n上面的方法在提交后超时了，分析用例和代码发现，上面的代码有以下两个问题：\n\nstart 的值从 0 开始，如果 A[0] 和 B[0] 的起始值比较大，那么就做了很多无用的 start++ 操作。\nend 的值从 start 开始，遍历到区间的最大值，如果区间范围过大，也会导致频繁的 end++。\n\n于是我们根据上面的问题进行优化，先从 A[0] 和 B[0] 开始找规律，假设两个闭区间有交集，那么我们可以发现，交集的起始值 start = max(A[0][0], B[0][0])，交集的终止值 end = min(A[0][1], B[0][1])。这样我们相比上面的方法，减少了很多无用的 ++ 操作。延申而来，对于任意的 A[indexA] 和 B[indexB] 都可以这样求出交集。但是如果求出 start &gt; end 则认为这两个区间没有交集，然后我们对于提前结束的集合，即集合的最大值等于 end 的集合，我们对其指针进行 index++ 操作。因为较早结束的集合，已经计算完交集了，而另外一个范围比较大的集合，还有有值没有计算是否相交。下面看代码将会更好的理解。\npublic int[][] intervalIntersection(int[][] A, int[][] B) &#123;    if (A == null || B == null) &#123;        return new int[0][];    &#125;    List&lt;int[]&gt; ans = new ArrayList&lt;&gt;();    int indexA = 0;    int indexB = 0;    while (indexA &lt; A.length &amp;&amp; indexB &lt; B.length) &#123;        int start = Math.max(A[indexA][0], B[indexB][0]);        int end = Math.min(A[indexA][1], B[indexB][1]);        if (start &lt;= end) &#123;            ans.add(new int[]&#123;start, end&#125;);        &#125;        if (A[indexA][1] == end) &#123;            indexA++;        &#125;        if (B[indexB][1] == end) &#123;            indexB++;        &#125;    &#125;    return ans.toArray(new int[0][]);&#125;\n\n进一步我们使用条件运算符优化下 16 行开始的代码。\npublic int[][] intervalIntersection(int[][] A, int[][] B) &#123;    if (A == null || B == null) &#123;        return new int[0][];    &#125;    List&lt;int[]&gt; ans = new ArrayList&lt;&gt;();    int indexA = 0;    int indexB = 0;    while (indexA &lt; A.length &amp;&amp; indexB &lt; B.length) &#123;        int start = Math.max(A[indexA][0], B[indexB][0]);        int end = A[indexA][1] &lt; B[indexB][1] ? A[indexA++][1] : B[indexB++][1];        if (start &lt;= end) &#123;            ans.add(new int[]&#123;start, end&#125;);        &#125;    &#125;    return ans.toArray(new int[0][]);&#125;\n\n复杂度分析\n时间复杂度：O(M + N)，其中 M, N 分别是数组 A 和 B 的长度。\n空间复杂度：O(M + N)，答案中区间数量的上限。\n\n来源\n区间列表的交集 | 力扣（LeetCode）区间列表的交集 | 题解（LeetCode）\n\n\n","categories":["LeetCode"],"tags":["Java","LeetCode","学习笔记","数组","指针","双指针"]},{"title":"平衡二叉树","url":"/blog/2020/08/17/balanced-binary-tree/","content":"\n题目描述给定一个二叉树，判断它是否是高度平衡的二叉树。本题中，一棵高度平衡二叉树定义为：一个二叉树每个节点的左右两个子树的高度差的绝对值不超过1。\n示例 1:\n给定二叉树 [3, 9, 20, null, null, 15, 7]    3   / \\  9  20    /  \\   15   7返回 true 。\n\n示例 2:\n给定二叉树 [1, 2, 2, 3, 3, null, null, 4, 4]       1      / \\     2   2    / \\   3   3  / \\ 4   4返回 false 。\n\n\n\n题解根据题意一个二叉树每个节点的左右两个子树的高度差的绝对值不超过1。那么我们可以递归的判断一棵树的左右子树，判断是否是平衡二叉树。对于当前遍历到的节点，先递归地判断其左右子树是否平衡，再判断以当前节点为根的子树是否平衡。如果一棵子树是平衡的，则返回其高度（高度一定是非负整数），否则返回 -1。如果存在一棵子树不平衡，则整个二叉树一定不平衡。\npublic boolean isBalanced(TreeNode root) &#123;    return height(root) != -1;&#125;public int height(TreeNode node) &#123;    if (node == null) &#123;        return 0;    &#125;    int leftHeight = height(node.left);    int rightHeight = height(node.right);    if (leftHeight == -1 || rightHeight == -1 || Math.abs(leftHeight - rightHeight) &gt; 1) &#123;        return -1;    &#125; else &#123;        return Math.max(leftHeight, rightHeight) + 1;    &#125;&#125;\n\n对于上述代码，我们还可以简单优化下，如果左子树不是平衡的，那么也就不需要再递归的求右子树是否平衡了。\npublic boolean isBalanced(TreeNode root) &#123;    return height(root) != -1;&#125;public int height(TreeNode node) &#123;    if (node == null) &#123;        return 0;    &#125;    int leftHeight;    int rightHeight;    if ((leftHeight = height(node.left)) == -1            || (rightHeight = height(node.right)) == -1            || Math.abs(leftHeight - rightHeight) &gt; 1) &#123;        return -1;    &#125; else &#123;        return Math.max(leftHeight, rightHeight) + 1;    &#125;&#125;\n\n另外也可以先看一道简单的求树的高度的题：二叉树的最大深度 | 笑话人生\n复杂度分析\n时间复杂度：O(n)，其中 n 是二叉树中的节点个数。使用自底向上的递归，每个节点的计算高度和判断是否平衡都只需要处理一次，最坏情况下需要遍历二叉树中的所有节点，因此时间复杂度是 O(n)。\n空间复杂度：O(n)，其中 n 是二叉树中的节点个数。空间复杂度主要取决于递归调用的层数，递归调用的层数不会超过 n。\n\n来源\n平衡二叉树 | 力扣（LeetCode）平衡二叉树 | 题解（LeetCode）\n\n\n","categories":["LeetCode"],"tags":["Java","LeetCode","学习笔记","递归","树","二叉树","深度优先搜索","平衡二叉树"]},{"title":"将二叉搜索树变平衡","url":"/blog/2020/08/20/balance-a-binary-search-tree/","content":"\n题目描述给你一棵二叉搜索树，请你返回一棵平衡后的二叉搜索树，新生成的树应该与原来的树有着相同的节点值。如果一棵二叉搜索树中，每个节点的两棵子树高度差不超过 1 ，我们就称这棵二叉搜索树是平衡的。如果有多种构造方法，请你返回任意一种。\n示例：\n\n\n\n\n输入：root = [1, null, 2, null, 3, null, 4, null, null]输出：[2, 1, 3, null, null, null, 4]解释：这不是唯一的正确答案，[3, 1, 4, null, 2, null, null] 也是一个可行的构造方案。\n\n提示：\n\n树节点的数目在 1 到 10^4 之间。\n树节点的值互不相同，且在 1 到 10^5 之间。\n\n\n\n题解「平衡」要求它是一棵空树或它的左右两个子树的高度差的绝对值不超过 1，这很容易让我们产生这样的想法——左右子树的大小越「平均」，这棵树会不会越平衡？于是一种贪心策略就形成了：我们可以通过中序遍历将原来的二叉搜索树转化为一个有序序列，然后对这个有序序列递归建树，对于区间 [L, R]：\n\n取 mid = (L + R) / 2，即中心位置做为当前节点的值。\n如果 L ≤ mid − 1，那么递归地将区间 [L, mid − 1] 作为当前节点的左子树。\n如果 mid + 1 ≤ R，那么递归地将区间 [mid + 1, R] 作为当前节点的右子树。\n\n经过证明此方法是可行的，关于证明方式在此不做赘述，想要了解的同学可以参考下面官方的题解。\nList&lt;Integer&gt; treeValList = new ArrayList&lt;&gt;();public TreeNode balanceBST(TreeNode root) &#123;    dfsGetTreeValList(root);    return buildBalanceBST(0, treeValList.size() - 1);&#125;private TreeNode buildBalanceBST(int left, int right) &#123;    int mid = right - ((right - left) &gt;&gt; 1);    TreeNode node = new TreeNode(treeValList.get(mid));    node.left = left &lt; mid ? buildBalanceBST(left, mid - 1) : null;    node.right = mid &lt; right ? buildBalanceBST(mid + 1, right) : null;    return node;&#125;private void dfsGetTreeValList(TreeNode node) &#123;    if (node == null) &#123;        return;    &#125;    dfsGetTreeValList(node.left);    treeValList.add(node.val);    dfsGetTreeValList(node.right);&#125;public class TreeNode &#123;    int val;    TreeNode left;    TreeNode right;    TreeNode(int x) &#123;        val = x;    &#125;&#125;\n\n复杂度分析\n时间复杂度：O(n)，获得中序遍历的时间代价是 O(n)；建立平衡二叉树的时建立每个点的时间代价为 O(1)，总时间也是 O(n)。故渐进时间复杂度为 O(n)。\n空间复杂度：O(n)，这里使用了一个数组作为辅助空间，存放中序遍历后的有序序列，故渐进空间复杂度为 O(n)。\n\n来源\n将二叉搜索树变平衡 | 力扣（LeetCode）将二叉搜索树变平衡 | 题解（LeetCode）\n\n\n","categories":["LeetCode"],"tags":["Java","LeetCode","学习笔记","递归","贪心算法","树","二叉树","深度优先搜索","中序遍历","二叉搜索树","平衡二叉树"]},{"title":"数字范围按位与","url":"/blog/2020/08/26/bitwise-and-of-numbers-range/","content":"\n题目描述给定范围 [m, n]，其中 0 &lt;= m &lt;= n &lt;= 2147483647，返回此范围内所有数字的按位与（包含 m, n 两端点）。\n示例 1:\n\n输入: [5, 7]输出: 4\n\n示例 2:\n\n输入: [0, 1]输出: 0\n\n\n\n题解我们观察按位与运算的性质。对于一系列的位，例如 [1, 1, 0, 1, 1]，只要有一个零的位，那么这一系列位的按位与运算结果都将为零。对于此题，我们将一系列数字变成二进制展示，如下：\n\n\n\n-\n1\n2\n3\n4\n5\n6\n7\n8\n\n\n\n0\n0\n0\n0\n0\n0\n0\n0\n0\n\n\n1\n0\n0\n0\n0\n0\n0\n0\n1\n\n\n2\n0\n0\n0\n0\n0\n0\n1\n0\n\n\n3\n0\n0\n0\n0\n0\n0\n1\n1\n\n\n4\n0\n0\n0\n0\n0\n1\n0\n0\n\n\n5\n0\n0\n0\n0\n0\n1\n0\n1\n\n\n6\n0\n0\n0\n0\n0\n1\n1\n0\n\n\n7\n0\n0\n0\n0\n0\n1\n1\n1\n\n\n8\n0\n0\n0\n0\n1\n0\n0\n0\n\n\n9\n0\n0\n0\n0\n1\n0\n0\n1\n\n\n10\n0\n0\n0\n0\n1\n0\n1\n0\n\n\n11\n0\n0\n0\n0\n1\n0\n1\n1\n\n\n12\n0\n0\n0\n0\n1\n1\n0\n0\n\n\n13\n0\n0\n0\n0\n1\n1\n0\n1\n\n\n14\n0\n0\n0\n0\n1\n1\n1\n0\n\n\n15\n0\n0\n0\n0\n1\n1\n1\n1\n\n\n16\n0\n0\n0\n1\n0\n0\n0\n0\n\n\n上面表格中，我将[0, 16] 全部展开成8进制展示，上图中，我们任意取出一个范围，比如[9, 12]，我们可以发现，对所有数字执行按位与运算的结果是所有对应二进制字符串的公共前缀再用零补上后面的剩余位。那么这个规律是否正确呢？我们可以进行简单的证明。假设对于所有这些二进制串，前 i 位均相同，第 i + 1 位开始不同，由于 [m, n] 连续，所以第 i + 1 位在 [m, n] 的数字范围从小到大列举出来一定是前面全部是 0，后面全部是 1，在上图中对应 [9, 11] 均为 0，[12, 12] 均为 1。并且一定存在连续的两个数 x 和 x + 1，满足 x 的第 i + 1 位为 0，后面全为 1，x + 1 的第 i + 1 位为 1，后面全为 0，对应上图中的例子即为 11 和 12。这种形如 0111… 和 1000… 的二进制串的按位与的结果一定为 0000…，因此第 i + 1 位开始的剩余位均为 0，前 i 位由于均相同，因此按位与结果不变。最后的答案即为二进制字符串的公共前缀再用零补上后面的剩余位。\n进一步来说，所有这些二进制字符串的公共前缀也即指定范围的起始和结束数字 m 和 n 的公共前缀（即在上面的示例中分别为 9 和 12）。因此，最终我们可以将问题重新表述为：给定两个整数，我们要找到它们对应的二进制字符串的公共前缀。\n位移操作我们的想法是将两个数字不断向右移动，直到数字相等，即数字被缩减为它们的公共前缀。计算移动的次数，然后，通过将公共前缀向左移动相同次数，将零添加到公共前缀的右边以获得最终结果。\npublic int rangeBitwiseAnd(int m, int n) &#123;    int count = 0;    while (m != n) &#123;        m = m &gt;&gt; 1;        n = n &gt;&gt; 1;        count++;    &#125;    return m &lt;&lt; count;&#125;\n\n复杂度分析\n时间复杂度：O(logn)。算法的时间复杂度取决于 m 和 n 的二进制位数，由于 m ≤ n，因此时间复杂度取决于 n 的二进制位数。\n空间复杂度：O(1)。我们只需要常数空间存放若干变量。\n\nBrian Kernighan 算法还有一个位移相关的算法叫做「Brian Kernighan 算法」，它用于清除二进制串中最右边的 1。Brian Kernighan 算法的关键在于我们每次对 n 和 n − 1 之间进行按位与运算后，n 中最右边的 1 会被抹去变成 0。\n\n\n基于上述技巧，我们可以用它来计算两个二进制字符串的公共前缀。其思想是，对于给定的范围 [m, n]（m &lt; n），我们可以对数字 n 迭代地应用上述技巧，清除最右边的 1，直到它小于或等于 m，此时非公共前缀部分的 1 均被消去。因此最后我们返回 n 即可。\npublic int rangeBitwiseAnd(int m, int n) &#123;    while (m &lt; n) &#123;        n = n &amp; (n - 1);    &#125;    return n;&#125;\n\n复杂度分析\n时间复杂度：O(logn)。和位移方法类似，算法的时间复杂度取决于 m 和 n 二进制展开的位数。尽管和位移方法具有相同的渐近复杂度，但 Brian Kernighan 的算法需要的迭代次数会更少，因为它跳过了两个数字之间的所有零位。\n空间复杂度：O(1)。我们只需要常数空间存放若干变量。\n\n来源\n数字范围按位与 | 力扣（LeetCode）数字范围按位与 | 题解（LeetCode）\n\n\n","categories":["LeetCode"],"tags":["Java","LeetCode","学习笔记","数学","位运算","Brian Kernighan 算法"]},{"title":"重新安排行程","url":"/blog/2020/08/28/reconstruct-itinerary/","content":"\n题目描述给定一个机票的字符串二维数组 [from, to]，子数组中的两个成员分别表示飞机出发和降落的机场地点，对该行程进行重新规划排序。所有这些机票都属于一个从 JFK（肯尼迪国际机场）出发的先生，所以该行程必须从 JFK 开始。\n提示：\n\n如果存在多种有效的行程，请你按字符自然排序返回最小的行程组合。例如，行程 [“JFK”, “LGA”] 与 [“JFK”, “LGB”] 相比就更小，排序更靠前。\n所有的机场都用三个大写字母表示（机场代码）。\n假定所有机票至少存在一种合理的行程。\n所有的机票必须都用一次且只能用一次。\n\n示例 1：\n\n输入：[[“MUC”, “LHR”], [“JFK”, “MUC”], [“SFO”, “SJC”], [“LHR”, “SFO”]]输出：[“JFK”, “MUC”, “LHR”, “SFO”, “SJC”]\n\n示例 2：\n\n输入：[[“JFK”, “SFO”],[“JFK”, “ATL”],[“SFO”, “ATL”],[“ATL”, “JFK”],[“ATL”, “SFO”]]输出：[“JFK”, “ATL”, “JFK”, “SFO”, “ATL”, “SFO”]解释：另一种有效的行程是 [“JFK”, “SFO”, “ATL”, “JFK”, “ATL”, “SFO”]。但是它自然排序更大更靠后。\n\n\n\n题解本题是一道求解欧拉回路/欧拉通路的问题。也叫「一笔画」问题，下面给出定义。\n\n通过图中所有边恰好一次且行遍所有顶点的通路称为欧拉通路。\n通过图中所有边恰好一次且行遍所有顶点的回路称为欧拉回路。\n具有欧拉回路的无向图称为欧拉图。\n具有欧拉通路但不具有欧拉回路的无向图称为半欧拉图。\n\n因为本题保证至少存在一种合理的路径，也就告诉了我们，这张图是一个欧拉图或者半欧拉图。我们只需要输出这条欧拉通路的路径即可。如果没有保证至少存在一种合理的路径，我们需要判别这张图是否是欧拉图或者半欧拉图，具体地：\n\n对于无向图 G，G 是欧拉图当且仅当 G 是连通的且没有奇度顶点。\n\n对于无向图 G，G 是半欧拉图当且仅当 G 是连通的且 G 中恰有 2 个奇度顶点。\n\n对于有向图 G，G 是欧拉图当且仅当 G 的所有顶点属于同一个强连通分量且每个顶点的入度和出度相同。\n\n对于有向图 G，G 是半欧拉图当且仅当 G 的所有顶点属于同一个强连通分量且。\n\n恰有一个顶点的出度与入度差为 1；\n\n恰有一个顶点的入度与出度差为 1；\n\n所有其他顶点的入度和出度相同。\n接下来我们考虑如下的行程：合法路径为 JFK→BBB→JFK→AAA\n\n\n\n\n算法 Hierholzer 算法用于在连通图中寻找欧拉路径，其流程如下：\n\n从起点出发，进行深度优先搜索。\n每次沿着某条边从某个顶点移动到另外一个顶点的时候，都需要删除这条边。\n如果没有可移动的路径，则将所在节点加入到栈中，并返回。\n\n当我们顺序地考虑该问题时，我们也许很难解决该问题，根据上图我们可以发现，如果我们先走到 AAA 的顶点，就回不去了，我们走入了「死胡同」，从而导致无法遍历到其他还未访问的边。于是我们希望能够遍历完当前节点所连接的其他节点后再进入「死胡同」。\n\n注意对于每一个节点，它只有最多一个「死胡同」分支。依据前言中对于半欧拉图的描述，只有那个入度与出度差为 1 的节点会导致死胡同。\n\n不妨倒过来思考。我们注意到只有那个入度与出度差为 1 的节点会导致死胡同。而该节点必然是最后一个遍历到的节点。我们可以改变入栈的规则，当我们遍历完一个节点所连的所有节点后，我们才将该节点入栈（即逆序入栈）。对于当前节点而言，从它的每一个非「死胡同」分支出发进行深度优先搜索，都将会搜回到当前节点。而从它的「死胡同」分支出发进行深度优先搜索将不会搜回到当前节点。也就是说当前节点的死胡同分支将会优先于其他非「死胡同」分支入栈。另外为了保证我们能够快速找到当前节点所连的节点中字典序最小的那一个，我们可以使用优先队列存储当前节点所连到的点。\n这样就能保证我们可以「一笔画」地走完所有边，最终的栈中逆序地保存了「一笔画」的结果。我们只要将栈中的内容反转，即可得到答案。\nMap&lt;String, PriorityQueue&lt;String&gt;&gt; graph = new HashMap&lt;&gt;();List&lt;String&gt; ans = new LinkedList&lt;&gt;();public List&lt;String&gt; findItinerary(List&lt;List&lt;String&gt;&gt; tickets) &#123;    for (List&lt;String&gt; ticket : tickets) &#123;        if (graph.containsKey(ticket.get(0))) &#123;            graph.get(ticket.get(0)).add(ticket.get(1));        &#125; else &#123;            PriorityQueue&lt;String&gt; queue = new PriorityQueue&lt;&gt;();            queue.add(ticket.get(1));            graph.put(ticket.get(0), queue);        &#125;    &#125;    buildEulerPath(&quot;JFK&quot;);    Collections.reverse(ans);    return ans;&#125;public void buildEulerPath(String travel) &#123;    while (graph.containsKey(travel) &amp;&amp; graph.get(travel).size() &gt; 0) &#123;        String tmpTravel = graph.get(travel).poll();        buildEulerPath(tmpTravel);    &#125;    ans.add(travel);&#125;\n\n复杂度分析\n时间复杂度：O(mlogm)，其中 m 是边的数量。对于每一条边我们需要 O(logm) 地删除它，最终的答案序列长度为 m + 1。\n空间复杂度：O(m)，其中 m 是边的数量。我们需要存储每一条边。\n\n来源\n重新安排行程 | 力扣（LeetCode）重新安排行程 | 题解（LeetCode）\n\n\n","categories":["LeetCode"],"tags":["Java","LeetCode","学习笔记","递归","回溯算法","深度优先搜索","图","优先队列","欧拉路径"]},{"title":"钥匙和房间","url":"/blog/2020/08/31/keys-and-rooms/","content":"\n题目描述有 N 个房间，开始时你位于 0 号房间。每个房间有不同的号码：0，1，2，…，N - 1，并且房间里可能有一些钥匙能使你进入下一个房间。在形式上，对于每个房间 i 都有一个钥匙列表 rooms[i]，每个钥匙 rooms[i][j] 由 [0, 1，…，N - 1] 中的一个整数表示，其中 N = rooms.length。 钥匙 rooms[i][j] = v 可以打开编号为 v 的房间。\n最初，除 0 号房间外的其余所有房间都被锁住。你可以自由地在房间之间来回走动。如果能进入每个房间返回 true，否则返回 false。\n示例 1：\n\n输入: [[1], [2], [3], []]输出: true解释:我们从 0 号房间开始，拿到钥匙 1。之后我们去 1 号房间，拿到钥匙 2。然后我们去 2 号房间，拿到钥匙 3。最后我们去了 3 号房间。由于我们能够进入每个房间，我们返回 true。\n\n示例 2：\n\n输入：[[1, 3], [3, 0, 1], [2], [0]]输出：false解释：我们不能进入 2 号房间。\n\n提示：\n\n1 &lt;= rooms.length &lt;= 1000\n0 &lt;= rooms[i].length &lt;= 1000\n所有房间中的钥匙数量总计不超过 3000。\n\n\n\n深度优先搜索此题我们将房间理解成节点，房间 A 到房间 B 理解成边，这样这道题就变成了，我们从图的 0 点出发，能否到达所有节点的问题。\n具体实现上，我们使用一个变量 count 记录访问过的房间数，每次访问过一个房间后就标记为访问过 visited[room] = true，并将 count++ ，如果最后 count 等于房间的数量，那么就说明可以访问所有的房间。\nint count = 0;boolean[] visited;public boolean canVisitAllRooms(List&lt;List&lt;Integer&gt;&gt; rooms) &#123;    visited = new boolean[rooms.size()];    visitRooms(rooms, 0);    return count == rooms.size();&#125;private void visitRooms(List&lt;List&lt;Integer&gt;&gt; rooms, Integer room) &#123;    visited[room] = true;    count++;    List&lt;Integer&gt; keyList = rooms.get(room);    for (Integer nextRoom : keyList) &#123;        if (!visited[nextRoom]) &#123;            visitRooms(rooms, nextRoom);        &#125;    &#125;&#125;\n\n复杂度分析\n时间复杂度：O(n + m)，其中 n 是房间的数量，m 是所有房间中的钥匙数量的总数。\n空间复杂度：O(n)，其中 n 是房间的数量。主要为栈空间的开销。\n\n广度优先搜索同样的，我们可以使用广度优先搜索解决此问题。\npublic boolean canVisitAllRooms(List&lt;List&lt;Integer&gt;&gt; rooms) &#123;    int n = rooms.size();    int count = 0;    boolean[] visited = new boolean[n];    Queue&lt;Integer&gt; queue = new LinkedList&lt;Integer&gt;();    visited[0] = true;    queue.offer(0);    while (!queue.isEmpty()) &#123;        int room = queue.poll();        count++;        for (int key : rooms.get(room)) &#123;            if (!visited[key]) &#123;                visited[key] = true;                queue.offer(key);            &#125;        &#125;    &#125;    return count == n;&#125;\n\n复杂度分析\n时间复杂度：O(n + m)，其中 n 是房间的数量，m 是所有房间中的钥匙数量的总数。\n空间复杂度：O(n)，其中 n 是房间的数量。主要为队列的开销。\n\n来源\n钥匙和房间 | 力扣（LeetCode）钥匙和房间 | 题解（LeetCode）\n\n\n","categories":["LeetCode"],"tags":["Java","LeetCode","学习笔记","队列","递归","深度优先搜索","广度优先搜索","图"]},{"title":"预测赢家","url":"/blog/2020/09/01/predict-the-winner/","content":"\n题目描述给定一个表示分数的非负整数数组。 玩家 1 从数组任意一端拿取一个分数，随后玩家 2 继续从剩余数组任意一端拿取分数，然后玩家 1 拿，…… 。每次一个玩家只能拿取一个分数，分数被拿取之后不再可取。直到没有剩余分数可取时游戏结束。最终获得分数总和最多的玩家获胜。给定一个表示分数的数组，预测玩家1是否会成为赢家。你可以假设每个玩家的玩法都会使他的分数最大化。\n示例 1：\n\n输入：[1, 5, 2]输出：False解释：一开始，玩家1可以从1和2中进行选择。如果他选择 2（或者 1 ），那么玩家 2 可以从 1（或者 2 ）和 5 中进行选择。如果玩家 2 选择了 5 ，那么玩家 1 则只剩下 1（或者 2 ）可选。所以，玩家 1 的最终分数为 1 + 2 = 3，而玩家 2 为 5 。因此，玩家 1 永远不会成为赢家，返回 False 。\n\n示例 2：\n\n输入：[1, 5, 233, 7]输出：True解释：玩家 1 一开始选择 1 。然后玩家 2 必须从 5 和 7 中进行选择。无论玩家 2 选择了哪个，玩家 1 都可以选择 233 。最终，玩家 1（234 分）比玩家 2（12 分）获得更多的分数，所以返回 True，表示玩家 1 可以成为赢家。\n\n提示：\n\n1 &lt;= 给定的数组长度 &lt;= 20.\n数组里所有分数都为非负数且不会大于 10000000 。\n如果最终两个玩家的分数相等，那么玩家 1 仍为赢家。\n\n\n\n递归为了判断哪个玩家可以获胜，需要计算一个得分差值，即先手得分赢过后手的得分。当数组中的所有数字都被拿取时，如果先手与后手得分之差大于或等于 0，则先手获胜，反之则后手获胜。\n由于每次只能从数组的任意一端拿取数字，因此可以保证数组中剩下的部分一定是连续的。假设数组当前剩下的部分为下标 start 到下标 end，其中 0 ≤ start ≤ end &lt; nums.length。如果 start = end，则只剩一个数字，当前玩家只能拿取这个数字。如果 start &lt; end，则当前玩家可以选择 nums[start] 或 nums[end]，然后轮到另一个玩家在数组剩下的部分选取数字。这是一个递归的过程。递归时记录当前做选择的玩家赢过对手的分数。如果大于等于 0，则代表他在这个子问题中赢了。\npublic boolean PredictTheWinner(int[] nums) &#123;    return calculate(nums, 0, nums.length - 1) &gt;= 0;&#125;public int calculate(int[] nums, int start, int end) &#123;    if (start == end) &#123;        return nums[start];    &#125;    int selectStart = nums[start] - calculate(nums, start + 1, end);    int selectEnd = nums[end] - calculate(nums, start, end - 1);    return Math.max(selectStart, selectEnd);&#125;\n\n上面的递归，其实有很多重复的计算，比如你先选 1，我再选 7，和你先选 7，我再选 1，这两种所带来的子问题是一样的，都是剩下 [5, 233]。我们用数组或哈希表去存储计算过的子问题的解，遇到重复的子问题，就不用再次递归计算。\nInteger[][] maxScore;public boolean PredictTheWinner(int[] nums) &#123;    maxScore = new Integer[nums.length][nums.length];    return calculate(nums, 0, nums.length - 1) &gt;= 0;&#125;public int calculate(int[] nums, int start, int end) &#123;    if (maxScore[start][end] != null) &#123;        return maxScore[start][end];    &#125;    if (start == end) &#123;        return maxScore[start][end] = nums[start];    &#125;    int selectStart = nums[start] - calculate(nums, start + 1, end);    int selectEnd = nums[end] - calculate(nums, start, end - 1);    return maxScore[start][end] = Math.max(selectStart, selectEnd);&#125;\n\n复杂度分析\n时间复杂度：O(2^n)，其中 n 是数组的长度。\n空间复杂度：O(n)，其中 n 是数组的长度。空间复杂度取决于递归使用的栈空间。\n\n动态规划定义二维数组 dp，其行数和列数都等于数组的长度，dp[i][j] 表示当数组剩下的部分为下标 i 到下标 j 时，当前玩家与另一个玩家的分数之差的最大值，注意当前玩家不一定是先手。\n\n只有当 i ≤ j 时，数组剩下的部分才有意义，因此当 i &gt; j 时，dp[i][j] = 0。\n当 i = j 时，只剩一个数字，当前玩家只能拿取这个数字，因此对于所有 0 ≤ i &lt; nums.length，都有 dp[i][i] = nums[i]。\n当 i &lt; j 时，当前玩家可以选择 nums[i] 或 nums[j]，然后轮到另一个玩家在数组剩下的部分选取数字。在两种方案中，当前玩家会选择最优的方案，使得自己的分数最大化。因此可以得到如下状态转移方程：\ndp[i][j] = max(nums[i] − dp[i+1][j], nums[j] − dp[i][j − 1])\n\n\n\n最后判断 dp[0][nums.length − 1] 的值，如果大于或等于 0，则先手得分大于或等于后手得分，因此先手成为赢家，否则后手成为赢家。\npublic boolean PredictTheWinner(int[] nums) &#123;    int[][] dp = new int[nums.length][nums.length];    for (int i = 0; i &lt; nums.length; i++) &#123;        dp[i][i] = nums[i];    &#125;    for (int i = nums.length - 2; i &gt;= 0; i--) &#123;        for (int j = i + 1; j &lt; nums.length; j++) &#123;            dp[i][j] = Math.max(nums[i] - dp[i + 1][j], nums[j] - dp[i][j - 1]);        &#125;    &#125;    return dp[0][nums.length - 1] &gt;= 0;&#125;\n\n上述代码中使用了二维数组 dp。分析状态转移方程可以看到，dp[i][j] 的值只和 dp[i + 1][j] 与 dp[i][j − 1] 有关，即在计算 dp 的第 i 行的值时，只需要使用到 dp 的第 i 行和第 i + 1 行的值，因此可以使用一维数组代替二维数组，对空间进行优化。\npublic boolean PredictTheWinner(int[] nums) &#123;    int[] dp = new int[nums.length];    for (int i = 0; i &lt; nums.length; i++) &#123;        dp[i] = nums[i];    &#125;    for (int i = nums.length - 2; i &gt;= 0; i--) &#123;        for (int j = i + 1; j &lt; nums.length; j++) &#123;            dp[j] = Math.max(nums[i] - dp[j], nums[j] - dp[j - 1]);        &#125;    &#125;    return dp[nums.length - 1] &gt;= 0;&#125;\n\n复杂度分析\n时间复杂度：O(n²)，其中 n 是数组的长度。需要计算每个子数组对应的 dp 的值，共有 n * (n + 1) / 2 个子数组。\n空间复杂度：O(n)，其中 n 是数组的长度。空间复杂度取决于额外创建的数组 dp，如果不优化空间，则空间复杂度是 O(n²)，使用一维数组优化之后空间复杂度可以降至 O(n)。\n\n来源\n预测赢家 | 力扣（LeetCode）预测赢家 | 题解（LeetCode）\n\n\n","categories":["LeetCode"],"tags":["Java","LeetCode","学习笔记","递归","记忆化","动态规划","滚动数组","零和博弈"]},{"title":"二叉树的遍历","url":"/blog/2020/09/02/binary-tree-traverse/","content":"\n前言最近一直在刷 Leetcode ，其中涉及了很多二叉树相关的题，二叉树是一种很重要的数据结构，很多其他的数据结构都是以二叉树为基础，二叉树的遍历涉及很多种，包括前序遍历、中序遍历、后序遍历、层次遍历。开始一直分不清这些遍历是如何工作的，随着后面题刷的越来越多，也渐渐熟悉了二叉树的遍历方式，在这里做一个总结分享给大家。\n四种遍历的主要方式为：\n\n前序遍历：根节点 -&gt; 左子树 -&gt; 右子树\n中序遍历：左子树 -&gt; 根节点 -&gt; 右子树\n后序遍历：左子树 -&gt; 右子树 -&gt; 根节点\n层次遍历：从上到下按照层遍历\n\n接下来使用以下的二叉树做样例：\n        1       / \\      2   3     / \\   \\    4   5   6       / \\      7   8前序遍历：1  2  4  5  7  8  3  6 中序遍历：4  2  7  5  8  1  3  6后序遍历：4  7  8  5  2  6  3  1层次遍历：1  2  3  4  5  6  7  8\n\n\n\n前序遍历前序遍历：根节点 -&gt; 左子树 -&gt; 右子树。前序遍历是先输出根节点的值，再去递归的输出左子树和右子树。代码实现也包括递归和非递归两个版本。\n递归树的结构定义本身就是递归的定义，所以使用递归版本实现树的遍历会使代码更加简洁易于理解。\npublic void dfsPreOrderTraverse(TreeNode root) &#123;    if (root == null) &#123;        return;    &#125;    System.out.print(root.val + &quot; &quot;);    dfsPreOrderTraverse(root.left);    dfsPreOrderTraverse(root.right);&#125;\n\n非递归非递归版本，就没有递归版本那么好理解，代码也比较多，我们这里引入栈来保存每个节点，首先将根节点加入栈中，接下来我们遍历此栈，根据栈的后进先出特性，每次将栈顶元素退出，并输出其值，接下来，我们将此节点的右节点和左节点依次加入到栈中，根据栈的后进先出特性，永远都是先输出左子树，然后输出右子树。\npublic void preOrderTraverse(TreeNode root) &#123;    if (root == null) &#123;        return;    &#125;    Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();    stack.push(root);    while (!stack.isEmpty()) &#123;        TreeNode node = stack.pop();        System.out.print(node.val + &quot; &quot;);        if (node.right != null) &#123;            stack.push(node.right);        &#125;        if (node.left != null) &#123;            stack.push(node.left);        &#125;    &#125;&#125;\n\n中序遍历中序遍历：左子树 -&gt; 根节点 -&gt; 右子树。中序遍历是中间输出根节点的值，先递归左子树，然后输出根节点的值，再递归右子树。\npublic void dfsInOrderTraverse(TreeNode root) &#123;    if (root == null) &#123;        return;    &#125;    dfsInOrderTraverse(root.left);    System.out.print(root.val + &quot; &quot;);    dfsInOrderTraverse(root.right);&#125;\n\n后续遍历后序遍历：左子树 -&gt; 右子树 -&gt; 根节点。后续遍历是先递归左子树和右子树，最后输出根节点的值。\npublic void dfsPostOrderTraverse(TreeNode root) &#123;    if (root == null) &#123;        return;    &#125;    dfsPostOrderTraverse(root.left);    dfsPostOrderTraverse(root.right);    System.out.print(root.val + &quot; &quot;);&#125;\n\n层次遍历层次遍历：从上到下按照层遍历。这里不是递归的去遍历，而是横向的遍历每一层，这里我们引入队列，我们先把根节点加入到队列中，接下来，根据队列的先进先出特性，我们先从队列中取出最先加入的节点，输出其值，然后将此节点的左右节点分别加入到队列中。\npublic void levelTraverse(TreeNode root) &#123;    if (root == null) &#123;        return;    &#125;    Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();    queue.offer(root);    while (!queue.isEmpty()) &#123;        TreeNode node = queue.poll();        System.out.print(node.val + &quot; &quot;);        if (node.left != null) &#123;            queue.offer(node.left);        &#125;        if (node.right != null) &#123;            queue.offer(node.right);        &#125;    &#125;&#125;\n\n另外一种比较复杂的按层遍历是每层当成一个列表输出，这个时候我们只要增加另外一个队列，同时记录当时遍历的层数即可。\npublic ArrayList&lt;ArrayList&lt;Integer&gt;&gt; levelTraverse(TreeNode root) &#123;    ArrayList&lt;ArrayList&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;();    ArrayList&lt;Integer&gt; item = new ArrayList&lt;&gt;();    if (root == null) &#123;        return ans;    &#125;    Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();    Queue&lt;Integer&gt; queueLevel = new LinkedList&lt;&gt;();    int curLevel = 1;    queue.offer(root);    queueLevel.offer(1);    while (!queue.isEmpty()) &#123;        TreeNode node = queue.poll();        int level = queueLevel.poll();        if (level != curLevel) &#123;            curLevel = level;            ans.add(new ArrayList&lt;&gt;(item));            item.clear();        &#125;        item.add(node.val);        if (node.left != null) &#123;            queue.offer(node.left);            queueLevel.offer(curLevel + 1);        &#125;        if (node.right != null) &#123;            queue.offer(node.right);            queueLevel.offer(curLevel + 1);        &#125;    &#125;    if (!item.isEmpty()) &#123;        ans.add(new ArrayList&lt;&gt;(item));    &#125;    return ans;&#125;\n\n输出样例：[[1], [2, 3], [4, 5, 6], [7, 8]]\n总结其实写完代码就可以发现很多有意思的事情，之前模糊不清的概念也都搞清楚了。\n\n前序、中序、后序遍历其实是针对根节点来说的，对于左右子节点，都是先左后右。另外无论是哪种遍历方式，都是先遍历（访问）根节点，区别就是什么时候处理根节点（比如输出根节点的值）。\n广度优先搜索对于树来说，其实就是层次遍历，深度优先搜索对于树来说，其实就是先序遍历。\n树的层次遍历和树的先序遍历的非递归版本，其实代码一样，只不过一个使用的是队列，一个使用的是栈。\n\n参考\n二叉树遍历（前序、中序、后序、层次遍历、深度优先、广度优先）\n\n\n","categories":["数据结构与算法"],"tags":["Java","LeetCode","数据结构与算法","链表","队列","递归","树","二叉树","深度优先搜索","栈","中序遍历","广度优先搜索","前序遍历","后序遍历"]},{"title":"汉明距离","url":"/blog/2020/09/08/hamming-distance/","content":"\n题目描述两个整数之间的汉明距离指的是这两个数字对应二进制位不同的位置的数目。给出两个整数 x 和 y，计算它们之间的汉明距离。\n示例:\n\n输入: x = 1, y = 4输出: 2解释:\n\n1   (0 0 0 1)4   (0 1 0 0)       ↑   ↑\n\n\n\n位移运算根据题意，我们直接使用异或运算两个整数，结果是相同位为 1，不同位为 0，这样我们直接计算异或后整数的 1 的位数，就是汉明距离。检查某一位是否是 1， 可以使用取模运算(i % 2)或者 AND 与运算(i &amp; 1)。\npublic int hammingDistance(int x, int y) &#123;    int xor = x ^ y;    int ans = 0;    while (xor != 0) &#123;        if (xor % 2 == 1) &#123;            ans += 1;        &#125;        xor = xor &gt;&gt; 1;    &#125;    return ans;&#125;\n\n复杂度分析\n时间复杂度：O(1)，在 Java 中 Integer 的大小是固定的，处理时间也是固定的。 32 位整数需要 32 次迭代。\n空间复杂度：O(1)，使用恒定大小的空间。\n\nBrian Kernighan 算法上面例子中，遇到最右边的 1 后，如果可以跳过中间的 0，直接跳到下一个 1，效率会高很多。这是布赖恩·克尼根位计数算法的基本思想。该算法使用特定比特位和算术运算移除等于 1 的最右比特位。\n当我们在 number 和 number - 1 上做 AND 位运算时，原数字 number 的最右边等于 1 的比特会被移除。\n\n\npublic int hammingDistance(int x, int y) &#123;    int xor = x ^ y;    int ans = 0;    while (xor != 0) &#123;        ans += 1;        xor = xor &amp; (xor - 1);    &#125;    return ans;&#125;\n\n复杂度分析\n时间复杂度：O(1)，在 Java 中 Integer 的大小是固定的，处理时间也是固定的。 但是该方法需要的迭代操作更少。\n空间复杂度：O(1)，使用恒定大小的空间。\n\n来源\n汉明距离 | 力扣（LeetCode）汉明距离 | 题解（LeetCode）\n\n\n","categories":["LeetCode"],"tags":["Java","LeetCode","学习笔记","数学","位运算","Brian Kernighan 算法"]},{"title":"组合","url":"/blog/2020/09/17/combinations/","content":"\n题目描述给定两个整数 n 和 k，返回 1 … n 中所有可能的 k 个数的组合。\n示例:\n\n输入: n = 4, k = 2输出:\n\n[  [2,4],  [3,4],  [2,3],  [1,2],  [1,3],  [1,4],]\n\n\n\n递归从 n 个当中选 k 个的所有方案对应的枚举是组合型枚举。思路很简单，针对 1 … n 中的每个数，在组合的结果中，我们都有两种结果，选择或者不选择。于是我们从第一个数开始进行递归的判断。详细分析在代码注释中。\nList&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;();LinkedList&lt;Integer&gt; item = new LinkedList&lt;&gt;();public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) &#123;    dfsCombine(n, k, 1);    return ans;&#125;public void dfsCombine(int n, int k, int index) &#123;    if (item.size() == k) &#123;        // 如果长度达到k，保存结果。        ans.add(new ArrayList&lt;&gt;(item));        return;    &#125;    if (item.size() + n - index + 1 &lt; k) &#123;        // 如果剩下的数字不够组合成k个数，则不满足要求。        return;    &#125;    // 选择当前元素，然后进行递归。     item.add(index);    dfsCombine(n, k, index + 1);        // 不选择当前元素，然后进行递归，也是一种回溯。    item.removeLast();    dfsCombine(n, k, index + 1);&#125;\n\n来源\n组合 | 力扣（LeetCode）组合 | 题解（LeetCode）\n\n\n","categories":["LeetCode"],"tags":["Java","LeetCode","学习笔记","递归","回溯算法","深度优先搜索","组合"]},{"title":"删除排序数组中的重复项","url":"/blog/2020/09/18/remove-duplicates-from-sorted-array/","content":"\n题目描述给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。不要使用额外的数组空间，你必须在原地修改输入数组 并在使用 O(1) 额外空间的条件下完成。\n示例1:\n\n给定数组 nums = [1, 1, 2],函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 你不需要考虑数组中超出新长度后面的元素。\n\n示例2:\n\n给定 nums = [0, 0, 1, 1, 1, 2, 2, 3, 3, 4],函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。你不需要考虑数组中超出新长度后面的元素。\n\n说明:\n\n为什么返回数值是整数，但输出的答案是数组呢?请注意，输入数组是以「引用」方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。你可以想象内部操作如下:\n\n// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝int len = removeDuplicates(nums);// 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。for (int i = 0; i &lt; len; i++) &#123;    print(nums[i]);&#125;\n\n\n\n题解题目中是一个排序后的数组，那么相同的元素一定是排列在一起的，我们可以使用两个指针 i 和 j，我们不断的移动j指针，只要 nums[i]=nums[j]，我们就进行 j++ 操作，跳过重复项，直到 nums[i]≠nums[j] 的时候，说明遇到了下一个非重复项，于是我们就将 num[j] 的值复制到 num[i + 1] 的位置，接着重复此流程，遍历完全部数组。\npublic int removeDuplicates(int[] nums) &#123;    int i = 0;    for (int j = 1; j &lt; nums.length; j++) &#123;        if (nums[i] != nums[j]) &#123;            i++;            nums[i] = nums[j];        &#125;    &#125;    return i + 1;&#125;\n\n复杂度分析\n时间复杂度：O(n)，假设数组的长度是 n，那么 i 和 j 分别最多遍历 n 步。\n空间复杂度：O(1)。\n\n来源\n删除排序数组中的重复项 | 力扣（LeetCode）删除排序数组中的重复项 | 题解（LeetCode）\n\n\n","categories":["LeetCode"],"tags":["Java","LeetCode","学习笔记","数组","指针","双指针"]},{"title":"环形链表","url":"/blog/2020/10/09/linked-list-cycle/","content":"\n题目描述给定一个链表，判断链表中是否有环。如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。\n如果链表中存在环，则返回 true 。 否则，返回 false 。\n进阶：\n你能用 O(1)（即，常量）内存解决此问题吗？\n示例 1：\n\n\n输入：head = [3, 2, 0, -4], pos = 1输出：true解释：链表中有一个环，其尾部连接到第二个节点。\n\n\n\n题解比较简单的方法是遍历整个链表，将每个元素都加入到 HashSet 中，根据 HashSet 的没有重复元素的特性，当遇到重复的元素，说明遍历这个链表访问了重复的元素，即链表中有环。HashSet 是使用 HashMap 实现的，关于实现细节可以直接看源码。\n\n浅谈 HashMap | 笑话人生\n\npublic boolean hasCycle(ListNode head) &#123;    HashSet&lt;ListNode&gt; visit = new HashSet&lt;ListNode&gt;();    while (head != null) &#123;        if (!visit.add(head)) &#123;            return true;        &#125;        head = head.next;    &#125;    return false;&#125;class ListNode &#123;   int val;   ListNode next;   ListNode(int x) &#123;       val = x;       next = null; &#125;&#125;\n\n复杂度分析\n时间复杂度：O(N)，其中 N 是链表中的节点数。最坏情况下我们需要遍历每个节点一次。\n空间复杂度：O(N)，其中 N 是链表中的节点数。主要为哈希表的开销，最坏情况下我们需要将每个节点插入到哈希表中一次。\n\n快慢指针我们定义两个指针，一快一慢。慢指针每次只移动一步，而快指针每次移动两步。初始时，慢指针在位置 head，而快指针在位置 head.next。这样一来，如果在移动的过程中，快指针反过来追上慢指针，就说明该链表为环形链表。否则快指针将到达链表尾部，该链表不为环形链表。\npublic boolean hasCycle(ListNode head) &#123;    if (head == null || head.next == null) &#123;        return false;    &#125;    ListNode slow = head;    ListNode fast = head.next;    while (slow != fast) &#123;        if (fast == null || fast.next == null) &#123;            return false;        &#125;        slow = slow.next;        fast = fast.next.next;    &#125;    return true;&#125;\n\n复杂度分析\n时间复杂度：O(N)，其中 N 是链表中的节点数。\n当链表中不存在环时，快指针将先于慢指针到达链表尾部，链表中每个节点至多被访问两次。\n当链表中存在环时，每一轮移动后，快慢指针的距离将减小一。而初始距离为环的长度，因此至多移动 N 轮。\n\n\n空间复杂度：O(1)。我们只使用了两个指针的额外空间。\n\n来源\n环形链表 | 力扣（LeetCode）环形链表 | 题解（LeetCode）\n\n\n","categories":["LeetCode"],"tags":["Java","LeetCode","学习笔记","链表","哈希表","指针","双指针","HashSet"]},{"title":"填充每个节点的下一个右侧节点指针","url":"/blog/2020/10/15/populating-next-right-pointers-in-each-node/","content":"\n题目描述给定一个完美二叉树，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：\nstruct Node &#123;  int val;  Node *left;  Node *right;  Node *next;&#125;\n填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。初始状态下，所有 next 指针都被设置为 NULL。\n示例：\n\n\n\n输入：{“$id”:”1”,”left”:{“$id”:”2”,”left”:{“$id”:”3”,”left”:null,”next”:null,”right”:null,”val”:4},”next”:null,”right”:{“$id”:”4”,”left”:null,”next”:null,”right”:null,”val”:5},”val”:2},”next”:null,”right”:{“$id”:”5”,”left”:{“$id”:”6”,”left”:null,”next”:null,”right”:null,”val”:6},”next”:null,”right”:{“$id”:”7”,”left”:null,”next”:null,”right”:null,”val”:7},”val”:3},”val”:1}输出：{“$id”:”1”,”left”:{“$id”:”2”,”left”:{“$id”:”3”,”left”:null,”next”:{“$id”:”4”,”left”:null,”next”:{“$id”:”5”,”left”:null,”next”:{“$id”:”6”,”left”:null,”next”:null,”right”:null,”val”:7},”right”:null,”val”:6},”right”:null,”val”:5},”right”:null,”val”:4},”next”:{“$id”:”7”,”left”:{“$ref”:”5”},”next”:null,”right”:{“$ref”:”6”},”val”:3},”right”:{“$ref”:”4”},”val”:2},”next”:null,”right”:{“$ref”:”7”},”val”:1}解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。\n\n提示：\n\n你只能使用常量级额外空间。\n使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。\n\n\n\n按层遍历按层遍历是常规的思路，基本框架就是二叉树的按层遍历，这里使用两个队列 queue 记录二叉树的节点，queueLevel 记录二叉树节点所在的层。每次往 queue 队列添加节点的时候，同时记录当前节点所在的层数，遍历层的时候，如果当前节点的层等于下一个节点的层，则执行操作 node.next = nextNode 。最后层次遍历完全部节点后，即完成了填充每个节点的下一个右侧节点的操作。\npublic Node connect(Node root) &#123;        if (root == null) &#123;            return null;        &#125;        Queue&lt;Node&gt; queue = new LinkedList&lt;&gt;();        Queue&lt;Integer&gt; queueLevel = new LinkedList&lt;&gt;();        int curLevel = 1;        queue.offer(root);        queueLevel.offer(1);        while (!queue.isEmpty()) &#123;            Node node = queue.poll();            Node nextNode = queue.peek();            Integer level = queueLevel.poll();            Integer nextLevel = queueLevel.peek();            if (level != null &amp;&amp; level != curLevel) &#123;                curLevel = level;            &#125;            if (level == nextLevel) &#123;                node.next = nextNode;            &#125;            if (node.left != null) &#123;                queue.offer(node.left);                queueLevel.offer(curLevel + 1);            &#125;            if (node.right != null) &#123;                queue.offer(node.right);                queueLevel.offer(curLevel + 1);            &#125;        &#125;        return root;    &#125;&#125;class Node &#123;    public int val;    public Node left;    public Node right;    public Node next;    public Node() &#123;&#125;        public Node(int _val) &#123;        val = _val;    &#125;    public Node(int _val, Node _left, Node _right, Node _next) &#123;        val = _val;        left = _left;        right = _right;        next = _next;    &#125;&#125;;\n\n复杂度分析\n时间复杂度：O(N)。每个节点会被访问一次且只会被访问一次，即从队列中弹出，并建立 next 指针。\n空间复杂度：O(N)。这是一棵完美二叉树，它的最后一个层级包含 N/2 个节点。广度优先遍历的复杂度取决于一个层级上的最大元素数量。这种情况下空间复杂度为 O(N)。\n\n使用已有的 next 指针一棵树中，存在两种类型的 next 指针。\n\n第一种情况是连接同一个父节点的两个子节点。它们可以通过同一个节点直接访问到，因此执行下面操作即可完成连接。node.left.next = node.right\n\n第二种情况在不同父亲的子节点之间建立连接，这种情况不能直接连接。我们可以发现当前节点右节点的指针指向的是当前节点父节点 next 节点的左节点，如果父节点没有 next 节点，则指向 null。node.right.next = node.next != null ? node.next.left : null;\n\n\n\n\n这里我们使用递归可以很方便的解决上述问题。\npublic Node connect(Node root) &#123;    if (root == null) &#123;        return root;    &#125;    if (root.left != null) &#123;        root.left.next = root.right;        root.right.next = root.next != null ? root.next.left : null;        connect(root.left);        connect(root.right);    &#125;    return root;&#125;\n\n复杂度分析\n时间复杂度：O(N)，每个节点只访问一次。\n空间复杂度：O((logn)，不需要存储额外的节点。这里只有递归占用的空间，满足题目要求。\n\n来源\n填充每个节点的下一个右侧节点指针 | 力扣（LeetCode）填充每个节点的下一个右侧节点指针 | 题解（LeetCode）\n\n\n","categories":["LeetCode"],"tags":["Java","LeetCode","学习笔记","队列","递归","树","二叉树","深度优先搜索","广度优先搜索"]},{"title":"有序数组的平方","url":"/blog/2020/10/16/squares-of-a-sorted-array/","content":"\n题目描述给定一个按非递减顺序排序的整数数组 A，返回每个数字的平方组成的新数组，要求也按非递减顺序排序。\n示例 1：\n\n输入：[-4, -1, 0, 3, 10]输出：[0, 1, 9, 16, 100]\n\n示例 2：\n\n输入：[-7, -3, 2, 3, 11]输出：[4, 9, 9, 49, 121]\n\n\n\n双指针最简单的方法，我们可以将数组中的元素全部求平方，然后进行排序即可，但是这样操作空间复杂度和时间复杂度都较大，在此我们不多做赘述。我们观察数组的特性可以发现，数组是排序好的，这样我们就可以使用一个比较巧妙的方法进行计算，具体的，对于全正数的数组，直接平方后即满足题意，但是有负数的情况下，负数中越小的负数，计算的结果越大。正数中越大的正数计算的结果越大，题目要求平方后的数组依然是非递减顺序排序，于是我们可以定义两个指针分别指向 0 和 len - 1。不断的移动这两个指针，每次我们将平方后的较大的值逆序的放入数组中。最后完成计算，结果也将是非递减顺序。\npublic int[] sortedSquares(int[] A) &#123;    int len = A.length;    int[] ans = new int[len];    for (int i = 0, j = len - 1, pos = len - 1; i &lt;= j;) &#123;        if (A[i] * A[i] &gt; A[j] * A[j]) &#123;            ans[pos] = A[i] * A[i];            i++;        &#125; else &#123;            ans[pos] = A[j] * A[j];            j--;        &#125;        pos--;    &#125;    return ans;&#125;\n\n复杂度分析\n时间复杂度：O(n)，其中 n 是数组 A 的长度。\n空间复杂度：O(1)。\n\n来源\n有序数组的平方 | 力扣（LeetCode）有序数组的平方 | 题解（LeetCode）\n\n\n","categories":["LeetCode"],"tags":["Java","LeetCode","学习笔记","数组","指针","双指针"]},{"title":"划分字母区间","url":"/blog/2020/10/22/partition-labels/","content":"\n题目描述字符串 S 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。返回一个表示每个字符串片段的长度的列表。\n示例：\n\n输入：S = “ababcbacadefegdehijhklij”输出：[9, 7, 8]解释：划分结果为 “ababcbaca”, “defegde”, “hijhklij”。每个字母最多出现在一个片段中。像 “ababcbacadefegde”, “hijhklij” 的划分是错误的，因为划分的片段数较少。\n\n提示：\n\nS的长度在 [1, 500] 之间。\nS只包含小写字母 ‘a’ 到 ‘z’。\n\n\n\n贪心算法由于同一个字母只能出现在同一个片段，显然同一个字母的第一次出现的下标位置和最后一次出现的下标位置必须出现在同一个片段。我们从第一个字母开始遍历，初始的时候，我们认为划分的字符串就是当前字母，即 maxLen = 1，然后我们求当前字母的最后一次出现的下标 index。并更新当前划分的字符串最长长度为 maxLen = Math.max(index + 1, maxLen)。遍历的截止条件就是 i &lt; maxLen。说明已经满足了题目条件。接下来，我们只要递归的处理剩下的字符串即可。\nList&lt;Integer&gt; ans = new ArrayList&lt;&gt;();public List&lt;Integer&gt; partitionLabels(String S) &#123;    if (S == null || S.length() == 0) &#123;        return ans;    &#125;    int maxLen = 1;    for (int i = 0; i &lt; maxLen; i++) &#123;        int index = S.lastIndexOf(S.charAt(i));        maxLen = Math.max(index + 1, maxLen);    &#125;    ans.add(maxLen);    partitionLabels(S.substring(maxLen));    return ans;&#125;\n\n参考官方的解法后发现，其实以上代码有几处可以优化的点，首先就是，我们可以先遍历一遍字符串，求出每个字符最后一次出现的下标位置。在得到每个字母最后一次出现的下标位置之后，可以使用贪心算法和双指针的方法将字符串划分为尽可能多的片段，具体做法如下。\n\n从左到右遍历字符串，遍历的同时维护当前片段的开始下标 start 和结束下标 end，初始时 start = end = 0。\n对于每个访问到的字母 c，得到当前字母的最后一次出现的下标位置 end_c，则当前片段的结束下标一定不会小于 end_c，因此令 end = max(end, end_c)。\n当访问到下标 end 时，当前片段访问结束，当前片段的下标范围是 [start, end]，长度为 end − start + 1，将当前片段的长度添加到返回值，然后令 start = end + 1，继续寻找下一个片段。\n重复上述过程，直到遍历完字符串。\n\npublic List&lt;Integer&gt; partitionLabels(String S) &#123;    int[] last = new int[26];    int length = S.length();    for (int i = 0; i &lt; length; i++) &#123;        last[S.charAt(i) - &#x27;a&#x27;] = i;    &#125;    List&lt;Integer&gt; ans = new ArrayList&lt;Integer&gt;();    int start = 0;    int end = 0;    for (int i = 0; i &lt; length; i++) &#123;        end = Math.max(end, last[S.charAt(i) - &#x27;a&#x27;]);        if (i == end) &#123;            ans.add(end - start + 1);            start = end + 1;        &#125;    &#125;    return ans;&#125;\n\n复杂度分析\n时间复杂度：O(n)，其中 n 是字符串的长度。需要遍历字符串两次，第一次遍历时记录每个字母最后一次出现的下标位置，第二次遍历时进行字符串的划分。\n空间复杂度：O(Σ)，其中 Σ 是字符串中的字符集大小。这道题中，字符串只包含小写字母，因此 Σ = 26。\n\n来源\n划分字母区间 | 力扣（LeetCode）划分字母区间 | 题解（LeetCode）\n\n\n","categories":["LeetCode"],"tags":["Java","LeetCode","学习笔记","字符串","指针","双指针","递归","贪心算法"]},{"title":"二叉树的前序遍历","url":"/blog/2020/10/27/binary-tree-preorder-traversal/","content":"\n题目描述给你二叉树的根节点 root ，返回它节点值的 前序 遍历。\n示例 1：\n\n\n输入：root = [1, null, 2, 3]输出：[1, 2, 3]\n\n示例 2：\n\n输入：root = []输出：[]\n\n\n\n递归与非递归版本前序遍历的输出顺序就是根节点 -&gt; 左子树 -&gt; 右子树。前序遍历是先输出根节点的值，再去递归的输出左子树和右子树。整个遍历过程就是递归的性质，我们可以直接使用递归来完成计算。非递归版本其实是等阶的，只是我们将递归的栈显示的表达出来。下面是递归的版本解法，非递归的解法和二叉树的其他遍历方式可以参考我的另外一篇博客：二叉树的遍历\nList&lt;Integer&gt; ans = new ArrayList&lt;&gt;();public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123;    dfsPreOrder(root);    return ans;&#125;public void dfsPreOrder(TreeNode root) &#123;    if (root == null) &#123;        return;    &#125;    ans.add(root.val);    dfsPreOrder(root.left);    dfsPreOrder(root.right);&#125;\n\n复杂度分析\n时间复杂度：O(n)，其中 n 是二叉树的节点数。每一个节点恰好被遍历一次。\n空间复杂度：O(n)，为迭代过程中显式栈的开销，平均情况下为 O(logn)，最坏情况下树呈现链状，为 O(n)。\n\nMorris 遍历所谓再简单的题，通过看官方的题解，总能发现惊喜。有一种巧妙的方法可以在线性时间内，只占用常数空间来实现前序遍历。这种方法由 J. H. Morris 在 1979 年的论文「Traversing Binary Trees Simply and Cheaply」中首次提出，因此被称为 Morris 遍历。\nMorris 遍历的核心思想是利用树的大量空闲指针，实现空间开销的极限缩减。其前序遍历规则总结如下：\n\n新建临时节点，令该节点为 root；\n如果当前节点的左子节点为空，将当前节点加入答案，并遍历当前节点的右子节点；\n如果当前节点的左子节点不为空，在当前节点的左子树中找到当前节点在中序遍历下的前驱节点：\n如果前驱节点的右子节点为空，将前驱节点的右子节点设置为当前节点。然后将当前节点加入答案，并将前驱节点的右子节点更新为当前节点。当前节点更新为当前节点的左子节点。\n如果前驱节点的右子节点为当前节点，将它的右子节点重新设为空。当前节点更新为当前节点的右子节点。\n重复步骤 2 和步骤 3，直到遍历结束。\n\npublic List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123;    List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;();    if (root == null) &#123;        return res;    &#125;    TreeNode p1 = root, p2 = null;    while (p1 != null) &#123;        p2 = p1.left;        if (p2 != null) &#123;            while (p2.right != null &amp;&amp; p2.right != p1) &#123;                p2 = p2.right;            &#125;            if (p2.right == null) &#123;                res.add(p1.val);                p2.right = p1;                p1 = p1.left;                continue;            &#125; else &#123;                p2.right = null;            &#125;        &#125; else &#123;            res.add(p1.val);        &#125;        p1 = p1.right;    &#125;    return res;&#125;\n\n复杂度分析\n时间复杂度：O(n)，其中 n 是二叉树的节点数。没有左子树的节点只被访问一次，有左子树的节点被访问两次。\n空间复杂度：O(1)。只操作已经存在的指针（树的空闲指针），因此只需要常数的额外空间。\n\n来源\n二叉树的前序遍历 | 力扣（LeetCode）二叉树的前序遍历 | 题解（LeetCode）\n\n\n","categories":["LeetCode"],"tags":["Java","LeetCode","学习笔记","递归","树","二叉树","深度优先搜索"]},{"title":"求根到叶子节点数字之和","url":"/blog/2020/10/29/sum-root-to-leaf-numbers/","content":"\n题目描述给定一个二叉树，它的每个结点都存放一个 0-9 的数字，每条从根到叶子节点的路径都代表一个数字。例如，从根到叶子节点路径 1-&gt;2-&gt;3 代表数字 123。计算从根到叶子节点生成的所有数字之和。\n说明: 叶子节点是指没有子节点的节点。\n示例 1:\n输入: [1, 2, 3]    1   / \\  2   3输出: 25解释:从根到叶子节点路径 1-&gt;2 代表数字 12.从根到叶子节点路径 1-&gt;3 代表数字 13.因此，数字总和 = 12 + 13 = 25.\n\n示例 2:\n输入: [4, 9, 0, 5, 1]    4   / \\  9   0 / \\5   1输出: 1026解释:从根到叶子节点路径 4-&gt;9-&gt;5 代表数字 495.从根到叶子节点路径 4-&gt;9-&gt;1 代表数字 491.从根到叶子节点路径 4-&gt;0 代表数字 40.因此，数字总和 = 495 + 491 + 40 = 1026.\n\n\n\n深度优先搜索此题中，每个节点都对应一个 0-9 的数字，每条从根节点到叶子节点的路径都代表一个数字。我们只要通过深度优先搜索加回溯算法，求出所有路径组成的数字，再将所有数字相加求和即可。具体的，从根节点开始，遍历每个节点，如果遇到叶子节点，则将组成的数字保存，并进行回溯。如果不是叶子节点，则递归遍历子节点构造数字。\nList&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();LinkedList&lt;Integer&gt; item = new LinkedList&lt;&gt;();public int sumNumbers(TreeNode root) &#123;    dfsBuildNumbers(root);    int sum = 0;    for (List&lt;Integer&gt; list : res) &#123;        sum += parseInt(list);    &#125;    return sum;&#125;public void dfsBuildNumbers(TreeNode node) &#123;    if (node == null) &#123;        return;    &#125;    item.add(node.val);    if (node.left == null &amp;&amp; node.right == null) &#123;        res.add(new LinkedList&lt;&gt;(item));    &#125;    dfsBuildNumbers(node.left);    dfsBuildNumbers(node.right);    item.removeLast();&#125;public int parseInt(List&lt;Integer&gt; list) &#123;    int res = 0;    for (int n : list) &#123;        res = res * 10 + n;    &#125;    return res;&#125;\n\n其实，每个节点都对应一个数字，等于其父节点对应的数字乘以 10 再加上该节点的值（这里假设根节点的父节点对应的数字是 0）。只要计算出每个叶子节点对应的数字，然后计算所有叶子节点对应的数字之和，即可得到结果。可以通过深度优先搜索实现。\n\n\npublic int sumNumbers(TreeNode root) &#123;    return dfs(root, 0);&#125;public int dfs(TreeNode root, int prevSum) &#123;    if (root == null) &#123;        return 0;    &#125;    int sum = prevSum * 10 + root.val;    if (root.left == null &amp;&amp; root.right == null) &#123;        return sum;    &#125; else &#123;        return dfs(root.left, sum) + dfs(root.right, sum);    &#125;&#125;\n\n复杂度分析\n时间复杂度：O(n)，其中 n 是二叉树的节点个数。对每个节点访问一次。\n空间复杂度：O(n)，其中 n 是二叉树的节点个数。空间复杂度主要取决于递归调用的栈空间，递归栈的深度等于二叉树的高度，最坏情况下，二叉树的高度等于节点个数，空间复杂度为 O(n)。\n\n来源\n求根到叶子节点数字之和 | 力扣（LeetCode）求根到叶子节点数字之和 | 题解（LeetCode）\n\n\n","categories":["LeetCode"],"tags":["Java","LeetCode","学习笔记","递归","回溯算法","树","二叉树","深度优先搜索"]},{"title":"2022届实习生-蚂蚁集团-支付宝事业线","url":"/blog/2021/03/01/job-alipay/","content":"\n写在前面看到学弟学妹都很热情的联系我，所以我整理了这个博客，方便给大家答疑，并同步招聘动态给大家。先自我介绍一下，我是南大软院17届毕业的，目前在支付宝就职，我叫陈云龙【花名奇策】，作为学长，可以根据自己亲身经历，给学弟学妹量身定做春招实习建议。大家有任何的疑问或者职业咨询，随时都可以联系我。\n周围有其他感兴趣的小伙伴，都可以让他们联系我，哪怕不想投递这个部门，也可以听听学长的唠叨【实习经验、注意事项、简历建议、面试建议等】随时联系学长咨询各种实习内推问题呀～\n微信：cylong1016【加微信请备注姓名 + 学校 + 学历 + 学弟or学妹】\n\n\nPS：加学长微信，可以给你24小时的热心答疑服务！(oﾟvﾟ)ノ\n招聘招聘2022届蚂蚁集团-支付宝事业线-区域中台技术部招聘实习生啦（内推），如果有意愿来支付宝的，给自己一次机会简历速度砸过来吧，我帮助大家内推。后续可转正！\n招聘对象： 2021.11 - 2022.10毕业的应届毕业生。招聘流程： 简历投递-&gt;在线笔试及测评-&gt;面试-&gt;发放实习offer-&gt;实习入职岗位类型： Java研发、数据研发、产品经理，欢迎加入钉钉群交流：31091227工作地点： 杭州、上海、成都简历请发送到邮箱： chenyunlong.cyl@antgroup.com注意简历命名格式： 姓名 + 学校 + 手机号 + 邮箱\n附： 投递简历后学长将把关简历，提供修改建议，并提供实习问题咨询及职业指导，简历快快砸过来～\n\n\n关于我们蚂蚁集团是中国最大的移动支付平台支付宝的母公司，也是全球领先的金融科技开放平台，致力于以科技推动包括金融服务业在内的全球现代服务业的数字化升级，携手合作伙伴为消费者和小微企业提供普惠、绿色、可持续的服务，为世界带来微小而美好的改变，用科技让普通人和小企业，享受平等的金融和生活服务。未来三年，支付宝将携手5万家服务商，帮助4000W服务业商家完成数字化升级。\n我们区域中台技术部正式为了这一目标而诞生。核心团队来自蚂蚁两大超域的主架构。我们用工程、数据、算法、分布式架构等能力，为区域化作战提供：数字化的指挥决策系统、场景覆盖的销售及技术交付系统、区域化运营及招商技术。为推进百城的数字化提供完善的技术支持和保障。\n为什么加入我们\n\n有数据：支付宝万亿级规模交易/营销数据。\n有挑战：大型分布式系统和大数据应用场景。\n有影响力：支付宝核心团队，各路领域专家和高手。\n有成长：快速成长的通道，助力成长为技术领域大牛。\n\n期待你的加入，助力你成长为技术大牛！\n春招问题汇总整理了下大家问我的问题，有漏的或者后续有其他问题也都可以随时联系我。\nQ：内推投了大概多久面试？内推系统什么时候开放？A：目前是收集简历阶段，内推系统会在3月8号开启，之前给我发简历的同学，我就会投递到系统中，这个时候你就会收到一个我（陈云龙）内推邮件的，你点击确认后就进入后续的春招笔试、面试流程。第一批笔试是3月9日开始，每周两次，之后也会有面试官联系你安排面试。\nQ：内推投递简历截止时间？A：校招系统内推投递通道全年开放，可以长期推荐，主要集中在3-4月。越早投递越有优势～不要因为练题等原因错过最佳投递时间，毕竟机会总是留给有准备的人。\nQ：内推同时只能投一个部门？A：是的，如果同时找多个学长学姐内推，投递多个部门，最后可能收到多个内推邮件，只能确认一个部门，只能走一个部门的面试流程。A: 校招系统改版，每位同学投递，可以选择三个意向部门。系统默认会把首次内推该简历的同学所在的BG推荐为该学生第一志愿，学生保留修改的权力；学生可自主填写二志愿和三志愿。当前志愿不通过后，会通过一些条件及学生意愿，流转到下一个志愿。\nQ：内推没过的话还能继续投其他部门么？A：内推如果没通过，大家还是可以继续去阿里官网，投递其他部门的。（内推和官网申请各有一次机会）A：参考上一条答疑，新系统上线后，就是一次投递三个部门了。不分内推和网申了。\nQ：新系统上线，哪些同学会收到填写意向的邮件？\n\n此前已在官网投递，且处于“新投递”状态下的同学（可登录官网个人中心查看），请留意自己的邮箱，系统会发送意向填写邮件。\n此前已经内推的同学，如果面试未通过，我们会发送意向邮件，同学可以补填第二和第三志愿。\n目前已经被回绝的同学，也将收到填写意向的邮件，可以补填第二及第三志愿。\n\nQ：实习待遇？A：我们会提供具有市场竞争力的薪酬（不会亏待大家滴），其他的福利如餐补、房补、交通补贴、入职酒店住宿等会根据同学的实际情况按照公司标准给到大家，具体的数字面试通过后HRG会和大家沟通~\nQ：什么时候实习？A：拿到实习Offer后，实习时间可以沟通，随时来实习。如果有意外情况无法来实习，后续也会有秋季校招直通面试（前面的面试结果都会保留）。\nQ：实习可能直接发正式Offer？A：实习后会有述职，评定是否发正式的校招Offer。\nQ：笔试题型是什么样的？有没有编程机试，限不限语言？笔试是统一的么？A：2道在线编程题，知识点为计算机学科基础知识点，如动态规划、字符串、数学问题等，不区分岗位，不区分语言。所有岗位每场考试考同一套题目。还有一块是测评，主要有一些计算、推理，考察逻辑思维等。\nQ：实习生会有同事带么？A：每个人入职都会指定专门的师兄带你，熟悉阿里的文化、生活、熟悉项目组业务，指导你工作上的事情，让你更快的提升自己。除了师兄以外，任何问题都可以找周围的同事，每个人都会愿意为你解答的~\nQ：有同学是海外读书，回国需要隔离，隔离期间能否远程实习？A：目前集团没有远程实习政策，后续是否有新的政策，或者其他特殊情况可以远程实习，可以拿到offer后和HR沟通。\nQ：要怎么查看面试进展？A：请进入阿里巴巴校招官网→个人中心查看。【3月8号开放】\nQ：还有N个无法解决的问题？A：有任何问题，可在工作日9:00-12:00、13:00-18:00期间拨打校招热线咨询：0571-81595981。也可咨询校园小蜜人工客服：校园招聘官网右侧→校园小蜜→人工客服\n你们可能的担心、疑虑：\n\n如果后续不考虑来我们部门，可以不点我的内推确认邮件，就不会走春招流程；\n如果想多些时间准备笔试、面试，那么笔试、面试时间也是可以自己决定的；投递简历、笔试、面试并没有截止时间，目前系统会一直开放的。想晚一点点击确认邮件，想晚一点笔试、想晚一点面试，都不会有影响，想给自己充分的准备时间，都可以由自己决定。但是建议大家在3月份，最晚4月份搞定这些事情，因为不清楚后面会不会有什么政策改变，比如部门人招满了，可能后续就不招了。越早投递越有优势～不要因为练题等原因错过最佳投递时间。\n越早投递简历，越早内推，越早面试，越早拿offer，越早安心。\n后续拿到offer，什么时候实习，也是可以自由决定的。\n\n总结重点： 大家有简历现在就可以投递了！现在就可以投递了！现在就可以投递了！不会有任何的后顾之忧！简历后续也是可以随时更新的！\n经验之谈\n大学生实习是一个很好的机会，特别是大公司的实习，千万不要错过，首先实习是很容易拿到正式校招Offer的。如果后续想去其他公司，那么有实习经历，是很大的加分项。\n机会总是给有准备的人，不要等待，要主动出击，先写好简历就是开始，接下来就可以准备，不知道准备啥，就可以看看你简历里写的啥，深入了解，很多面试官都会根据简历问你问题的。不知道简历写啥，可以看平时学校里做的项目（课内作业、课外项目，团队项目写写自己在项目中担任的角色，负责的模块），参加的竞赛，学习的课程知识，有没有发表过论文，比赛获得过什么奖，有没有自己的技术博客，参加过什么交流，讲座，开源项目等等。非技术相关的也可以写，比如社团，学生会的工作职责，参加某某公益，社会项目等等，有没有奖学金，读了哪些书。都可以写，有什么写什么（但是不要太多，太啰嗦，挑亮点写）。\n面试也可以很快的提升自己，不要怕挂，也不要担心其他的，无论通过与否，都会积累很有价值的经验，也能快速的发现自己的不足。\n自信点，大家都是从学校出来的，你可能觉得，要学的太多了，这也不会，那也不会，学无止境，大学不可能都被你学完，学会的。只要认真准备，认真学习了，把大学里的知识学会，就已经超越很多人了。\n很多同学都会问面试可能都面试些什么，我虽然没有做过面试官，但是我被面试过啊，可以跟大家分享下。 a. 基础的信息，比如成绩、竞赛、奖学金、社团、学生会、课外实践，这些面试官可能会简单提及下，确认下实际情况（这个可能是HR面试官会问） b. 技术问题就是一些基础知识、由浅入深，就看你都掌握程度。简历里写的优先深入了解。面试官可能还会扩散问，这个时候就看自己知识的广度和深度了。 c. 项目面试都话，会问你项目为了解决什么问题，在项目中担任什么角色，负责什么部分，用了什么技术，过程中遇到了什么困难，怎么解决的，最后这个项目做完，有哪些收获总结，自己得到了哪些成长。 d. 自己的优点，缺点，自己的价值，自己对未来的规划。 e. 最后有没有什么问题要问面试官。\n知乎上有几篇下如何写简历的文章感觉可借鉴，可以参考：\nhttps://www.zhihu.com/question/26265144https://www.zhihu.com/question/23734172\n\n\n\n最后祝愿学弟学妹们都能拿到自己满意的实习Offer(ง •_•)ง\n本文档也会不断的更新，欢迎大家推荐给周围的小伙伴呀(●ˇ∀ˇ●)\n\n","categories":["招聘"],"tags":["招聘","实习生"]},{"title":"国内如何注册 ChatGPT 账号","url":"/blog/2023/10/08/sign-up-chatgpt/","content":"\n前言OpenAI 公司是一家位于美国的人工智能研究与开发公司，成立于2015年，致力于推动人工智能技术的发展。该公司的使命是确保人工智能技术对整个人类社会的利益产生积极影响。OpenAI 在自然语言处理领域取得了重要突破，其中的一个产品就是 ChatGPT。ChatGPT 是 OpenAI 开发的一款强大的自然语言处理模型。它可以理解和生成人类语言，能够回答问题、执行任务、进行对话等多种应用。ChatGPT 可以用于在线客服、智能助手、内容生成、教育支持等众多领域，为用户提供自然而流畅的文本交互体验。OpenAI 不断改进和扩展 ChatGPT，以提供更准确、有用和安全的服务。这一技术的发展代表了人工智能在改善人们的生活、工作和沟通方面的潜力，并在多个领域产生了广泛的应用。\n在国内并不支持 OpenAI 账号注册，多数会提示：OpenAI&#39;s services are not available in your country，查阅了一些资料后发现以下方式可以注册成功。\n前期准备\n国外梯子，没有的话可以参考 站在 Shadowsocks 的肩膀上发现精彩的世界\n国外手机号，没有的话可以通过 SMS-Activate 购买一个\n\n\n\n注册ChatGPT账号\n访问 OpenAI 右上角注册（建议使用国外IP），可以使用 Google、Microsoft、Apple 或者直接使用邮箱注册\n这里输入你国外的手机号，如果没有的话，参考下文注册 SMS-Activate\nOpenAI 产品列表，选择 ChatGPT（DALL·E有兴趣可以玩玩，可以生成与文本描述相关的图像，收费）\n初体验 ChatGPT，免费的是 ChatGPT-3.5，想要使用 ChatGPT-4 需要 ChatGPT Plus，收费20$/月\n\n\n\n注册短信服务\n打开 SMS-Activate 右上角注册登录，登录后右上角充值\n往下拉选择支付宝，最低充值2$（吐槽一下，之前没有最低充值额度的，估计是发现了商机😒）\n左侧服务选择搜索 OpenAI\n国家选择印度并购买\n此时你就有了一个可以接收验证码的国外手机号，用于后续注册 ChatGPT 使用，此号码在20分钟有效期内并且未使用的情况下可以退款取消注册，如果注册 ChatGPT 过程中一直收不到验证码，可以多试几次，我是一次就成功了哈哈哈😁\n\n\n\n下载 ChatGPT IOS APP参考：国内如何注册国外 Apple ID | 笑话人生\n开通 ChatGPT Plus想要使用 ChatGPT-4 ，需要开通 Plus 订阅，网上找了些资料，还比较复杂，先挖个坑，待实操一遍再埋坑，可以先参考：\n\n国内开通 ChatGPT Plus 保姆级教程ChatGPT 怎样升级 Plus 订阅\n\n一些感想自从接触 ChatGPT 之后，平时写文章，写代码都会想到先问问 ChatGPT，确实能得到很多不错的答案。网络上各行各业的人使用后发出感叹，大部分人要失业了。我认为 ChatGPT 不会让大部分人失业，但是会让不会用 ChatGPT 的人失业。\n\n\n参考资料\nOpenAI 推出超神 ChatGPT 注册攻略来了 | V2EX最近很火的 ChatGPT，带你注册体验全攻略 | 腾讯云开发者社区如何编程调用 OpenAI 的 ChatGPT API 接口 | Read dev Docs 博客\n\n\n","categories":["人工智能"],"tags":["人工智能","OpenAI","ChatGPT","AIGC","AGI"]},{"title":"国内如何注册国外 Apple ID","url":"/blog/2023/10/10/sign-up-apple-id/","content":"\n前言最近喜欢玩 ChatGPT，奈何手机 IOS 版的 ChatGPT 没有上架中国大陆区 App Store，所以折腾下想要注册美国的 Apple ID，同时也方便下载一些其他有用的软件，比如 PayPal 和 Shadowrocket，话不多说，操作起来也是很简单的 👻\n\n\n如何注册\n首先去 Apple 官网 创建你的 Apple ID，这里 国家或地区 选择 美国，其他的填写你的真实信息，手机号可以填写中国大陆手机号，用于后续接收验证码，验证通过后你就获得了一个国外的 Apple ID ，但是还没结束。\n用你刚刚注册的 Apple ID 登录你的苹果设备，我用我的 iPad 做了小白鼠，第一次登录，有各种验证和同意条款等操作，确认即可。\n设置 里点击你的头像，找到 付款与配送，编辑配送地址（如果默认跳转到添加付款方式页面，回到上一页即可），这里要选择一个美国的地址，可以通过 美国地址生成器（链接打不开的话直接去谷歌或者百度搜索关键字）随机生成填入后保存。\n接下来就可以尽情的在 App Store 里下载各种神秘的软件啦（第3步没设置的话，这里下载软件的时候也是会提示设置送货地址的）\n\n\n\n参考\n国内如何注册 ChatGPT 账号 | 笑话人生手把手教你注册国外apple ID（超简单） | 知乎如何创建海外 Apple ID | imToken Fans\n\n\n","categories":["Apple"],"tags":["IOS","ChatGPT","Apple"]},{"title":"利用完全二叉树特性递归统计节点数（LeetCode 222）","url":"/blog/2025/02/06/count-complete-tree-nodes/","content":"\n题目描述给你一棵 完全二叉树 的根节点 root ，求出该树的节点个数。\n说明:完全二叉树：除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层（从第 0 层开始），则该层包含 1 ~ 2h 个节点。\n     1   /   \\  2     3 / \\   /4   5 6\n\n示例 1:\n\n输入：root = [1,2,3,4,5,6]输出：6\n\n示例 2:\n\n输入：root = []输出：0\n\n示例 3:\n\n输入：root = [1]输出：1\n\n提示:\n\n树中节点的数目范围是 [0, 5 * 10^4]\n0 &lt;= Node.val &lt;= 5 * 10^4\n题目数据保证输入的树是 完全二叉树\n\n\n\n思路分析如果是普通二叉树的话，最直接的方法就是递归或者迭代遍历每个节点，然后统计个数，这样时间复杂度是 O(n)，其中 n 是树的节点总数。空间复杂度是 O(h)，其中 h 是树的高度。\npublic int countNodes(TreeNode root) &#123;    if (root == null) &#123;        return 0;    &#125;    return 1 + countNodes(root.left) + countNodes(root.right);&#125;\n\n但这是一个普适的解法，对于此题给的完全二叉树的特点没有利用起来，我们先了解一下 满二叉树 的概念：一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是满二叉树，满二叉树的节点总数是 (2^h) - 1 \n     1   /   \\  2     3 / \\   / \\4   5 6   7\n\n而完全二叉树的特点是除了最后一层外，其余层都是满的，并且最后一层的节点尽可能靠左。因此，可以利用这个特性来高效计算节点数，而不是普通的遍历方法。首先计算左子树高度 left 和右子树高度 right，接下来比较 left 和 right。\n\n如果两者相等，说明左子树是满的，此时左子树的节点数为 2^left - 1，加上根节点，总共是 2^left。然后递归计算右子树的节点数。\n如果 left 不等于 right，则说明右子树是满的，但层数比左子树少一层，所以右子树的节点数是 2^right - 1，加上根节点，再递归计算左子树的节点数。\n\n这里的关键在于，当左右子树高度相等时，左子树一定是满的，可以快速计算其节点数，而无需递归下去；反之，右子树是满的，可以同样处理。\npublic int countNodes(TreeNode root) &#123;    if (root == null) &#123;        return 0;    &#125;    // 计算左子树高度    int left = countLevel(root.left);    // 计算右子树高度    int right = countLevel(root.right);    if (left == right) &#123;        // 左子树是满的，直接计算左子树节点数 (2^left)，递归计算右子树        return countNodes(root.right) + (1 &lt;&lt; left);    &#125; else &#123;        // 右子树是满的，直接计算右子树节点数 (2^right)，递归计算左子树        return countNodes(root.left) + (1 &lt;&lt; right);    &#125;&#125;private int countLevel(TreeNode root) &#123;    int level = 0;    while (root != null) &#123;        // 完全二叉树的高度由最左路径决定        level++;        root = root.left;    &#125;    return level;&#125;\n\n复杂度分析\n时间复杂度：O((logN)^2)，每次递归调用 countLevel 的时间为 O(h)（h 是当前子树高度），递归深度为树的高度 O(logN)（完全二叉树高度为 logN）。\n空间复杂度：递归深度为树的高度 O(logN)。\n\n来源\n222. 完全二叉树的节点个数 | 力扣（LeetCode）\n\n\n","categories":["LeetCode"],"tags":["Java","LeetCode","学习笔记","递归","树","二叉树","LeetCode简单","完全二叉树","满二叉树"]},{"title":"数学推导唯一二叉搜索树数量：动态规划实现（LeetCode 96）","url":"/blog/2025/02/17/unique-binary-search-trees/","content":"\n题目描述给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。\n示例 1:\n\n\n输入：n = 3输出：5\n\n示例 2:\n\n输入：n = 1输出：1\n\n提示:\n\n1 &lt;= n &lt;= 19\n\n\n\n动态规划二叉搜索树的特点是，对于每个节点来说，左子树的所有节点的值都小于它，右子树的所有节点的值都大于它。为了求解由 n 个节点组成的二叉搜索树的数量，可以使用动态规划的方法。二叉搜索树的中序遍历是有序的，因此结构数目仅与节点数量有关。\n假设以 i 为根节点，那么左子树由 1 到 i-1 组成，共有 i-1 个节点，右子树由 i+1 到 n 组成，共有 n-i 个节点。所以，以 i 为根的 BST 数目等于左子树的数目乘以右子树的数目。设 G(n) 为 n 个节点组成的 BST 数目，以不同根节点划分左右子树，总数目为左右子树数目的乘积之和。递推公式：G(n) = G(0)G(n-1) + G(1)G(n-2) + ... + G(n-1)G(0)，其中 G(0)=1。\npublic int numTrees(int n) &#123;    int[] dp = new int[n + 1];    dp[0] = 1;    // 遍历计算 dp[1] 到 dp[n]    for (int i = 1; i &lt;= n; i++) &#123;        // 枚举左子树的节点数 j        for (int j = 0; j &lt; i; j++) &#123;            // 左子树 j 节点，右子树 (i-j-1) 节点            dp[i] += dp[j] * dp[i - j - 1];        &#125;    &#125;    return dp[n];&#125;\n\n注：当 n ≥ 19 时，结果会超出 int 范围，需改用 long 或 BigInteger。\n复杂度分析\n时间复杂度：O(n²)。需要双层循环，外层循环 n 次，内层循环 i 次，总操作次数为 n(n+1)/2，因此总时间复杂度为 O(n²)。\n空间复杂度：O(n)。使用长度为 n+1 的数组存储中间结果。\n\n卡特兰数二叉搜索树的数目实际上是一个 卡特兰数 问题，卡特兰数是一个数列，满足递推关系 C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)，并且初始条件 C(0)=1。这和本题的二叉搜索树的数量问题是一样的，所以此问题其实已经接触过卡特兰数的一个应用案例。卡塔兰数更便于计算的定义如下:\n\n\npublic int numTrees(int n) &#123;    // 我们在这里需要用 long 类型防止计算过程中的溢出    long C = 1;    for (int i = 0; i &lt; n; ++i) &#123;        C = C * 2 * (2 * i + 1) / (i + 2);    &#125;    return (int) C;&#125;\n\n复杂度分析\n时间复杂度：O(n)。其中 n 表示二叉搜索树的节点个数。我们只需要循环遍历一次即可。\n空间复杂度：O(1)。我们只需要常数空间存放若干变量。\n\n来源\n96. 不同的二叉搜索树 | 力扣（LeetCode）\n\n\n","categories":["LeetCode"],"tags":["Java","LeetCode","学习笔记","动态规划","树","二叉树","二叉搜索树","LeetCode中等","数学公式"]},{"title":"树连接操作后的目标节点计算（LeetCode 2920）","url":"/blog/2025/02/28/maximize-the-number-of-target-nodes-after-connecting-trees-i/","content":"\n题目描述有两棵 无向树，分别有 n 和 m 个树节点。两棵树中的节点编号分别为 [0, n - 1] 和 [0, m - 1] 中的整数。\n给你两个二维整数 edges1 和 edges2 ，长度分别为 n - 1 和 m - 1 ，其中 edges1[i] = [ai, bi] 表示第一棵树中节点 ai 和 bi 之间有一条边，edges2[i] = [ui, vi] 表示第二棵树中节点 ui 和 vi 之间有一条边。同时给你一个整数 k 。如果节点 u 和节点 v 之间路径的边数小于等于 k ，那么我们称节点 u 是节点 v 的 目标节点 。一个节点一定是它自己的 目标节点 。\n请你返回一个长度为 n 的整数数组 answer ，answer[i] 表示将第一棵树中的一个节点与第二棵树中的一个节点连接一条边后，第一棵树中节点 i 的目标节点数目的最大值 。\n注意：每个查询相互独立。意味着进行下一次查询之前，你需要先把刚添加的边给删掉。\n示例 1:\n\n输入：edges1 = [[0, 1], [0, 2], [2, 3], [2, 4]], edges2 = [[0, 1], [0, 2], [0, 3], [2, 7], [1, 4], [4, 5], [4, 6]], k = 2输出：[9, 7, 9, 8, 8]解释：\n\n对于 i = 0 ，连接第一棵树中的节点 0 和第二棵树中的节点 0 。\n对于 i = 1 ，连接第一棵树中的节点 1 和第二棵树中的节点 0 。\n对于 i = 2 ，连接第一棵树中的节点 2 和第二棵树中的节点 4 。\n对于 i = 3 ，连接第一棵树中的节点 3 和第二棵树中的节点 4 。\n对于 i = 4 ，连接第一棵树中的节点 4 和第二棵树中的节点 4 。\n\n\n\n\n示例 2:\n\n输入：edges1 = [[0, 1], [0, 2], [0, 3], [0, 4]], edges2 = [[0, 1], [1, 2], [2, 3]], k = 1输出：[6, 3, 3, 3, 3]解释：对于每个 i ，连接第一棵树中的节点 i 和第二棵树中的任意一个节点。\n\n\n\n提示:\n\n2 &lt;= n, m &lt;= 1000\nedges1.length == n - 1\nedges2.length == m - 1\nedges1[i].length == edges2[i].length == 2\nedges1[i] = [ai, bi]\n0 &lt;= ai, bi &lt; n\nedges2[i] = [ui, vi]\n0 &lt;= ui, vi &lt; m\n输入保证 edges1 和 edges2 都表示合法的树。\n0 &lt;= k &lt;= 1000\n\n\n\n思路分析\n第一棵树内部目标节点计算：对于第一棵树中的每个节点 i，计算在不添加新边的情况下，距离 i 不超过 k 的节点数（包括自身）。这部分节点不受添加边的影响，因为新边连接的是另一棵树。\n第二棵树内部目标节点计算：对于第二棵树中的每个节点 j，计算距离 j 不超过 k-1 的节点数（包括自身）。这是因为添加边后，从第一棵树节点 i 到第二棵树节点 v 的路径为 i → a → b → v，其中 a 和 b 是添加边的两个端点，路径长度为 d1(i, a) + 1 + d2(b, v)。为最大化第二棵树部分的贡献，选择 a = i（即连接点选在 i），这样路径长度简化为 1 + d2(b, v)。因此，第二棵树部分最多贡献距离 b 不超过 k-1 的节点数。\n最大化第二棵树贡献：取第二棵树中所有节点在距离 k-1 内节点数的最大值 maxCount2。\n合并结果：对于第一棵树中的每个节点 i，其目标节点最大值为 count1[i] + maxCount2，其中 count1[i] 是第一棵树内部距离 i 不超过 k 的节点数。\n\npublic int[] maxTargetNodes(int[][] edges1, int[][] edges2, int k) &#123;    // 计算第一课无向树中每个节点的目标节点数    int[] count1 = count(edges1, k);    // 计算第一课无向树中每个节点的目标节点数    int[] count2 = count(edges2, k - 1);    // 计算第二课无向树中每个节点的目标节点数的最大值    int maxCount2 = Arrays.stream(count2).max().orElse(0);    int n = edges1.length + 1;    int[] result = new int[n];    for (int i = 0; i &lt; n; i++) &#123;        result[i] = count1[i] + maxCount2;    &#125;    return result;&#125;public int[] count(int[][] edges, int k) &#123;    int n = edges.length + 1;    // 构建无向树    List&lt;List&lt;Integer&gt;&gt; graph = new ArrayList&lt;&gt;(n);    for (int i = 0; i &lt; n; i++) &#123;        graph.add(new ArrayList&lt;&gt;());    &#125;    for (int[] edge : edges) &#123;        int u = edge[0], v = edge[1];        graph.get(u).add(v);        graph.get(v).add(u);    &#125;    int[] result = new int[n];    for (int i = 0; i &lt; n; i++) &#123;        result[i] = dfs(i, -1, graph, k);    &#125;    return result;&#125;public int dfs(int u, int parent, List&lt;List&lt;Integer&gt;&gt; graph, int k) &#123;    if (k &lt; 0) &#123;        return 0;    &#125;    int count = 1;    for (int v : graph.get(u)) &#123;        // 防止回溯到父节点，避免无限递归和重复计数        if (v == parent) &#123;            continue;        &#125;        count += dfs(v, u, graph, k - 1);    &#125;    return count;&#125;\n\n复杂度分析\n时间复杂度：O(n² + m²)，其中 n 和 m 分别是两棵树的节点数。计算 count1 和 count2 时，对每个节点进行 BFS，每次 BFS 最坏 O(n) 或 O(m)，总时间复杂度为 O(n²) 和 O(m²)。\n空间复杂度：O(n + m)，用于存储树的邻接表 O(n + m) 和 BFS 的队列及访问标记 O(n) 或 O(m)。\n\n来源\n3372. 连接两棵树后最大目标节点数目 Ⅰ | 力扣（LeetCode）\n\n\n","categories":["LeetCode"],"tags":["Java","LeetCode","学习笔记","树","深度优先搜索","LeetCode中等","无向树"]},{"title":"双指针法原地移动零元素（LeetCode 283）","url":"/blog/2025/03/01/move-zeroes/","content":"\n题目描述给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。\n请注意，必须在不复制数组的情况下原地对数组进行操作。\n示例 1:\n\n输入：nums = [0, 1, 0, 3, 12]输出：[1, 3, 12, 0, 0]\n\n示例 2:\n\n输入：nums = [0]输出：[0]\n\n提示:\n\n1 &lt;= nums.length &lt;= 10^4\n-2^31 &lt;= nums[i] &lt;= 2^31 - 1\n\n\n\n双指针（交换法）使用两个指针，left 和 right，right 指针用于遍历数组，left 指针用于指向当前已经处理好的序列的尾部（即非零序列的末尾，也就是下一个非零元素要放置的位置）。当 right 指针遇到非零元素时，就将其与 left 指针指向的元素交换，然后 left 指针右移。这样，非零元素被逐渐交换到前面，而 0 被交换到后面。\n注意：交换后，left 指向的位置可能是 0（如果之前 left 指向的是 0）或者非零（如果 left 和 right 相同，即自己交换自己，此时不会改变），但无论如何，left 指针的左侧都是非零元素，并且保持了原有顺序。\npublic void moveZeroes(int[] nums) &#123;    int left = 0;    for (int right = 0; right &lt; nums.length; right++) &#123;        if (nums[right] != 0) &#123;            // 避免不必要的自交换            if (left != right) &#123;                int temp = nums[left];                nums[left] = nums[right];                nums[right] = temp;            &#125;            left++;        &#125;    &#125;    // 数组变化过程    // 输入：[0, 1, 0, 3, 12]    // [0, 1, 0, 3, 12]    // [1, 0, 0, 3, 12]    // [1, 0, 0, 3, 12]    // [1, 3, 0, 0, 12]    // [1, 3, 12, 0, 0]&#125;\n\n执行过程（以 [0, 1, 0, 3, 12] 为例）[0, 1, 0, 3, 12] - right=0: 0 → 跳过[1, 0, 0, 3, 12] - right=1: 1 → 与 left(0) 交换[1, 0, 0, 3, 12] - right=2: 0 → 跳过[1, 3, 0, 0, 12] - right=3: 3 → 与 left(1) 交换[1, 3, 12, 0, 0] - right=4: 12 → 与 left(2) 交换\n复杂度分析\n时间复杂度：O(n)，只需一次遍历数组。\n空间复杂度：O(1)，原地操作，仅使用常数空间。\n\n双指针（覆盖法）使用一个指针 cur，表示当前非零元素应该存放的位置。遍历数组，当遇到非零元素时，将其复制到 cur 位置，然后 cur 指针右移。遍历完成后，所有非零元素都被按顺序移动到了数组的前部，然后将 cur 之后的元素全部置为 0。\npublic void moveZeroes(int[] nums) &#123;    int cur = 0;    // 第一阶段：移动非零元素    for (int i = 0; i &lt; nums.length; i++) &#123;        if (nums[i] != 0) &#123;            nums[cur++] = nums[i];        &#125;    &#125;    // 第二阶段：填充零    while (cur &lt; nums.length) &#123;        nums[cur++] = 0;    &#125;    // 数组变化过程    // 输入：[0, 1, 0, 3, 12]    // 输入：[0, 1, 0, 3, 12]    // [0, 1, 0, 3, 12]    // [1, 1, 0, 3, 12]    // [1, 1, 0, 3, 12]    // [1, 3, 0, 3, 12]    // [1, 3, 12, 3, 12]    // [1, 3, 12, 0, 0]&#125;\n\n执行过程（以 [0, 1, 0, 3, 12] 为例）\n第一阶段：\n\ni=0: 0 → 跳过\ni=1: 1 → nums[0]=1 (cur=1)\ni=2: 0 → 跳过\ni=3: 3 → nums[1]=3 (cur=2)\ni=4: 12 → nums[2]=12 (cur=3)\n\n第二阶段：\n\n填充 nums[3]=0, nums[4]=0\n结果: [1, 3, 12, 0, 0]\n\n复杂度分析\n时间复杂度：O(n)，两次独立遍历数组。\n空间复杂度：O(1)，原地操作，仅使用常数空间。\n\n总结两种方法都有效地解决了移动零的问题：\n\n交换法更高效，单次遍历完成操作，代码更简洁\n覆盖法写操作更少，但需要两次遍历\n\n在实际应用中，交换法通常是更优选择，因为它只需要一次遍历且代码更简洁。理解这两种双指针策略有助于解决类似的数组重排问题，如移除指定元素、删除排序数组中的重复项等。\n来源\n283. 移动零 | 力扣（LeetCode）\n\n\n","categories":["LeetCode"],"tags":["Java","LeetCode","学习笔记","数组","双指针","LeetCode简单"]},{"title":"滑动窗口求解异位词：双指针与字符频次统计（LeetCode 438）","url":"/blog/2025/03/02/find-all-anagrams-in-a-string/","content":"\n题目描述给定两个字符串 s 和 p，找到 s 中所有 p 的 异位词 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。\n字母异位词 是通过重新排列不同单词或短语的字母而形成的单词或短语，并使用所有原字母一次。\n示例 1:\n\n输入：s = &quot;cbaebabacd&quot;, p = &quot;abc&quot;输出：[0, 6]解释:起始索引等于 0 的子串是 &quot;cba&quot;, 它是 &quot;abc&quot; 的异位词。起始索引等于 6 的子串是 &quot;bac&quot;, 它是 &quot;abc&quot; 的异位词。\n\n示例 2:\n\n输入：s = &quot;abab&quot;, p = &quot;ab&quot;输出：[0, 1, 2]解释:起始索引等于 0 的子串是 &quot;ab&quot;, 它是 &quot;ab&quot; 的异位词。起始索引等于 1 的子串是 &quot;ba&quot;, 它是 &quot;ab&quot; 的异位词。起始索引等于 2 的子串是 &quot;ab&quot;, 它是 &quot;ab&quot; 的异位词。\n\n提示:\n\n1 &lt;= s.length, p.length &lt;= 3 * 10^4\ns 和 p 仅包含小写字母\n\n\n\n固定窗口滑动 + 计数数组\n初始化处理：\n\n\n若 s 长度小于 p，直接返回空列表。\n创建两个长度为 26 的数组 pCount 和 sCount，分别统计 p 的字符频次和 s 中前 p.length() 个字符的频次。\n\n\n首次匹配检查：\n\n\n比较 pCount 和 sCount，若相等说明起始索引 0 是异位词，加入结果列表。\n\n\n滑动窗口：\n\n\n窗口长度固定为 p.length()，每次右移一位：\n移除窗口最左侧字符（对应频次减 1）。\n加入窗口右侧新字符（对应频次加 1）。\n\n\n每次窗口移动后，比较 pCount 和 sCount，若相等则记录当前窗口起始索引（i + 1）。\n\npublic List&lt;Integer&gt; findAnagrams(String s, String p) &#123;    if (s == null || p == null) &#123;        return new ArrayList&lt;&gt;();    &#125;    int sLen = s.length();    int pLen = p.length();    if (sLen &lt; pLen) &#123;        return new ArrayList&lt;&gt;();    &#125;    // 统计 p 和 s 的前 pLen 个字符出现的次数，如果相等，则说明是异位词    int[] pCount = new int[26];    int[] sCount = new int[26];    for (int i = 0; i &lt; pLen; i++) &#123;        pCount[p.charAt(i) - &#x27;a&#x27;]++;        sCount[s.charAt(i) - &#x27;a&#x27;]++;    &#125;    List&lt;Integer&gt; anagrams = new ArrayList&lt;&gt;();    if (Arrays.equals(pCount, sCount)) &#123;        anagrams.add(0);    &#125;    // 定长滑动窗口，每次移动一个字符，判断是否是异位词    for (int i = 0; i &lt; s.length() - p.length(); i++) &#123;        sCount[s.charAt(i) - &#x27;a&#x27;]--;        sCount[s.charAt(i + p.length()) - &#x27;a&#x27;]++;        if (Arrays.equals(pCount, sCount)) &#123;            anagrams.add(i + 1);        &#125;    &#125;    return anagrams;&#125;\n\n复杂度分析\n时间复杂度：O(26n)，其中 n 是 s 的长度。因为每次窗口移动后，我们都要比较两个长度为 26 的数组（Arrays.equals 内部会循环 26 次）。\n空间复杂度：O(1)，固定使用两个长度为 26 的数组（常数空间）。\n\n不固定窗口滑动 + 计数数组以下参考大佬的解法：438. 找到字符串中所有字母异位词 | 题解 | 灵茶山艾府\n\n频次数组预处理：\n\n\n统计 p 的字符频次到数组 pCount。\n\n\n双指针滑动窗口：\n\n\n使用双指针 left 和 right，right 向右移动，将遇到的字符在 pCount 中减 1（相当于进入窗口）。\n如果某个字符在 pCount 中的值小于 0，说明当前窗口中这个字符的数量超过了 p 中该字符的数量，或者 p 中根本没有这个字符。那么就需要移动 left 指针，将 left 指向的字符在 pCount 中加 1（相当于移出窗口），直到 pCount[c] 不再小于 0（即调整到当前字符数量正常）。\n当窗口长度（right - left + 1）等于 p 的长度时，说明我们找到了一个异位词子串，将 left 加入结果列表。\n\n注意：这种方法中，pCount 数组被复用，我们通过加减操作来维护窗口内字符的计数。当窗口长度等于 p 的长度时，由于我们保证了窗口内每个字符的出现次数都不超过 p 中的出现次数（通过 while 循环调整），并且窗口长度恰好等于 p 的长度，那么窗口内的字符串必然是 p 的一个异位词。因为如果窗口内某个字符的出现次数大于 p 中的出现次数，我们会通过 left 右移来减少它，直到它等于 p 中的出现次数（即不再为负）。而当窗口长度等于 p 的长度时，每个字符的出现次数恰好等于 p 中的出现次数（因为如果少了，那么 pCount 中对应的值应该是正数，但我们的操作中，进入窗口减 1，移出窗口加 1，并且我们保证了没有负值，所以每个字符都不多不少）。\npublic List&lt;Integer&gt; findAnagrams(String s, String p) &#123;    List&lt;Integer&gt; anagrams = new ArrayList&lt;&gt;();    // 统计 p 的每种字母的出现次数    int[] pCount = new int[26];    for (char c : p.toCharArray()) &#123;        pCount[c - &#x27;a&#x27;]++;    &#125;    int left = 0;    for (int right = 0; right &lt; s.length(); right++) &#123;        int c = s.charAt(right) - &#x27;a&#x27;;        // 右端点字母进入窗口        pCount[c]--;        // 字母 c 太多了，left右移，直到窗口中字母 c 的出现次数为 0        while (pCount[c] &lt; 0) &#123;            pCount[s.charAt(left) - &#x27;a&#x27;]++;            left++;        &#125;        // s&#x27; 和 p 的每种字母的出现次数都相同        if (right - left + 1 == p.length()) &#123;            // s&#x27; 左端点下标加入答案            anagrams.add(left);        &#125;    &#125;    return anagrams;&#125;\n\n复杂度分析\n时间复杂度：O(m + n)，其中 m 是 s 的长度，n 是 p 的长度。虽然写了个二重循环，但是内层循环中对 left 加一的总执行次数不会超过 m 次，所以滑窗的时间复杂度为 O(m)。\n空间复杂度：O(1)，使用固定大小的数组（ 26 个整数）。\n\n来源\n438. 找到字符串中所有字母异位词 | 力扣（LeetCode）\n\n\n","categories":["LeetCode"],"tags":["Java","LeetCode","学习笔记","哈希表","字符串","滑动窗口","LeetCode中等"]},{"title":"动态规划和中心扩散法求解最长回文子串（LeetCode 5）","url":"/blog/2025/05/24/longest-palindromic-substring/","content":"\n题目描述给你一个字符串 s，找到 s 中最长的 回文子串。\n说明:\n\n如果字符串向前和向后读都相同，则它满足回文性。\n子字符串是字符串中连续的非空字符序列。\n\n示例 1:\n\n输入：s = &quot;babad&quot;输出：&quot;bab&quot;解释：&quot;aba&quot; 同样是符合题意的答案。\n\n示例 2:\n\n输入：s = &quot;cbbd&quot;输出：&quot;bb&quot;\n\n提示:\n\n1 &lt;= s.length &lt;= 1000\ns 仅由数字和英文字母组成\n\n\n\n暴力法（不推荐）枚举所有子串，检查是否为回文，记录最长的一个。\npublic String longestPalindrome(String s) &#123;    if (s == null || s.isEmpty()) &#123;        return &quot;&quot;;    &#125;    int start = 0;    int maxLen = 0;    for (int i = 0; i &lt; s.length(); i++) &#123;        for (int j = i; j &lt; s.length(); j++) &#123;            if (longestPalindrome(s, i, j) &amp;&amp; (j - i + 1 &gt; maxLen)) &#123;                maxLen = j - i + 1;                start = i;            &#125;        &#125;    &#125;    return s.substring(start, start + maxLen);&#125;public boolean longestPalindrome(String s, int start, int end) &#123;    while (start &lt; end) &#123;        if (s.charAt(start++) != s.charAt(end--)) &#123;            return false;        &#125;    &#125;    return true;&#125;\n\n复杂度分析\n时间复杂度：O(n³)，共有 O(n²) 个子串（两层循环：i 从 0 到 n-1，j 从 i 到 n-1）。每个子串检查是否为回文需要 O(n) 时间（如长度为 k 的子串需比较 k/2 次）。总时间 = O(n²) × O(n) = O(n³)。\n空间复杂度：O(n)，仅需常数空间存储临时变量（如 maxLen, start）。\n\n动态规划利用二维数组 dp[i][j] 记录子串 s[i...j] 是否为回文，逐步扩展长度。\npublic String longestPalindrome(String s) &#123;    if (s == null || s.length() &lt;= 1) &#123;        return s;    &#125;    int len = s.length();    boolean[][] dp = new boolean[len][len];    int start = 0;    int maxLen = 1;    // 长度为1的子串全都是回文串    for (int i = 0; i &lt; len; i++) &#123;        dp[i][i] = true;    &#125;    // 判断长度为2的子串是否是回文串    for (int i = 0; i &lt; len - 1; i++) &#123;        if (s.charAt(i) == s.charAt(i + 1)) &#123;            dp[i][i + 1] = true;            start = i;            maxLen = 2;        &#125;    &#125;    // 判断长度为3及更长的子串是否是回文串    for (int l = 3; l &lt;= len; l++) &#123;        for (int i = 0; i &lt; len - l + 1; i++) &#123;            int j = i + l - 1;            if (s.charAt(i) == s.charAt(j) &amp;&amp; dp[i + 1][j - 1]) &#123;                dp[i][j] = true;                start = i;                maxLen = l;            &#125;        &#125;    &#125;    return s.substring(start, start + maxLen);&#125;\n\n复杂度分析\n时间复杂度：O(n²)，外层循环遍历子串长度 l（从 3 到 n），内层循环遍历起始点 i，总时间 = O(n²)。\n空间复杂度：O(n²)，需一个二维数组 dp[n][n] 存储所有子串的状态。\n\n中心扩展法以每个字符或每两个字符为中心，向两侧扩展寻找最长回文。\npublic String longestPalindrome1(String s) &#123;    if (s == null || s.isEmpty()) &#123;        return &quot;&quot;;    &#125;    int start = 0;    int end = 0;    for (int i = 0; i &lt; s.length(); i++) &#123;        // 奇数长度        int len1 = expand(s, i, i);        // 偶数长度        int len2 = expand(s, i, i + 1);        int len = Math.max(len1, len2);        if (len &gt; end - start) &#123;            start = i - (len - 1) / 2;            end = i + len / 2;        &#125;    &#125;    return s.substring(start, end + 1);&#125;private int expand(String s, int left, int right) &#123;    while (left &gt;= 0 &amp;&amp; right &lt; s.length() &amp;&amp; s.charAt(left) == s.charAt(right)) &#123;        left--;        right++;    &#125;    return right - left - 1;&#125;\n\n复杂度分析\n时间复杂度：O(n²)，共有 2n-1 个中心（每个字符作为奇中心，每两个字符之间作为偶中心），每个中心最多扩展 O(n) 次（如全相同字符时，扩展到边界）。总时间 = O(2n) × O(n) = O(n²)。\n空间复杂度：O(1)，仅需常数空间记录扩展的左右指针和最长回文的起止点。\n\n来源\n5. 最长回文子串 | 力扣（LeetCode）\n\n\n","categories":["LeetCode"],"tags":["Java","LeetCode","学习笔记","字符串","动态规划","LeetCode中等"]},{"title":"两字母单词构造回文串：哈希表计数与配对实现（LeetCode 2131）","url":"/blog/2025/05/25/longest-palindrome-by-concatenating-two-letter-words/","content":"\n题目描述给你一个字符串数组 words 。words 中每个元素都是一个包含两个小写英文字母的单词。请你从 words 中选择一些元素并按任意顺序连接它们，并得到一个尽可能长的回文串 。每个元素至多只能使用一次。请你返回你能得到的最长回文串的长度 。如果没办法得到任何一个回文串，请你返回 0 。\n说明: 回文串指的是从前往后和从后往前读一样的字符串。\n示例 1:\n\n输入：words = [&quot;lc&quot;, &quot;cl&quot;, &quot;gg&quot;]输出：6解释：一个最长的回文串为 &quot;lc&quot; + &quot;gg&quot; + &quot;cl&quot; = &quot;lcggcl&quot; ，长度为 6 。&quot;clgglc&quot; 是另一个可以得到的最长回文串。\n\n示例 2:\n\n输入：words = [&quot;ab&quot;, &quot;ty&quot;, &quot;yt&quot;, &quot;lc&quot;, &quot;cl&quot;, &quot;ab&quot;]输出：8解释：最长回文串是 &quot;ty&quot; + &quot;lc&quot; + &quot;cl&quot; + &quot;yt&quot; = &quot;tylcclyt&quot; ，长度为 8 。&quot;lcyttycl&quot; 是另一个可以得到的最长回文串。\n\n示例 3:\n\n输入：words = [&quot;cc&quot;, &quot;ll&quot;, &quot;xx&quot;]输出：2解释：最长回文串是 &quot;cc&quot; ，长度为 2 。&quot;ll&quot; 是另一个可以得到的最长回文串。&quot;xx&quot; 也是。\n\n提示:\n\n1 &lt;= words.length &lt;= 10^5\nwords[i].length == 2\nwords[i] 仅包含小写英文字母。\n\n\n\n思路分析\n统计单词出现次数：使用哈希表记录每个单词的出现次数。\n处理互为反转的单词对：对于每个单词，检查其反转是否存在。若存在，取两者出现次数的较小值，每对贡献 4 个字符（每个单词长度为 2 ）。\n处理对称单词：对于两个字符相同的单词（如 &quot;aa&quot;），可以成对使用（贡献 4 个字符），若有剩余且未使用中间点，可单独作为中间对称点（贡献 2 个字符）。\n避免重复处理：使用集合记录已处理的单词，确保每对单词只处理一次。\n\npublic int longestPalindrome(String[] words) &#123;    // 记录最长回文长度    int maxLen = 0;    // 标记是否已使用中间对称点    boolean center = false;    // 记录已处理的单词    List&lt;String&gt; processed = new ArrayList&lt;&gt;();    // 使用 HashMap 统计每个单词的出现次数    Map&lt;String, Integer&gt; wordCount = new HashMap&lt;&gt;();    // 记录所有 word 的次数    Arrays.stream(words).forEach(word -&gt; wordCount.put(word, wordCount.getOrDefault(word, 0) + 1));    for (String word : wordCount.keySet()) &#123;        if (processed.contains(word)) &#123;            continue;        &#125;        int count = wordCount.get(word);        String reversed = new StringBuilder(word).reverse().toString();        // 若单词字符相同（如&quot;aa&quot;），计算可成对使用的次数，剩余次数作为中间对称点。        if (word.equals(reversed)) &#123;            int pairs = count / 2;            maxLen += pairs * 4;            if (!center &amp;&amp; count % 2 == 1) &#123;                maxLen += 2;                center = true;            &#125;            processed.add(word);        &#125; else &#123;            // 找到反转单词，取较小次数计算贡献，避免重复处理。            if (wordCount.containsKey(reversed)) &#123;                int reversedCount = wordCount.get(reversed);                int pairs = Math.min(count, reversedCount);                maxLen += pairs * 4;                processed.add(word);                processed.add(reversed);            &#125;        &#125;    &#125;    return maxLen;&#125;\n\n复杂度分析\n时间复杂度：O(n)，遍历 words 数组并构建哈希表 wordCount，时间复杂度为 O(n)，遍历哈希表的键集合，假设不同的单词数量为 m，每个单词的处理包括生成反转字符串、哈希表查询等操作。由于每个单词长度为 2，生成反转字符串和哈希表操作均为 O(1)，总时间复杂度为 O(m)。最坏情况下，所有单词均不同（即 m = n），时间复杂度为 O(n)。其中 n 是数组长度。\n空间复杂度：O(n)，wordCount 存储所有单词及其频率，占用 O(m) 空间。processed 集合存储已处理的单词，需要 O(m) 空间。总体空间复杂度：O(m)，即 O(n)（m 最大为 n）。\n\n来源\n2131. 连接两字母单词得到的最长回文串 | 力扣（LeetCode）\n\n\n","categories":["LeetCode"],"tags":["Java","LeetCode","学习笔记","贪心算法","LeetCode中等"]},{"title":"整除性质解数字和差值：数学优化实现（LeetCode 2894）","url":"/blog/2025/05/28/divisible-and-non-divisible-sums-difference/","content":"\n题目描述给你两个正整数 n 和 m 。现定义两个整数 num1 和 num2 ，如下所示：\nnum1：范围 [1, n] 内所有 无法被 m 整除 的整数之和。num2：范围 [1, n] 内所有 能够被 m 整除 的整数之和。\n返回整数 num1 - num2 。\n示例 1:\n\n输入：n = 10, m = 3输出：19解释：在这个示例中：范围 [1, 10] 内无法被 3 整除的整数为 [1, 2, 4, 5, 7, 8, 10] ，num1 = 这些整数之和 = 37 。范围 [1, 10] 内能够被 3 整除的整数为 [3, 6, 9] ，num2 = 这些整数之和 = 18 。返回 37 - 18 = 19 作为答案。\n\n示例 2:\n\n输入：n = 5, m = 6输出：15解释：在这个示例中：范围 [1, 5] 内无法被 6 整除的整数为 [1, 2, 3, 4, 5] ，num1 = 这些整数之和 =  15 。范围 [1, 5] 内能够被 6 整除的整数为 [] ，num2 = 这些整数之和 = 0 。返回 15 - 0 = 15 作为答案。\n\n示例 3:\n\n输入：n = 5, m = 1输出：-15解释：在这个示例中：范围 [1, 5] 内无法被 1 整除的整数为 [] ，num1 = 这些整数之和 = 0 。范围 [1, 5] 内能够被 1 整除的整数为 [1, 2, 3, 4, 5] ，num2 = 这些整数之和 = 15 。返回 0 - 15 = -15 作为答案。\n\n提示:\n\n1 &lt;= n, m &lt;= 1000\n\n\n\n普通遍历最直观方法遍历 1 到 n 的每个数，分别累加能被 m 整除的数的和 sum_div 和不能整除的数的和 sum_non_div ，最后返回 sum_non_div - sum_div。\npublic int differenceOfSums(int n, int m) &#123;    int sum_div = 0;    int sum_non_div = 0;    for (int i = 1; i &lt;= n; i++) &#123;        if (i % m == 0) &#123;            sum_div += i;        &#125; else &#123;            sum_non_div += i;        &#125;    &#125;    return sum_non_div - sum_div;&#125;\n\n复杂度分析\n时间复杂度：O(n)，需遍历 1 到 n 的所有数。\n空间复杂度：O(1)，仅使用常数空间。\n\n数学公式利用数学公式直接计算，避免遍历：\n\n总和：1 到 n 的和为 total = n * (n + 1) / 2。\n整除和：能被 m 整除的数形如 m, 2m, 3m, ..., km（其中 k = n / m），和为 m * (k * (k + 1) / 2)。\n差值：非整除和 - 整除和 = (total - sum_div) - sum_div = total - 2 * sum_div。\n\npublic int differenceOfSums(int n, int m) &#123;    // 计算 1 到 n 的总和    long total = (long) n * (n + 1) / 2;    // 计算可整除数的个数k    int k = n / m;    // 可整除数的和    long divisibleSum = (long) m * k * (k + 1) / 2;    // 返回差值    return (int) (total - 2 * divisibleSum);&#125;\n\n复杂度分析\n时间复杂度：O(1)。\n空间复杂度：O(1)。\n\n来源\n2894. 分类求和并作差 | 力扣（LeetCode）\n\n\n","categories":["LeetCode"],"tags":["Java","LeetCode","学习笔记","LeetCode简单","数学公式"]},{"title":"哈希表分组字母异位词：排序与计数实现（LeetCode 49）","url":"/blog/2025/05/30/group-anagrams/","content":"\n题目描述给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。\n字母异位词 是由重新排列源单词的所有字母得到的一个新单词。\n示例 1:\n\n输入：strs = [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;]输出：[[&quot;bat&quot;], [&quot;nat&quot;, &quot;tan&quot;], [&quot;ate&quot;, &quot;eat&quot;, &quot;tea&quot;]]\n\n示例 2:\n\n输入：strs = [&quot;&quot;]输出：[[&quot;&quot;]]\n\n示例 3:\n\n输入：strs = [&quot;a&quot;]输出：[[&quot;a&quot;]]\n\n提示:\n\n1 &lt;= strs.length &lt;= 104\n0 &lt;= strs[i].length &lt;= 100\nstrs[i] 仅包含小写字母\n\n\n\n排序 + 哈希表字母异位词指字母相同，但排列不同的字符串。所以对每个字符串排序，将排序后的字符串作为 key，原字符串添加到该 key 对应的列表中。（如 &quot;eat&quot; 和 &quot;tea&quot; 的 key 都为 &quot;aet&quot;）。\npublic List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;    Map&lt;String, List&lt;String&gt;&gt; resultMap = new HashMap&lt;&gt;();    for (String str : strs) &#123;        char[] chars = str.toCharArray();        Arrays.sort(chars);        String key = new String(chars);        if (!resultMap.containsKey(key)) &#123;            resultMap.put(key, new ArrayList&lt;&gt;());        &#125;        resultMap.get(key).add(str);    &#125;    return new ArrayList&lt;&gt;(resultMap.values());&#125;\n\n复杂度分析\n时间复杂度：O(nk logk)，假设有 n 个字符串，每个字符串最大长度为 k。排序每个字符串的时间复杂度为O(k logk)，所以总时间复杂度为O(nk logk)。\n空间复杂度：O(nk)，哈希表存储所有字符串（最坏情况无重复 key）。\n\n字符计数 + 哈希表字母异位词指字母相同，但排列不同的字符串，所以，每个字符串里字母的数量是相等的，故可以统计每个字符串中每个字符出现的次数，然后生成一个表示字符频次的字符串作为 key（例如：&quot;a1b2&quot;），然后将原字符串添加到该 key 对应的列表中。\npublic List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;    int[] count = new int[26];    Map&lt;String, List&lt;String&gt;&gt; resultMap = new HashMap&lt;&gt;();    for (String str : strs) &#123;        Arrays.fill(count, 0);        for (char c : str.toCharArray()) &#123;            // 统计每个字符出现的次数            count[c - &#x27;a&#x27;]++;        &#125;        StringBuilder sb = new StringBuilder();        for (int i = 0; i &lt; 26; i++) &#123;            // 拼接每个字符出现的次数，作为 Map 的 key            if (count[i] &gt; 0) &#123;                sb.append((char) (&#x27;a&#x27; + i));                sb.append(count[i]);            &#125;        &#125;        String key = sb.toString();        if (!resultMap.containsKey(key)) &#123;            resultMap.put(key, new ArrayList&lt;&gt;());        &#125;        resultMap.get(key).add(str);    &#125;    // 入参：[&quot;eatt&quot;, &quot;teat&quot;, &quot;tan&quot;, &quot;atet&quot;, &quot;nat&quot;, &quot;bat&quot;]    // resultMap 结果为：&#123;a1b1t1=[bat], a1n1t1=[tan, nat], a1e1t2=[eatt, teat, atet]&#125;    return new ArrayList&lt;&gt;(resultMap.values());&#125;\n\n复杂度分析\n时间复杂度：O(nk)，哈希表存储所有字符串（最坏情况无重复 key）。\n空间复杂度：O(1)。\n\n关键结论\n排序 + 哈希表：代码简洁，但排序开销随字符串变长而增大。\n计数 + 哈希表：避免排序，通过字符频次编码更高效处理长字符串。\n实际选择：若字符串平均长度小，选方法一；若长度大，选方法二。\n\n通过哈希表将字母异位词映射到相同 key，两种方法均能高效解决分组问题！\n来源\n49. 字母异位词分组 | 力扣（LeetCode）\n\n\n","categories":["LeetCode"],"tags":["Java","LeetCode","学习笔记","数组","哈希表","字符串","排序","LeetCode中等"]},{"title":"前缀和解法实现区间和查询（LeetCode 303）","url":"/blog/2025/06/03/range-sum-query-immutable/","content":"\n题目描述给定一个整数数组  nums，处理以下类型的多个查询:\n计算索引 left 和 right （包含 left 和 right）之间的 nums 元素的和 ，其中 left &lt;= right。\n实现 NumArray 类：\n\nNumArray(int[] nums) 使用数组 nums 初始化对象\nint sumRange(int i, int j) 返回数组 nums 中索引 left 和 right 之间的元素的总和 ，包含 left 和 right 两点（也就是 nums[left] + nums[left + 1] + ... + nums[right] )\n\n示例 1:\n\n输入：[&quot;NumArray&quot;, &quot;sumRange&quot;, &quot;sumRange&quot;, &quot;sumRange&quot;][[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]]输出：[null, 1, -1, -3]解释：NumArray numArray = new NumArray([-2, 0, 3, -5, 2, -1]);numArray.sumRange(0, 2); // return 1 ((-2) + 0 + 3)numArray.sumRange(2, 5); // return -1 (3 + (-5) + 2 + (-1)) numArray.sumRange(0, 5); // return -3 ((-2) + 0 + 3 + (-5) + 2 + (-1))\n\n提示:\n\n1 &lt;= nums.length &lt;= 10^4\n-10^5 &lt;= nums[i] &lt;= 10^5\n0 &lt;= i &lt;= j &lt; nums.length\n最多调用 10*4 次 sumRange 方法\n\n\n\n直接计算最简单的思路，每次调用 sumRange() 时，直接遍历 left 到 right 的元素并求和。\nclass NumArray &#123;    private int[] nums;    public NumArray(int[] nums) &#123;        this.nums = nums;    &#125;        public int sumRange(int left, int right) &#123;        int sum = 0;        for (int i = left; i &lt;= right; i++) &#123;            sum += nums[i];        &#125;        return sum;    &#125;&#125;\n\n复杂度分析\n时间复杂度：O(mn)，其中 m 为查询次数，n 为数组长度。\n空间复杂度：O(1)，不考虑存储输入的数组。\n\n前缀和前缀和是一种高效处理区间求和问题的预处理技术，其核心思想是通过数学变换将区间求和转化为两个端点的差值计算。下面我们通过数学推导详细解释前缀和的工作原理。\n步骤1：定义前缀和数组给定数组 nums[0...n-1]，我们定义前缀和数组 prefix：\n\nprefix[0] = 0prefix[1] = nums[0]prefix[2] = nums[0] + nums[1]…prefix[i] = nums[0] + nums[1] + ... + nums[i-1]…prefix[n] = nums[0] + ... + nums[n-1]\n\n步骤2：区间和与前缀和的数学关系考虑区间 [left, right] 的和：\n\nsum(left, right)= nums[left] + nums[left+1] + ... + nums[right]= (nums[0] + ... + nums[left-1] + nums[left] + ... + nums[right]) - (nums[0] + ... + nums[left-1])= prefix[right+1] - prefix[left]\n\nclass NumArray &#123;    private int[] prefix;    public NumArray(int[] nums) &#123;        // 多一位存储0位置        prefix = new int[nums.length + 1];        for (int i = 0; i &lt; nums.length; i++) &#123;            // 递推关系：当前前缀和 = 前一个前缀和 + 当前元素            prefix[i + 1] = prefix[i] + nums[i];        &#125;    &#125;        public int sumRange(int left, int right) &#123;        return prefix[right + 1] - prefix[left];    &#125;&#125;\n\n前缀和的核心优势\n查询高效化：将 O(n) 的求和操作转化为 O(1) 的差值计算。\n预处理思想：一次构建多次使用，特别适合查询密集型场景。\n数学简洁性：通过简单的数组差值实现复杂区间计算。\n\n复杂度分析\n时间复杂度：O(n)，初始化前缀和数组，其中 n 是数组长度。sumRange 是 O(1)。\n空间复杂度：O(n)，存储前缀和数组。\n\n来源\n303. 区域和检索 - 数组不可变 | 力扣（LeetCode）\n\n\n","categories":["LeetCode"],"tags":["Java","LeetCode","学习笔记","数组","LeetCode简单","前缀和"]},{"title":"前缀和 + 哈希表解和为 K 的子数组问题（LeetCode 560）","url":"/blog/2025/06/05/subarray-sum-equals-k/","content":"\n题目描述给你一个整数数组 nums 和一个整数 k ，请你统计并返回 该数组中和为 k 的子数组的个数 。\n子数组 是数组中元素的连续非空序列。\n示例 1:\n\n输入：nums = [1, 1, 1], k = 2输出：2\n\n示例 2:\n\n输入：nums = [1, 2, 3], k = 3输出：2\n\n提示:\n\n1 &lt;= nums.length &lt;= 2 * 10^4\n-1000 &lt;= nums[i] &lt;= 1000\n-10^7 &lt;= k &lt;= 10^7\n\n\n\n暴力枚举（双重循环）最直观的方法是枚举所有可能的连续子数组，计算它们的和并统计等于 k 的个数。\npublic int subarraySum(int[] nums, int k) &#123;    int count = 0;    for (int i = 0; i &lt; nums.length; i++) &#123;        int sum = 0;        for (int j = i; j &lt; nums.length; j++) &#123;            sum += nums[j];            if (sum == k) &#123;                count++;            &#125;        &#125;    &#125;    return count;&#125;\n\n复杂度分析\n时间复杂度：O(n²)，其中 n 是数组长度。外层循环遍历每个元素作为起始点，内层循环遍历从起始点开始的所有子数组。\n空间复杂度：O(1)，只使用了常数级别的额外空间。\n\n前缀和 + 哈希表在做这道题之前，我们先看之前做过的两道题：\n\n前缀和解法实现区间和查询（LeetCode 303） | 笑话人生\n两数之和 | 笑话人生\n\n思路利用 前缀和 技术优化计算过程：\n\n计算数组的前缀和数组 prefix，其中：\nprefix[0] = 0，表示空数组的和，用于处理从第一个元素开始的子数组\nprefix[i + 1] = nums[0] + nums[1] + ... + nums[i]（i ≥ 0）\n\n\n对于任意子数组 nums[i..j]（包含下标 i 到 j），其和可表示为 prefix[j + 1] - prefix[i]\n问题转化为：寻找满足 prefix[j + 1] - prefix[i] = k 且 0 ≤ i &lt; j + 1 ≤ n 的索引对 (i, j) 的数量\n使用哈希表存储每个前缀和出现的次数，遍历时查询 prefix[j] - k 的出现次数并累加（这其实就是上面的两数之和）\n\npublic int subarraySum(int[] nums, int k) &#123;    int n = nums.length;    int[] prefix = new int[n + 1];    // 计算前缀和    for (int i = 0; i &lt; n; i++) &#123;        prefix[i + 1] = prefix[i] + nums[i];    &#125;    int count = 0;    // 设置容量可以快 2ms    Map&lt;Integer, Integer&gt; countMap = new HashMap&lt;&gt;(n + 1);    for (int p : prefix) &#123;        // 查找前缀和为 p - k 的出现次数        count += countMap.getOrDefault(p - k, 0);        // 更新当前前缀和的出现次数        countMap.put(p, countMap.getOrDefault(p, 0) + 1);    &#125;    return count;&#125;\n\n示例解析以 nums = [1, 1, 1], k=2 为例：\n\n前缀和数组：prefix = [0, 1, 2, 3]\n遍历过程：\np=0：查找 -2 → 不存在，count=0；更新 map&#123;0:1&#125;\np=1：查找 -1 → 不存在，count=0；更新 map&#123;0:1, 1:1&#125;\np=2：查找 0 → 存在1次，count=1；更新 map&#123;0:1, 1:1, 2:1&#125;\np=3：查找 1 → 存在1次，count=2；更新 map&#123;0:1, 1:1, 2:1, 3:1&#125;\n\n\n返回结果：2\n\n常见问题解答\n为什么需要 prefix[0] = 0？考虑子数组从第一个元素开始的情况：子数组 nums[0..j] 的和应为 prefix[j + 1] - prefix[0] 没有 prefix[0] 就无法表示从数组开头开始的子数组\n哈希表如何处理重复前缀和？当不同位置产生相同的前缀和时，哈希表记录出现次数。例如：\nnums = [0, 0, 0], k=0\n前缀和：[0, 0, 0, 0]\n遍历时：\np=0：查找 0 → 初始不存在，count=0；记录 0:1\np=0：查找 0 → 存在1次，count=1；记录 0:2\np=0：查找 0 → 存在2次，count=3；记录 0:3\np=0：查找 0 → 存在3次，count=6；记录 0:4\n\n\n返回结果：6（正确对应6个子数组）\n\n\n\n复杂度分析\n时间复杂度：O(n)，其中 n 是数组长度。遍历数组两次（计算前缀和和统计子数组数量）。\n空间复杂度：O(n)，哈希表最多存储 n + 1 个键值对。\n\n总结\n暴力枚举简单直接，适合小规模数据（n ≤ 1000）\n前缀和 + 哈希表是更高效的通用解法，时间复杂度 O(n)，能处理较大规模数据（n ≤ 2×10⁴）\n实际应用中优先选择方法二，其线性时间复杂度能有效应对常见场景\n关键点在于理解前缀和定义和索引映射关系：子数组和 = prefix[j + 1] - prefix[i]\n\n来源\n560. 和为 K 的子数组 | 力扣（LeetCode）560. 和为 K 的子数组 | 题解 | 灵茶山艾府\n\n\n","categories":["LeetCode"],"tags":["Java","LeetCode","学习笔记","数组","哈希表","LeetCode简单","前缀和"]},{"title":"动态规划求解最大子数组和（LeetCode 53）","url":"/blog/2025/06/09/maximum-subarray/","content":"\n题目描述给你一个整数数组 nums ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。\n子数组 是数组中的一个连续部分。\n示例 1:\n\n输入：nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]输出：6解释：连续子数组 [4, -1, 2, 1] 的和最大，为 6 。\n\n示例 2:\n\n输入：nums = [1]输出：1\n\n示例 3:\n\n输入：nums = [5, 4, -1, 7, 8]输出：23\n\n提示:\n\n1 &lt;= nums.length &lt;= 10^5\n-10^4 &lt;= nums[i] &lt;= 10^4\n\n\n\n暴力枚举最简单的思路，通过两层循环遍历所有可能的连续子数组，计算每个子数组的和并记录最大值。\npublic int maxSubArray(int[] nums) &#123;    int max = nums[0];    for (int i = 0; i &lt; nums.length; i++) &#123;        int sum = 0;        for (int j = i; j &lt; nums.length; j++) &#123;            sum += nums[j];            max = Math.max(max, sum);        &#125;    &#125;    return max;&#125;\n\n复杂度分析\n时间复杂度：O(n²)，其中 n 是数组长度。需要两层循环遍历所有子数组。\n空间复杂度：O(1)，仅使用常数级别的额外空间。\n\n前缀和参考前缀和的定义：前缀和解法实现区间和查询（LeetCode 303） | 笑话人生\n利用前缀和的思想，由于子数组的元素和等于两个前缀和的差，遍历数组计算前缀和，同时维护当前最小前缀和。最大子数组和即为当前前缀和与最小前缀和的差值的最大值。\npublic int maxSubArray(int[] nums) &#123;    int max = nums[0];    int prefixSum = 0;    int minPrefixSum = 0;    for (int i = 0; i &lt; nums.length; i++) &#123;        prefixSum += nums[i];        max = Math.max(max, prefixSum - minPrefixSum);        minPrefixSum = Math.min(minPrefixSum, prefixSum);    &#125;    return max;&#125;\n\n复杂度分析\n时间复杂度：O(n)，只需一次遍历数组。\n空间复杂度：O(1)，仅使用常数级别的额外空间。\n\n动态规划定义 dp[i] 表示以 nums[i] 结尾的最大子数组和。状态转移方程为：dp[i] = Math.max(dp[i - 1], 0) + nums[i]。最终结果为 dp 数组中的最大值。可以简单的理解为，如果 nums[i] 左边的子数组和 dp[i - 1] &lt; 0，那么加上 nums[i] 的值会导致子数组和更小，所以这个时候取 nums[i] 的值即可，否则就将 nums[i] 的值加入 dp[i - 1] 的子数组和。\npublic int maxSubArray(int[] nums) &#123;    int[] dp = new int[nums.length];    dp[0] = nums[0];    int max = dp[0];    for (int i = 1; i &lt; nums.length; i++) &#123;        dp[i] = Math.max(dp[i - 1], 0) + nums[i];        max = Math.max(max, dp[i]);    &#125;    return max;&#125;\n\n复杂度分析\n时间复杂度：O(n)，只需一次遍历数组。\n空间复杂度：O(n)，需要额外的 dp 数组存储中间结果。\n\n动态规划（空间优化）在以上动态规划的基础上进行空间优化。由于 dp[i] 只依赖于 dp[i - 1]，因此可以用一个变量代替 dp 数组。\npublic int maxSubArray(int[] nums) &#123;    int dp = nums[0];    int max = nums[0];    for (int i = 1; i &lt; nums.length; i++) &#123;        dp = Math.max(dp, 0) + nums[i];        max = Math.max(max, dp);    &#125;    return max;&#125;\n\n复杂度分析\n时间复杂度：O(n)，只需一次遍历数组。\n空间复杂度：O(1)，仅使用常数级别的额外空间。\n\n总结\n\n\n解法\n时间复杂度\n空间复杂度\n特点\n\n\n\n暴力枚举\nO(n²)\nO(1)\n思路简单，效率低\n\n\n前缀和\nO(n)\nO(1)\n利用前缀和思想\n\n\n动态规划\nO(n)\nO(n)\n标准动态规划解法\n\n\n动态规划优化\nO(n)\nO(1)\n最优解法，推荐使用\n\n\n来源\n53. 最大子数组和 | 力扣（LeetCode）53. 最大子数组和 | 题解 | 灵茶山艾府\n\n\n","categories":["LeetCode"],"tags":["Java","LeetCode","学习笔记","数组","动态规划","LeetCode中等","前缀和","子数组"]},{"title":"Spring Boot 入门指南：从零开始创建 Web 应用","url":"/blog/2025/06/12/spring-boot/","content":"\n\n本文面向 Java 初学者，详细介绍 Spring Boot 框架原理、应用场景及从零搭建 Web 应用的完整流程。\n\nSpring Boot 框架简介基本原理Spring Boot 是 Spring 框架的扩展，通过 约定优于配置 的理念解决传统 Spring 应用配置复杂的问题，简化 Spring 应用的初始搭建和开发过程。通过自动配置和起步依赖（Starter Dependencies）来减少开发者的配置工作，Spring Boot 内嵌了 Tomcat、Jetty 或 Undertow 等服务器，因此无需部署 WAR 文件即可运行。核心思想是 让开发更简单 。\n核心特性\n自动配置：通过 @EnableAutoConfiguration 自动配置 Bean（基于项目中的 jar 依赖自动配置 Spring 应用）\n起步依赖：通过提供预定义的依赖描述符（如 spring-boot-starter-web 包含了开发 Web 应用所需的依赖）简化构建配置，解决版本冲突。\n内嵌服务：内置 Tomcat/Jetty/Undertow 等服务器，无需部署 WAR，直接运行一个独立的应用即可。\nActuator：提供生产级监控和管理功能，如监控应用的健康状况、信息查看等。\n\n工作原理[启动类] → [@SpringBootApplication]     → 扫描 @Component → 加载 @Configuration     → 读取 spring.factories → 应用自动配置    → 启动内嵌容器\n\n应用场景Spring Boot 适用于构建微服务架构、RESTful API、企业级应用等。\n\n\n环境准备软件版本\n开发工具：IntelliJ IDEA 2021+\nJava环境：JDK 1.8 或以上版本（建议使用 JDK 11 或 17）\n构建工具：Maven 3.6+（IDEA 一般自带，但需确保配置正确）\n\n配置 Maven 的 settings.xmlMaven的 settings.xml文件用于配置全局的 Maven 设置，如仓库镜像、代理等。通常位于Maven 安装目录的 conf 文件夹下，或者用户目录下的 .m2 文件夹（如 ~/.m2/settings.xml），在 IDEA → Settings 中可以直接查看文件路径：\n\n\n配置样例如下：\nsettings.xml&lt;settings xmlns=&quot;http://maven.apache.org/SETTINGS/1.0.0&quot;          xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;          xsi:schemaLocation=&quot;http://maven.apache.org/SETTINGS/1.0.0           http://maven.apache.org/xsd/settings-1.0.0.xsd&quot;&gt;        &lt;!-- 添加阿里云镜像加速 --&gt;    &lt;mirrors&gt;        &lt;mirror&gt;            &lt;id&gt;aliyun&lt;/id&gt; &lt;!-- 镜像的唯一标识 --&gt;            &lt;name&gt;Aliyun Public Repository&lt;/name&gt;            &lt;url&gt;https://maven.aliyun.com/repository/public&lt;/url&gt;            &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;!-- 匹配哪些仓库，`*` 表示所有仓库都使用该镜像 --&gt;        &lt;/mirror&gt;    &lt;/mirrors&gt;&lt;/settings&gt;\n\nIDEA 配置\n配置 Maven 路径：File → Settings → Build, Execution, Deployment → Build Tools → Maven\n设置 JDK 版本：File → Project Structure → SDKs\n\n创建 Spring Boot 项目项目初始化在 IDEA 中创建 Spring Boot 项目有两种常用方式：\n\n通过 Spring Initializr 网站（https://start.spring.io/）生成项目，然后导入 IDEA。\n打开 IDEA → New → Project → Spring Boot，配置项目信息\n添加依赖\nSpring Web：用于构建Web应用\nLombok：非必须，主要用于简化代码\n\n\n\n\n\n项目结构解析SpringBootDemo├── src/main/java│   └── com/cylong/springbootdemo│       ├── SpringBootDemoApplication.java  # 主启动类│       └── controller│           ├── HelloController.java # 控制器│           └── Student.java         # 这里主要用于展示 Lombok 简化代码作用├── src/main/resources│   ├── application.properties # 配置文件│   ├── static                 # 静态资源（HTML, CSS, JS）│   └── templates              # 模板文件（Thymeleaf）├── src/test                   # 测试代码└── pom.xml                    # Maven 配置\n\n核心配置文件详解pom.xml 解析pom.xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;!-- 继承 Spring Boot 默认配置，它提供了依赖管理，这样我们在添加其他 Spring Boot 依赖时就不需要指定版本号了 --&gt;    &lt;parent&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;        &lt;version&gt;3.5.0&lt;/version&gt;        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;    &lt;/parent&gt;    &lt;!-- 通常填写公司或者个人域名的倒序，例如：com.example --&gt;    &lt;groupId&gt;com.cylong&lt;/groupId&gt;    &lt;!-- 项目名称 --&gt;    &lt;artifactId&gt;SpringBootDemo&lt;/artifactId&gt;    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;    &lt;name&gt;SpringBootDemo&lt;/name&gt;    &lt;description&gt;SpringBootDemo&lt;/description&gt;    &lt;properties&gt;        &lt;java.version&gt;24&lt;/java.version&gt;    &lt;/properties&gt;    &lt;dependencies&gt;        &lt;!-- Web 开发核心依赖，（如 Spring MVC，内嵌 Tomcat 等） --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;!-- 测试依赖 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;        &lt;!-- Lombok 依赖--&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;            &lt;artifactId&gt;lombok&lt;/artifactId&gt;            &lt;optional&gt;true&lt;/optional&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;    &lt;!-- 打包插件（生成可执行 Jar） --&gt;    &lt;build&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;                &lt;configuration&gt;                    &lt;annotationProcessorPaths&gt;                        &lt;path&gt;                            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;                            &lt;artifactId&gt;lombok&lt;/artifactId&gt;                        &lt;/path&gt;                    &lt;/annotationProcessorPaths&gt;                &lt;/configuration&gt;            &lt;/plugin&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;                &lt;configuration&gt;                    &lt;excludes&gt;                        &lt;exclude&gt;                            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;                            &lt;artifactId&gt;lombok&lt;/artifactId&gt;                        &lt;/exclude&gt;                    &lt;/excludes&gt;                &lt;/configuration&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;&lt;/project&gt;\n\napplication.properties 解析application.properties# 应用名称spring.application.name=SpringBootDemo# 修改端口 默认8080server.port=9090# 配置上下文，URL变为：http://localhost:9090/demo/hello# 如果不配置，默认是：http://localhost:9090/helloserver.servlet.context-path=/demo# 自定义属性welcome.message=Hello Spring Boot\n\n编写第一个 Web 接口创建控制器HelloController.javapackage com.cylong.springbootdemo.controller;import org.springframework.beans.factory.annotation.Value;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;// 表明这是一个控制器，并且返回的数据直接写入响应体（如 JSON 或字符串）@RestController // = @Controller + @ResponseBodypublic class HelloController &#123;    // application.properties 中自定义属性    @Value(&quot;$&#123;welcome.message&#125;&quot;)    private String welcomeMsg;    // 映射 GET 请求到 /hello 路径    @GetMapping(&quot;/hello&quot;)    public String sayHello() &#123;        Student student = new Student();        student.setNo(&quot;1000&quot;);        student.setName(&quot;张三&quot;);        return welcomeMsg + &quot; &quot; + student.getName() + &quot; 访问成功！&quot;;    &#125;&#125;\n\nStudent.javapackage com.cylong.springbootdemo.controller;import lombok.Data;@Datapublic class Student &#123;    /**     * 学号     */    private String no;    /**     * 姓名     */    private String name;&#125;\n\n这里 @Data 是 Lombok 提供的一个组合注解，它主要用于简化 Java Bean 的编写。当你在类上使用 @Data 注解时，Lombok 会在编译时自动为类生成以下方法：\n\n所有字段的 getter 方法（对于非 static 字段）\n所有非 final 字段的 setter 方法\nequals() 方法\nhashCode() 方法\ntoString() 方法\n\n创建启动类SpringBootDemoApplication.javapackage com.cylong.springbootdemo;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;// 核心注解：启用自动配置和组件扫描// 组合了 @Configuration + @EnableAutoConfiguration + @ComponentScan@SpringBootApplicationpublic class SpringBootDemoApplication &#123;    public static void main(String[] args) &#123;        // 启动 Spring 应用        SpringApplication.run(SpringBootDemoApplication.class, args);    &#125;&#125;\n\n运行与测试启动应用\n右键 SpringBootDemoApplication → Run &#39;SpringBootDemoApplication&#39; 或者使用 IDEA 工具栏的运行按钮。\n查看控制台输出：  .   ____          _            __ _ _ /\\\\ / ___&#x27;_ __ _ _(_)_ __  __ _ \\ \\ \\ \\( ( )\\___ | &#x27;_ | &#x27;_| | &#x27;_ \\/ _` | \\ \\ \\ \\ \\\\/  ___)| |_)| | | | | || (_| |  ) ) ) )  &#x27;  |____| .__|_| |_|_| |_\\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot ::                (v3.5.0)2025-06-15T06:53:46.411+08:00  INFO 22460 --- [SpringBootDemo] [           main] c.c.s.SpringBootDemoApplication          : Starting SpringBootDemoApplication using Java 24.0.1 with PID 22460 (D:\\Github\\IdeaProjects\\SpringBootDemo\\target\\classes started by win in D:\\Github\\IdeaProjects\\SpringBootDemo)2025-06-15T06:53:46.413+08:00  INFO 22460 --- [SpringBootDemo] [           main] c.c.s.SpringBootDemoApplication          : No active profile set, falling back to 1 default profile: &quot;default&quot;2025-06-15T06:53:46.865+08:00  INFO 22460 --- [SpringBootDemo] [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat initialized with port 9090 (http)2025-06-15T06:53:46.875+08:00  INFO 22460 --- [SpringBootDemo] [           main] o.apache.catalina.core.StandardService   : Starting service [Tomcat]2025-06-15T06:53:46.875+08:00  INFO 22460 --- [SpringBootDemo] [           main] o.apache.catalina.core.StandardEngine    : Starting Servlet engine: [Apache Tomcat/10.1.41]2025-06-15T06:53:46.904+08:00  INFO 22460 --- [SpringBootDemo] [           main] o.a.c.c.C.[Tomcat].[localhost].[/demo]   : Initializing Spring embedded WebApplicationContext2025-06-15T06:53:46.904+08:00  INFO 22460 --- [SpringBootDemo] [           main] w.s.c.ServletWebServerApplicationContext : Root WebApplicationContext: initialization completed in 462 ms2025-06-15T06:53:47.124+08:00  INFO 22460 --- [SpringBootDemo] [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port 9090 (http) with context path &#x27;/demo&#x27;2025-06-15T06:53:47.129+08:00  INFO 22460 --- [SpringBootDemo] [           main] c.c.s.SpringBootDemoApplication          : Started SpringBootDemoApplication in 1.0 seconds (process running for 1.349)\n\n\n\n浏览器访问应用启动后，默认端口是 8080。我上文配置文件修改了端口号为 9090，并且设置了 context-path=/demo，所以打开浏览器访问：http://localhost:9090/demo/hello （默认是：http://localhost:8080/hello）\n页面输出：\nHello Spring Boot 张三 访问成功！\n\n项目打包部署\nbash 执行以下命令：\n# 生成可执行 JARmvn clean package # 生成 target/SpringBootDemo-0.0.1-SNAPSHOT.jar# 运行应用java -jar target/SpringBootDemo-0.0.1-SNAPSHOT.jar\n\n或者直接图形化界面打包：\n\n\n\n\n常见问题排查\n端口冲突：修改 server.port=9090，默认是 8080\n404 错误：\n检查 @RestController 注解\n确认 URL 包含 context-path\n\n\n依赖下载失败：\n检查 Maven 镜像配置\n执行 mvn clean install -U\n\n\n\n\n","categories":["Java"],"tags":["Java","Spring","SpringBoot","JavaWeb","后端框架","RESTfulAPI"]},{"title":"矩阵置零的原地算法：首行列标记与空间优化（LeetCode 73）","url":"/blog/2025/06/13/set-matrix-zeroes/","content":"\n题目描述给定一个 m x n 的矩阵，如果一个元素为 0 ，则将其所在行和列的所有元素都设为 0 。请使用 原地算法。\n原地算法：在计算机科学中，一个原地算法（in-place algorithm）是一种使用小的，固定数量的额外之空间来转换资料的算法。当算法执行时，输入的资料通常会被要输出的部分覆盖掉。不是原地算法有时候称为非原地（not-in-place）或不得其所（out-of-place）。\n示例 1:\n\n\n输入：matrix = [[1, 1, 1], [1, 0, 1], [1, 1, 1]]输出：[[1, 0, 1], [0, 0, 0], [1, 0, 1]]\n\n示例 2:\n\n\n输入：matrix = [[0, 1, 2, 0], [3, 4, 5, 2], [1, 3, 1, 5]]输出：[[0, 0, 0, 0], [0, 4, 5, 0], [0, 3, 1, 0]]\n\n提示:\n\nm == matrix.length\nn == matrix[0].length\n1 &lt;= m, n &lt;= 200\n-2^31 &lt;= matrix[i][j] &lt;= 2^31 - 1\n\n\n\n辅助数组法使用两个辅助数组分别记录需要置零的行和列。首先遍历矩阵，当遇到元素为 0 时，将对应的行标记和列标记设置为 true。然后再次遍历矩阵，根据行标记和列标记将相应元素置为 0。\npublic void setZeroes(int[][] matrix) &#123;    // 获取矩阵的行数和列数    int rowLen = matrix.length;    int colLen = matrix[0].length;        // 创建两个布尔数组，分别用于标记需要置零的行和列    boolean[] row = new boolean[rowLen];    boolean[] col = new boolean[colLen];        // 第一次遍历：标记包含 0 的行和列    for (int i = 0; i &lt; rowLen; i++) &#123;        for (int j = 0; j &lt; colLen; j++) &#123;            if (matrix[i][j] == 0) &#123;                row[i] = true; // 标记第 i 行需要置零                col[j] = true; // 标记第 j 列需要置零            &#125;        &#125;    &#125;        // 第二次遍历：根据标记数组将相应行和列的元素置零    for (int i = 0; i &lt; rowLen; i++) &#123;        for (int j = 0; j &lt; colLen; j++) &#123;            // 如果当前行或列被标记，则将元素置为 0            if (row[i] || col[j]) &#123;                matrix[i][j] = 0;            &#125;        &#125;    &#125;&#125;\n\n复杂度分析\n时间复杂度：O(m × n)，其中 m 和 n 分别是矩阵的行数和列数。我们遍历了两次矩阵。\n空间复杂度：O(m + n)，使用了两个辅助数组分别存储行和列的标记。\n\n原地标记法（优化空间）使用矩阵的第一行和第一列作为标记数组，代替上面解法中的额外数组。首先检查第一行和第一列是否需要置零，然后用第一行记录各列是否需要置零，第一列记录各行是否需要置零。最后根据标记处理除第一行第一列外的元素，再单独处理第一行和第一列。\npublic void setZeroes(int[][] matrix) &#123;    int rowLen = matrix.length;    int colLen = matrix[0].length;        // 检查第一列是否有 0    boolean colHasZero = false;    for (int i = 0; i &lt; rowLen; i++) &#123;        if (matrix[i][0] == 0) &#123;            colHasZero = true;            break;        &#125;    &#125;        // 检查第一行是否有 0    boolean rowHasZero = false;    for (int j = 0; j &lt; colLen; j++) &#123;        if (matrix[0][j] == 0) &#123;            rowHasZero = true;            break;        &#125;    &#125;        // 使用第一行和第一列标记其他行列的 0    for (int i = 1; i &lt; rowLen; i++) &#123;        for (int j = 1; j &lt; colLen; j++) &#123;            if (matrix[i][j] == 0) &#123;                // 这里其实也是先把有零的第一行和第一列位置置零了                matrix[i][0] = 0; // 标记第 i 行需要置零                matrix[0][j] = 0; // 标记第 j 列需要置零            &#125;        &#125;    &#125;        // 根据标记设置除第一行和第一列外的元素    for (int i = 1; i &lt; rowLen; i++) &#123;        for (int j = 1; j &lt; colLen; j++) &#123;            // 如果当前行或列被标记，则将元素置为 0            if (matrix[i][0] == 0 || matrix[0][j] == 0) &#123;                matrix[i][j] = 0;            &#125;        &#125;    &#125;        // 处理第一列置零    if (colHasZero) &#123;        for (int i = 0; i &lt; rowLen; i++) &#123;            matrix[i][0] = 0;        &#125;    &#125;        // 处理第一行置零    if (rowHasZero) &#123;        for (int j = 0; j &lt; colLen; j++) &#123;            matrix[0][j] = 0;        &#125;    &#125;&#125;\n\n复杂度分析\n时间复杂度：O(m × n)，其中 m 和 n 分别是矩阵的行数和列数。我们遍历了多次矩阵，但时间复杂度仍是线性级别。\n空间复杂度：O(1)，仅使用常数级别的额外空间。\n\n总结\n\n\n解法\n时间复杂度\n空间复杂度\n优势\n劣势\n\n\n\n辅助数组法\nO(m × n)\nO(m + n)\n思路清晰，实现简单，两次遍历矩阵即可完成\n使用了额外的 O(m + n) 空间，不是原地算法\n\n\n原地标记法\nO(m × n)\nO(1)\n空间复杂度最优，仅使用常数空间，符合原地算法\n实现逻辑相对复杂，需要多次遍历矩阵\n\n\n两种方法各有优劣，在实际应用中可根据具体场景选择最合适的解法。对于面试场景，掌握两种方法并能解释其优劣会更有优势。\n来源\n73. 矩阵置零 | 力扣（LeetCode）\n\n\n","categories":["LeetCode"],"tags":["Java","LeetCode","学习笔记","数组","矩阵","LeetCode中等"]},{"title":"Spring Boot 事件驱动编程：ApplicationEventPublisher 原理与实践指南","url":"/blog/2025/06/20/application-event-publisher/","content":"\n基本介绍ApplicationEventPublisher 是 Spring 框架的核心接口，用于发布应用事件，实现观察者模式。其核心作用包括：\n\n事件发布：允许组件发布自定义事件\n松耦合：实现发布者与订阅者的解耦\n同步处理：默认同步执行（可通过 @Async 实现异步）\n继承机制：事件对象可继承扩展（支持 ApplicationEvent 或任意 POJO）\n\n工作流程：\n[发布者] → (发布事件) → [ApplicationContext] → (路由事件) → [监听器]\n\n应用场景\n业务解耦：如用户注册后发送邮件/短信\n状态变更通知：订单状态变化时更新库存\n审计日志：关键操作后记录审计信息\n异步任务触发：耗时操作异步执行\n系统监控：关键事件触发监控上报\n\n\n\n代码示例添加 Maven 依赖由于 Spring Boot 已经内置了事件发布机制，我们只需要引入 spring-boot-starter 即可，它包含了 spring-context，其中就有 ApplicationEventPublisher。\n&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;        &lt;scope&gt;test&lt;/scope&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;\n\n关于 Spring Boot 入门可以参考：Spring Boot 入门指南：从零开始创建 Web 应用\n事件定义（POJO）import lombok.Getter;import org.springframework.context.ApplicationEvent;// 这里用了 Lombok 注解，也可以参考上一篇文章@Getterpublic class UserRegisterEvent extends ApplicationEvent &#123;    private final String username;    public UserRegisterEvent(Object source, String username) &#123;        // source 通常是事件发布者        super(source);        this.username = username;    &#125;&#125;\n\n事件监听器@Componentpublic class UserRegisterListener &#123;    // 监听方式1：注解监听指定事件，此时 UserRegisterEvent 无需继承 ApplicationEvent    @EventListener    public void handleEvent(UserRegisterEvent event) &#123;        System.out.println(&quot;[注解监听] 新用户注册: &quot; + event.getUsername());    &#125;&#125;\n// 监听方式2：实现 ApplicationListener 接口，此时 UserRegisterEvent 需要继承 ApplicationEvent@Componentpublic class EmailListener implements ApplicationListener&lt;UserRegisterEvent&gt; &#123;    @Override    public void onApplicationEvent(UserRegisterEvent event) &#123;        System.out.println(&quot;[接口监听] 发送欢迎邮件至: &quot; + event.getUsername());    &#125;&#125;\n\n在 Spring 4.2 之前，自定义事件必须继承 ApplicationEvent。从 Spring 4.2 开始，事件可以是任意对象，不再强制要求继承 ApplicationEvent。因此，有两种解决方案：\n\n让 UserRegisterEvent 继承 ApplicationEvent（这样两种监听方式都支持）\n将实现 ApplicationListener 接口的监听器改为使用 @EventListener 注解（推荐，因为更灵活）\n\n为了保持代码的简洁和现代 Spring 的使用方式，我们通常推荐使用 @EventListener 注解。这里为了演示两种方式，我们让事件类继承 ApplicationEvent，同时，在发布事件的时候，需要传递 source（通常就是发布者对象，但也可以为 null）\n事件发布服务@Servicepublic class UserService &#123;        // 注入事件发布器    private final ApplicationEventPublisher publisher;    public UserService(ApplicationEventPublisher publisher) &#123;        this.publisher = publisher;    &#125;    public void registerUser(String username) &#123;        System.out.println(&quot;注册用户: &quot; + username);        // 发布事件，需传递事件源（通常就是发布者对象 this，但也可以为 null）和业务数据        publisher.publishEvent(new UserRegisterEvent(this, username));        System.out.println(&quot;主流程完成&quot;);    &#125;&#125;\n\n主应用类@SpringBootApplicationpublic class ApplicationEventPublisherDemoApplication &#123;\tpublic static void main(String[] args) &#123;\t\tConfigurableApplicationContext context = SpringApplication.run(ApplicationEventPublisherDemoApplication.class, args);\t\tUserService userService = context.getBean(UserService.class);\t\tuserService.registerUser(&quot;cylong&quot;);\t&#125;&#125;\n\n代码解释\n事件对象：UserRegisterEvent 封装事件数据\n监听器：\n注解方式：@EventListener 自动匹配事件类型（也就是根据类名匹配）\n接口方式：实现 ApplicationListener 接口\n\n\n发布器：\nApplicationEventPublisher.publishEvent() 触发事件\nSpring 自动注入发布器实例\n\n\n执行流程：\n主应用调用 registerUser()\n服务内部发布事件\n所有监听器同步执行\n\n\n\n运行输出注册用户: cylong[接口监听] 发送欢迎邮件至: cylong[注解监听] 新用户注册: cylong主流程完成\n\n异常处理下面将展示三种异常处理方式（局部捕获、全局处理和异步处理）的实现\n代码示例import org.springframework.context.ApplicationEvent;// 1. 自定义事件public class OrderEvent extends ApplicationEvent &#123;    private final String orderId;    public OrderEvent(Object source, String orderId) &#123;        super(source);        this.orderId = orderId;    &#125;    public String getOrderId() &#123;        return orderId;    &#125;&#125;\n\nimport org.springframework.context.event.EventListener;import org.springframework.scheduling.annotation.Async;import org.springframework.stereotype.Component;@Componentpublic class OrderEventListeners &#123;    // 2.1 局部异常捕获 - 库存服务    @EventListener    public void handleInventory(OrderEvent event) &#123;        try &#123;            System.out.println(&quot;\\n[库存服务] 处理订单: &quot; + event.getOrderId());            if (&quot;error_stock&quot;.equals(event.getOrderId())) &#123;                throw new RuntimeException(&quot;库存不足，商品A缺货&quot;);            &#125;            System.out.println(&quot;   &gt; 库存锁定成功&quot;);        &#125; catch (Exception e) &#123;            System.out.println(&quot;   ! [库存异常] &quot; + e.getMessage());            System.out.println(&quot;   &gt; 执行本地补偿: 释放预留资源&quot;);        &#125;    &#125;    // 2.2 局部异常捕获 - 支付服务    @EventListener    public void handlePayment(OrderEvent event) &#123;        try &#123;            System.out.println(&quot;\\n[支付服务] 处理订单: &quot; + event.getOrderId());            if (&quot;error_payment&quot;.equals(event.getOrderId())) &#123;                throw new RuntimeException(&quot;支付失败，信用卡余额不足&quot;);            &#125;            System.out.println(&quot;   &gt; 支付处理成功&quot;);        &#125; catch (Exception e) &#123;            System.out.println(&quot;   ! [支付异常] &quot; + e.getMessage());            System.out.println(&quot;   &gt; 执行本地补偿: 取消支付预授权&quot;);        &#125;    &#125;    // 3. 用于演示全局异常处理的监听器（不捕获异常）    @EventListener    public void handleNotification(OrderEvent event) &#123;        System.out.println(&quot;\\n[通知服务] 处理订单: &quot; + event.getOrderId());        if (&quot;error_stock&quot;.equals(event.getOrderId())) &#123;            throw new RuntimeException(&quot;通知服务失败: 短信配额不足&quot;);        &#125;        System.out.println(&quot;   &gt; 已发送订单确认通知&quot;);    &#125;    // 4. 异步异常处理    @Async    @EventListener    public void handleAsyncTask(OrderEvent event) &#123;        System.out.println(&quot;\\n[异步服务] 开始处理: &quot; + event.getOrderId());        if (&quot;async_error&quot;.equals(event.getOrderId())) &#123;            throw new RuntimeException(&quot;异步任务处理失败: 外部API超时&quot;);        &#125;        System.out.println(&quot;   &gt; 异步任务完成&quot;);    &#125;&#125;\n\nimport org.springframework.util.ErrorHandler;// 5. 同步事件全局异常处理器public class SyncEventErrorHandler implements ErrorHandler &#123;    @Override    public void handleError(Throwable t) &#123;        System.out.println(&quot;\\n[全局同步异常处理器] 捕获异常: &quot; + t.getMessage());        System.out.println(&quot;   &gt; 执行全局处理: 记录错误日志并告警&quot;);    &#125;&#125;\n\nimport org.springframework.aop.interceptor.AsyncUncaughtExceptionHandler;import java.lang.reflect.Method;// 6. 异步事件全局异常处理器public class AsyncEventErrorHandler implements AsyncUncaughtExceptionHandler &#123;    @Override    public void handleUncaughtException(Throwable ex, Method method, Object... params) &#123;        System.out.println(&quot;\\n[全局异步异常处理器] 捕获异常: &quot; + ex.getMessage());        System.out.println(&quot;   &gt; 方法: &quot; + method.getName());        System.out.println(&quot;   &gt; 参数类型: &quot; + params[0].getClass().getSimpleName());        System.out.println(&quot;   &gt; 执行补偿操作: 记录日志并通知管理员&quot;);    &#125;&#125;\n\nimport org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.ApplicationEventPublisher;import org.springframework.stereotype.Service;@Servicepublic class OrderService &#123;    @Autowired    private ApplicationEventPublisher eventPublisher;    public void placeOrder(String orderId) &#123;        System.out.println(&quot;\\n[主流程] 开始处理订单: &quot; + orderId);        try &#123;            // 模拟核心业务逻辑            System.out.println(&quot;   &gt; 创建订单记录&quot;);            // 发布订单事件            eventPublisher.publishEvent(new OrderEvent(this, orderId));            System.out.println(&quot;[主流程] 订单处理完成: &quot; + orderId);        &#125; catch (Exception e) &#123;            System.out.println(&quot;[主流程异常] &quot; + e.getMessage());        &#125;    &#125;&#125;\n\nimport org.springframework.aop.interceptor.AsyncUncaughtExceptionHandler;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.event.ApplicationEventMulticaster;import org.springframework.context.event.SimpleApplicationEventMulticaster;import org.springframework.core.task.SimpleAsyncTaskExecutor;import org.springframework.scheduling.annotation.AsyncConfigurer;import org.springframework.scheduling.annotation.EnableAsync;@Configuration@EnableAsyncpublic class EventConfig implements AsyncConfigurer &#123;    // 配置异步事件广播器    @Bean(name = &quot;applicationEventMulticaster&quot;)    public ApplicationEventMulticaster applicationEventMulticaster() &#123;        SimpleApplicationEventMulticaster eventMulticaster = new SimpleApplicationEventMulticaster();        // 设置同步事件的异常处理器        eventMulticaster.setErrorHandler(new SyncEventErrorHandler());        // 设置异步执行器        eventMulticaster.setTaskExecutor(new SimpleAsyncTaskExecutor());        return eventMulticaster;    &#125;    // 异步异常处理配置    @Override    public AsyncUncaughtExceptionHandler getAsyncUncaughtExceptionHandler() &#123;        return new AsyncEventErrorHandler();    &#125;&#125;\n\npackage com.cylong.applicationeventpublisherdemo;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.CommandLineRunner;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.scheduling.annotation.EnableAsync;@SpringBootApplication@EnableAsyncpublic class EventExceptionDemoApplication implements CommandLineRunner &#123;    public static void main(String[] args) &#123;        SpringApplication.run(EventExceptionDemoApplication.class, args);    &#125;    @Autowired    private OrderService orderService;    @Override    public void run(String... args) throws InterruptedException &#123;        System.out.println(&quot;\\n===== 测试正常订单 =====&quot;);        orderService.placeOrder(&quot;order_2023001&quot;);        Thread.sleep(500); // 等待异步任务完成        System.out.println(&quot;\\n===== 测试库存不足订单 =====&quot;);        orderService.placeOrder(&quot;error_stock&quot;);        Thread.sleep(500);        System.out.println(&quot;\\n===== 测试支付失败订单 =====&quot;);        orderService.placeOrder(&quot;error_payment&quot;);        Thread.sleep(500);        System.out.println(&quot;\\n===== 测试异步异常订单 =====&quot;);        orderService.placeOrder(&quot;async_error&quot;);        Thread.sleep(1000); // 确保异步任务完成    &#125;&#125;\n\n输出结果===== 测试正常订单 =====[主流程] 开始处理订单: order_2023001   &gt; 创建订单记录[主流程] 订单处理完成: order_2023001[库存服务] 处理订单: order_2023001[支付服务] 处理订单: order_2023001[通知服务] 处理订单: order_2023001   &gt; 已发送订单确认通知   &gt; 库存锁定成功   &gt; 支付处理成功[异步服务] 开始处理: order_2023001   &gt; 异步任务完成===== 测试库存不足订单 =====[主流程] 开始处理订单: error_stock   &gt; 创建订单记录[库存服务] 处理订单: error_stock[支付服务] 处理订单: error_stock   &gt; 支付处理成功   ! [库存异常] 库存不足，商品A缺货   &gt; 执行本地补偿: 释放预留资源[主流程] 订单处理完成: error_stock[通知服务] 处理订单: error_stock[异步服务] 开始处理: error_stock[全局同步异常处理器] 捕获异常: 通知服务失败: 短信配额不足   &gt; 执行全局处理: 记录错误日志并告警   &gt; 异步任务完成===== 测试支付失败订单 =====[主流程] 开始处理订单: error_payment   &gt; 创建订单记录[库存服务] 处理订单: error_payment   &gt; 库存锁定成功[支付服务] 处理订单: error_payment[主流程] 订单处理完成: error_payment   ! [支付异常] 支付失败，信用卡余额不足   &gt; 执行本地补偿: 取消支付预授权[通知服务] 处理订单: error_payment   &gt; 已发送订单确认通知[异步服务] 开始处理: error_payment   &gt; 异步任务完成===== 测试异步异常订单 =====[主流程] 开始处理订单: async_error   &gt; 创建订单记录[库存服务] 处理订单: async_error   &gt; 库存锁定成功[支付服务] 处理订单: async_error   &gt; 支付处理成功[主流程] 订单处理完成: async_error[通知服务] 处理订单: async_error   &gt; 已发送订单确认通知[异步服务] 开始处理: async_error[全局异步异常处理器] 捕获异常: 异步任务处理失败: 外部API超时   &gt; 方法: handleAsyncTask   &gt; 参数类型: OrderEvent   &gt; 执行补偿操作: 记录日志并通知管理员\n\n异常处理机制解析\n局部异常捕获：\n在监听器内部使用 try-catch 块\n示例：库存和支付服务的监听器\n特点：异常不会传播，不影响其他监听器\n适用场景：需要独立处理的业务异常\n\n\n全局同步异常处理：\n实现 ErrorHandler 接口\n通过 SimpleApplicationEventMulticaster.setErrorHandler() 注册\n捕获所有未处理的同步事件异常\n示例：SyncEventErrorHandler\n特点：集中处理未被捕获的同步异常\n\n\n全局异步异常处理：\n实现 AsyncUncaughtExceptionHandler 接口\n通过 AsyncConfigurer 配置\n捕获所有未处理的异步事件异常\n示例：AsyncEventErrorHandler\n特点：专用于异步执行场景\n\n\n\n三种处理方式适用场景\n\n\n处理方式\n适用场景\n优点\n缺点\n\n\n\n局部捕获\n需要独立处理的业务异常\n精确控制，不影响其他监听器\n代码重复可能性高\n\n\n全局同步处理\n未捕获的同步异常统一处理\n集中管理，避免异常传播\n无法获取完整上下文\n\n\n全局异步处理\n所有未捕获的异步异常\n统一处理异步任务失败\n无法访问原始方法参数\n\n\n注意事项作用域限制// 监听器需是 Spring 管理的 Bean@Componentpublic class UserRegisterListener &#123;...&#125;\n\n事件源（source）的作用// 可获取事件发布者信息if (event.getSource() instanceof UserService) &#123;    // 特殊处理&#125;\n\n监听器执行顺序监听器按注册顺序执行（可通过 @Order 调整）\n@Order(1)  // 数字越小优先级越高@EventListenerpublic void firstListener(UserRegisterEvent event) &#123;...&#125;\n\n异步处理@Async  // 启用异步@EventListenerpublic void asyncHandle(UserRegisterEvent event) &#123;    // 耗时操作&#125;\n\n需在配置类添加 @EnableAsync\n@SpringBootApplication@EnableAsyncpublic class ApplicationEventPublisherDemoApplication &#123;\tpublic static void main(String[] args) &#123;\t\tConfigurableApplicationContext context = SpringApplication.run(ApplicationEventPublisherDemoApplication.class, args);\t\tUserService userService = context.getBean(UserService.class);\t\tuserService.registerUser(&quot;cylong&quot;);\t&#125;&#125;\n\n事件继承// 监听父类事件会同时接收子类事件public class VIPRegisterEvent extends UserRegisterEvent &#123;...&#125;\n\n\n监听 UserRegisterEvent 会接收到所有子类事件\n使用 @EventListener(classes = VIPRegisterEvent.class) 限定具体类型\n\n@EventListener(classes = VIPRegisterEvent.class)public void handleEvent(UserRegisterEvent event) &#123;    System.out.println(&quot;[注解监听] 新 VIP 用户注册: &quot; + event.getUsername());&#125;\n\n性能建议\n避免在监听器执行耗时操作（默认同步，可以切换为异步）\n单个事件避免注册过多监听器\n\n错误处理\n监听器异常会传播到发布者\n需要时添加单独异常处理\n\n通过 ApplicationEventPublisher 可实现优雅的业务解耦，但需根据场景权衡同步/异步机制。在实际项目中，建议将核心业务与辅助操作（邮件、日志等）通过事件分离，提升系统可维护性。\n\n","categories":["Java"],"tags":["Java","Spring","SpringBoot","后端框架","事件驱动","ApplicationEventPublisher","观察者模式"]},{"title":"矩阵原地旋转：分层遍历与坐标映射实现（LeetCode 48）","url":"/blog/2025/06/27/rotate-image/","content":"\n题目描述给定一个 n × n 的二维矩阵 matrix 表示一个图像。请你将图像顺时针旋转 90 度。你必须在 原地 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。\n原地算法：在计算机科学中，一个原地算法（in-place algorithm）是一种使用小的，固定数量的额外之空间来转换资料的算法。当算法执行时，输入的资料通常会被要输出的部分覆盖掉。不是原地算法有时候称为非原地（not-in-place）或不得其所（out-of-place）。\n示例 1:\n\n\n输入：matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]输出：[[7, 4, 1], [8, 5, 2], [9, 6, 3]]\n\n示例 2:\n\n\n输入：matrix = [[5, 1, 9, 11], [2, 4, 8, 10], [13, 3, 6, 7], [15, 14, 12, 16]]输出：[[15, 13, 2, 5], [14, 3, 4, ], [12, 6, 8, 9], [16, 7, 10, 11]]\n\n提示:\n\nn == matrix.length == matrix[i].length\n1 &lt;= n &lt;= 20\n-1000 &lt;= matrix[i][j] &lt;= 1000\n\n\n\n原地旋转法核心思路通过一次旋转四个元素实现原地旋转。对于每个位置 (i, j)，我们找到旋转后对应的三个位置，使用临时变量完成四个元素的交换。旋转过程如下：\n\n左上角元素 → 右上角\n右上角元素 → 右下角\n右下角元素 → 左下角\n左下角元素 → 左上角\n\n旋转公式推导\n设矩阵大小为 n，对于位置 (i, j)：\n\n左上角：(i, j)\n右上角：(j, n-1-i)\n右下角：(n-1-i, n-1-j)\n左下角：(n-1-j, i)\n\ntemp = matrix[i][j]matrix[i][j] = matrix[n-1-j][i]         // 左下 → 左上matrix[n-1-j][i] = matrix[n-1-i][n-1-j] // 右下 → 左下matrix[n-1-i][n-1-j] = matrix[j][n-1-i] // 右上 → 右下matrix[j][n-1-i] = temp                 // 左上 → 右上\n\n遍历范围优化\n\n当 n 为偶数时：遍历左上角 1/4 区域\n当 n 为奇数时：遍历左上角 1/4 + 中心轴 区域\n\n\n\n\n图形化示例\n初始矩阵：[1, 2, 3][4, 5, 6][7, 8, 9]步骤1：旋转(0,0)元素  1 → 3的位置，3 → 9的位置，9 → 7的位置，7 → 1的位置得到：[7, 2, 1][4, 5, 6][9, 8, 3]步骤2：旋转(0,1)元素  2 → 6的位置，6 → 8的位置，8 → 4的位置，4 → 2的位置得到：[7, 4, 1][8, 5, 2][9, 6, 3]最终结果：[7, 4, 1][8, 5, 2][9, 6, 3]\n\n代码实现public void rotate(int[][] matrix) &#123;    int n = matrix.length;    for (int i = 0; i &lt; n / 2; ++i) &#123;        for (int j = 0; j &lt; (n + 1) / 2; ++j) &#123;            int temp = matrix[i][j];            matrix[i][j] = matrix[n - j - 1][i];            matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1];            matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1];            matrix[j][n - i - 1] = temp;        &#125;    &#125;&#125;\n\n复杂度分析\n时间复杂度：O(n²)，其中 n 是 matrix 的边长。\n空间复杂度：O(1)，为原地旋转。\n\n翻转组合法核心思路通过两次翻转操作实现旋转：\n\n水平翻转（上下翻转）：matrix[i][j] ↔ matrix[n-1-i][j]\n以水平中线为轴交换元素\n行索引变换：i → n-1-i\n列索引不变\n\n\n主对角线翻转（转置）：matrix[i][j] ↔ matrix[j][i]\n沿主对角线（左上到右下）交换元素\n行列索引互换：(i, j) → (j, i)\n只需遍历对角线一侧避免重复\n\n\n\n推导步骤\n\n水平翻转后：(i, j) → (n-1-i, j)\n主对角线翻转后：(n-1-i, j) → (j, n-1-i)\n与顺时针旋转 90° 的坐标变换一致：(i, j) → (j, n-1-i)\n\n图形化示例\n初始矩阵：[1, 2, 3][4, 5, 6][7, 8, 9]步骤1：水平翻转  交换行：第0行 ↔ 第2行得到：[7, 8, 9][4, 5, 6][1, 2, 3]步骤2：主对角线翻转  交换(1,0)和(0,1)：8 ↔ 4  交换(2,0)和(0,2)：9 ↔ 1 → 但实际顺序：先1和9交换，再2和6交换  详细过程：    [7, 8, 9]    [7, 4, 9]    [7, 4, 1]    [7, 4, 1]    [4, 5, 6] → [8, 5, 6] → [8, 5, 6] → [8, 5, 2]    [1, 2, 3]    [1, 2, 3]    [9, 2, 3]    [9, 6, 3]最终结果：[7, 4, 1][8, 5, 2][9, 6, 3]\n\n代码实现public void rotate(int[][] matrix) &#123;    int n = matrix.length;    // 水平翻转    for (int i = 0; i &lt; n / 2; ++i) &#123;        for (int j = 0; j &lt; n; ++j) &#123;            int temp = matrix[i][j];            matrix[i][j] = matrix[n - i - 1][j];            matrix[n - i - 1][j] = temp;        &#125;    &#125;    // 主对角线翻转    for (int i = 0; i &lt; n; ++i) &#123;        for (int j = 0; j &lt; i; ++j) &#123;            int temp = matrix[i][j];            matrix[i][j] = matrix[j][i];            matrix[j][i] = temp;        &#125;    &#125;&#125;\n\n复杂度分析\n时间复杂度：O(n²)，其中 n 是 matrix 的边长。\n空间复杂度：O(1)，为原地旋转。\n\n总结\n\n\n解法\n时间复杂度\n空间复杂度\n优势\n\n\n\n原地旋转法\nO(n²)\nO(1)\n通过数学推导直接定位旋转位置，单次循环完成操作\n\n\n翻转组合法\nO(n²)\nO(1)\n利用基础操作组合实现旋转，逻辑清晰易理解\n\n\n两种方法都满足原地旋转的要求，在实际应用中可根据具体场景选择。翻转组合法更易于理解和扩展（如逆时针旋转只需调整翻转顺序），而原地旋转法在理论上减少了一半的交换操作。\n来源\n48. 旋转图像 | 力扣（LeetCode）\n\n\n","categories":["LeetCode"],"tags":["Java","LeetCode","学习笔记","数组","矩阵","LeetCode中等"]},{"title":"双指针法求解链表交点（LeetCode 160）","url":"/blog/2025/07/01/intersection-of-two-linked-lists/","content":"\n题目描述给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。题目数据保证整个链式结构中不存在环。\n图示两个链表在节点 c1 开始相交：\n\n\n注意：函数返回结果后，链表必须保持其原始结构 。\n自定义评测：评测系统的输入如下（你设计的程序不适用此输入）：\n\nintersectVal - 相交的起始节点的值。如果不存在相交节点，这一值为 0\nlistA - 第一个链表\nlistB - 第二个链表\nskipA - 在 listA 中（从头节点开始）跳到交叉节点的节点数\nskipB - 在 listB 中（从头节点开始）跳到交叉节点的节点数\n评测系统将根据这些输入创建链式数据结构，并将两个头节点 headA 和 headB 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被视作正确答案。\n\n示例 1:\n\n\n输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5, 6, 1, 8, 4, 5], skipA = 2, skipB = 3输出：Intersected at &#39;8&#39;解释：\n\n相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。\n从各自的表头开始算起，链表 A 为 [4, 1, 8, 4, 5]，链表 B 为 [5, 6, 1, 8, 4, 5]。\n在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。\n请注意相交节点的值不为 1，因为在链表 A 和链表 B 之中值为 1 的节点 (A 中第二个节点和 B 中第三个节点) 是不同的节点。换句话说，它们在内存中指向两个不同的位置，而链表 A 和链表 B 中值为 8 的节点 (A 中第三个节点，B 中第四个节点) 在内存中指向相同的位置。\n\n\n示例 2:\n\n\n输入：intersectVal = 2, listA = [1, 9, 1, 2, 4], listB = [3, 2, 4], skipA = 3, skipB = 1输出：Intersected at &#39;2&#39;解释：\n\n相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。\n从各自的表头开始算起，链表 A 为 [1, 9, 1, 2, 4]，链表 B 为 [3, 2, 4]。\n在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。\n\n\n示例 3:\n\n\n输入：intersectVal = 0, listA = [2, 6, 4], listB = [1, 5], skipA = 3, skipB = 2输出：No intersection解释：\n\n从各自的表头开始算起，链表 A 为 [2, 6, 4]，链表 B 为 [1, 5]。\n由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。\n这两个链表不相交，因此返回 null 。\n\n\n提示:\n\nlistA 中节点数目为 m\nlistB 中节点数目为 n\n1 &lt;= m, n &lt;= 3 * 10^4\n1 &lt;= Node.val &lt;= 10^5\n0 &lt;= skipA &lt;= m\n0 &lt;= skipB &lt;= n\n如果 listA 和 listB 没有交点，intersectVal 为 0\n如果 listA 和 listB 有交点，intersectVal == listA[skipA] == listB[skipB]\n\n\n\n哈希集合法核心思路使用哈希集合存储链表 A 的所有节点，然后遍历链表 B 的每个节点，判断该节点是否在集合中。第一个出现在集合中的节点就是相交节点。\n算法步骤\n\n创建一个 HashSet 用于存储链表 A 的节点。\n遍历链表 A，将每个节点添加到集合中。\n遍历链表 B，对于每个节点：\n如果该节点存在于集合中，则返回该节点（相交节点）。\n否则继续遍历下一个节点。\n\n\n如果遍历完链表 B 都没有找到相交节点，返回 null。\n\n动态过程示例\n以链表 A：1 → 2 → 3 → 4 和链表 B：5 → 3 → 4 为例（相交节点为 3）：\n\n遍历 A，将节点 1、2、3、4 加入集合。\n遍历 B：\n节点 5：不在集合中。\n节点 3：在集合中 → 返回节点 3。\n\n\n\n代码实现public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123;    Set&lt;ListNode&gt; set = new HashSet&lt;&gt;();    ListNode cur = headA;    while (cur != null) &#123;        set.add(cur);        cur = cur.next;    &#125;    cur = headB;    while (cur != null) &#123;        // 这里用 HashSet 可以保证查询复杂度为 O(1)        if (set.contains(cur)) &#123;            return cur;        &#125;        cur = cur.next;    &#125;    return null;&#125;\n\n复杂度分析\n时间复杂度：O(m + n)，其中 m 和 n 分别是链表 A 和 B 的长度。需要遍历两个链表各一次。\n空间复杂度：O(m)，存储链表 A 的节点集合。\n\n双指针法（浪漫相遇法）核心思路使用两个指针 pA 和 pB 分别遍历链表 A 和 B。当 pA 到达链表 A 末尾时，重定位到链表 B 的头节点；当 pB 到达链表 B 末尾时，重定位到链表 A 的头节点。若两链表相交，则 pA 和 pB 必在相交点相遇；若不相交，则最终会同时到达 null。\n算法步骤\n\n\n考虑构建两个节点指针 A​ , B 分别指向两链表头节点 headA , headB ，首个公共节点为 node，做如下操作：\n\n指针 A 先遍历完链表 headA ，再开始遍历链表 headB ，当走到 node 时，共走步数为：a + (b - c)\n指针 B 先遍历完链表 headB ，再开始遍历链表 headA ，当走到 node 时，共走步数为：b + (a - c)\n\n如下式所示，此时指针 A , B 重合，并有两种情况：a + (b - c) = b + (a - c)\n\n若两链表 有 公共尾部 (即 c &gt; 0 ) ：指针 A , B 同时指向「第一个公共节点」node 。\n若两链表 无 公共尾部 (即 c = 0 ) ：指针 A , B 同时指向 null 。\n\n代码实现public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123;    if (headA == null || headB == null) &#123;        return null;    &#125;    ListNode pA = headA;    ListNode pB = headB;    while (pA != pB) &#123;        pA = pA == null ? headB : pA.next;        pB = pB == null ? headA : pB.next;    &#125;    return pA;&#125;\n\n复杂度分析\n时间复杂度：O(m + n)，最多遍历两链表各两次。\n空间复杂度：O(1)，仅使用两个指针。\n\n总结\n\n\n解法\n时间复杂度\n空间复杂度\n适用场景\n\n\n\n哈希集合法\nO(m + n)\nO(m)\n无空间限制时，代码简单\n\n\n双指针法\nO(m + n)\nO(1)\n要求常数空间，逻辑巧妙高效\n\n\n双指针法通过重定位指针创造等长路径，巧妙解决了链表长度差异问题，是空间优化的最佳方案。实际应用中，若内存允许可优先选择哈希法（代码更直观），若要求严格空间复杂度则必须使用双指针法。\n力扣的一些浪漫留言\n当我在我的路上走过一遍依然没有遇见你时，那么我会接着来到你走过的路走一遍，如果我们心有灵犀，那么我们终将相遇。 - 局部降雨\n我走过你走过的路，只为和你相拥。 - Flow\n错的人就算走过了对方的路也还是会错过。 - 小虎\n我住长江头，君住长江尾，日夜思君不见君，共饮一江水。君奔长江头，我赴长江尾，辗转轮回未谋面，邂逅时好美！ - 瓦罗兰的文艺复兴\n世界上没有真正的感同身受直到你走过我走过的路。 - Cool PaninipeO\n\n来源\n160. 相交链表 | 力扣（LeetCode）160. 相交链表 | 题解 | Krahets160. 相交链表 | 题解 | 灵茶山艾府\n\n\n","categories":["LeetCode"],"tags":["Java","LeetCode","学习笔记","链表","哈希表","双指针","LeetCode简单"]},{"title":"哈希表与双向链表实现LRU缓存（LeetCode 146）","url":"/blog/2025/07/07/lru-cache/","content":"\n题目描述请你设计并实现一个满足 LRU (最近最少使用) 缓存 约束的数据结构。实现 LRUCache 类：\n\nLRUCache(int capacity) 以正整数作为容量 capacity 初始化 LRU 缓存。\nint get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。\nvoid put(int key, int value) 如果关键字 key 已经存在，则变更其数据值 value ；如果不存在，则向缓存中插入该组 key-value 。如果插入操作导致关键字数量超过 capacity ，则应该逐出最久未使用的关键字。\n函数 get 和 put 必须以 O(1) 的平均时间复杂度运行。\n\n示例 1:\n\n输入：[&quot;LRUCache&quot;, &quot;put&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;get&quot;, &quot;get&quot;][[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]输出：[null, null, null, 1, null, -1, null, -1, 3, 4]解释：LRUCache lRUCache = new LRUCache(2);lRUCache.put(1, 1); // 缓存是 {1=1}lRUCache.put(2, 2); // 缓存是 {1=1, 2=2}lRUCache.get(1);    // 返回 1lRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3}lRUCache.get(2);    // 返回 -1 (未找到)lRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3}lRUCache.get(1);    // 返回 -1 (未找到)lRUCache.get(3);    // 返回 3lRUCache.get(4);    // 返回 4\n\n提示:\n\n1 &lt;= capacity &lt;= 3000\n0 &lt;= key &lt;= 10000\n0 &lt;= value &lt;= 10^5\n最多调用 2 * 10^5 次 get 和 put\n\n\n\n哈希表 + 双向链表核心思路使用 哈希表 实现 O(1) 时间复杂度的键值查找，通过 双向链表 维护访问顺序：\n\n链表头部存放最近访问的节点\n链表尾部存放最久未使用的节点\n伪头尾节点简化链表边界操作\n\n关键操作图解\n添加节点到头部head &lt;-&gt; [node] &lt;-&gt; oldFirst1. node.prev = head2. node.next = head.next3. head.next.prev = node4. head.next = node\n移除节点prevNode &lt;-&gt; [node] &lt;-&gt; nextNode=&gt; prevNode &lt;-&gt; nextNode1. node.prev.next = node.next2. node.next.prev = node.prev\n\n\n\n代码实现public class LRUCache &#123;    static class DLinkedNode &#123;        int key;        int value;        DLinkedNode prev;        DLinkedNode next;        public DLinkedNode() &#123;        &#125;        public DLinkedNode(int key, int value) &#123;            this.key = key;            this.value = value;        &#125;    &#125;    private final Map&lt;Integer, DLinkedNode&gt; cache = new HashMap&lt;&gt;();    private int size;    private final int capacity;    private final DLinkedNode head;    private final DLinkedNode tail;    public LRUCache(int capacity) &#123;        this.size = 0;        this.capacity = capacity;        // 使用伪头部和伪尾部节点        head = new DLinkedNode();        tail = new DLinkedNode();        head.next = tail;        tail.prev = head;    &#125;    public int get(int key) &#123;        DLinkedNode node = cache.get(key);        if (node == null) &#123;            return -1;        &#125;        // 如果 key 存在，先通过哈希表定位，再移到头部        moveToHead(node);        return node.value;    &#125;    public void put(int key, int value) &#123;        DLinkedNode node = cache.get(key);        if (node == null) &#123;            // 如果 key 不存在，创建一个新的节点            DLinkedNode newNode = new DLinkedNode(key, value);            // 添加进哈希表            cache.put(key, newNode);            // 添加至双向链表的头部            addToHead(newNode);            size++;            if (size &gt; capacity) &#123;                // 如果超出容量，删除双向链表的尾部节点                DLinkedNode tail = removeTail();                // 删除哈希表中对应的项                cache.remove(tail.key);                size--;            &#125;        &#125; else &#123;            // 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部            node.value = value;            moveToHead(node);        &#125;    &#125;    private void addToHead(DLinkedNode node) &#123;        node.prev = head;        node.next = head.next;        head.next.prev = node;        head.next = node;    &#125;    private void removeNode(DLinkedNode node) &#123;        node.prev.next = node.next;        node.next.prev = node.prev;    &#125;    private void moveToHead(DLinkedNode node) &#123;        removeNode(node);        addToHead(node);    &#125;    private DLinkedNode removeTail() &#123;        DLinkedNode res = tail.prev;        removeNode(res);        return res;    &#125;&#125;\n\n复杂度分析\n时间复杂度：O(1)，哈希表查找 O(1)，链表操作 O(1)。\n空间复杂度：O(n)，哈希表存储 n 个键值对，双向链表存储 n+2 个节点（含伪头尾）。\n\n应用场景\n数据库查询缓存\n浏览器页面缓存\n操作系统页面置换算法\n微服务API响应缓存\n\n关键点总结：哈希表保证快速访问，双向链表维护访问顺序，伪头尾节点简化边界处理。通过O(1)时间完成核心操作，是工业级LRU缓存的经典实现。\n来源\n146. LRU 缓存 | 力扣（LeetCode）\n\n\n","categories":["LeetCode"],"tags":["Java","LeetCode","学习笔记","链表","哈希表","LeetCode中等","双向链表","缓存"]},{"title":"多源 BFS 解决腐烂橘子问题（LeetCode 994）","url":"/blog/2025/07/09/rotting-oranges/","content":"\n题目描述在给定的 m x n 网格 grid 中，每个单元格可以有以下三个值之一：\n\n值 0 代表空单元格；\n值 1 代表新鲜橘子；\n值 2 代表腐烂的橘子。\n\n每分钟，腐烂的橘子 周围 4 个方向上相邻 的新鲜橘子都会腐烂。返回直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 -1 。\n示例 1:\n\n\n输入：grid = [[2, 1, 1],[1, 1, 0],[0, 1, 1]]输出：4\n\n示例 2:\n\n输入：grid = [[2, 1, 1],[0, 1, 1],[1, 0, 1]]输出：-1解释：左下角的橘子（第 2 行， 第 0 列）永远不会腐烂，因为腐烂只会发生在 4 个方向上。\n\n示例 3:\n\n输入：grid = [[0, 2]]输出：0解释：因为 0 分钟时已经没有新鲜橘子了，所以答案就是 0 。\n\n提示:\n\nm == grid.length\nn == grid[i].length\n1 &lt;= m, n &lt;= 10\ngrid[i][j] 仅为 0、1 或 2\n\n\n\n多源 BFS（广度优先搜索）核心思路使用多源 BFS 模拟橘子腐烂的过程：\n\n初始化：遍历整个网格，统计新鲜橘子的数量，并将所有腐烂橘子的坐标加入队列。\nBFS遍历：从所有腐烂橘子同时开始扩散。\n每一轮处理当前队列中的所有腐烂橘子（同一分钟）。\n每个腐烂橘子使其上下左右相邻的新鲜橘子腐烂。\n新腐烂的橘子加入队列（下一分钟继续扩散）。\n\n\n结果判断：BFS 结束后，若还有新鲜橘子剩余，返回 -1；否则返回分钟数。\n\n代码实现class Solution &#123;    public int orangesRotting(int[][] grid) &#123;        int rows = grid.length;        int cols = grid[0].length;        int minutes = 0;        // 记录新鲜橘子数量        int freshCount = 0;        // BFS 队列        Queue&lt;int[]&gt; queue = new ArrayDeque&lt;&gt;();                // 四个方向：上、下、左、右        int[][] directions = &#123;&#123;-1, 0&#125;, &#123;1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;&#125;;                // 初始化：统计新鲜橘子，并将腐烂橘子入队        for (int i = 0; i &lt; rows; i++) &#123;            for (int j = 0; j &lt; cols; j++) &#123;                if (grid[i][j] == 1) &#123;                    freshCount++;                &#125; else if (grid[i][j] == 2) &#123;                    queue.offer(new int[]&#123;i, j&#125;);                &#125;            &#125;        &#125;                // BFS 开始：当还有新鲜橘子且队列不为空时        while (freshCount &gt; 0 &amp;&amp; !queue.isEmpty()) &#123;            // 当前层的橘子数量            int levelSize = queue.size();                        // 处理当前层的所有腐烂橘子            for (int i = 0; i &lt; levelSize; i++) &#123;                int[] cur = queue.poll();                                // 向四个方向扩散                for (int[] dir : directions) &#123;                    int x = cur[0] + dir[0];                    int y = cur[1] + dir[1];                                        // 检查边界且是否为新鲜橘子                    if (x &gt;= 0 &amp;&amp; x &lt; rows &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; cols &amp;&amp; grid[x][y] == 1) &#123;                        // 标记为腐烂                        grid[x][y] = 2;                        // 新鲜橘子减少                        freshCount--;                        // 新腐烂橘子入队                        queue.offer(new int[]&#123;x, y&#125;);                    &#125;                &#125;            &#125;            // 当前层处理完毕，分钟数增加            minutes++;        &#125;                // 若还有剩余新鲜橘子，返回 -1；否则返回分钟数        return freshCount == 0 ? minutes : -1;    &#125;&#125;\n\n复杂度分析\n时间复杂度：O(mn)，每个网格单元最多被访问一次。\n空间复杂度：O(mn)，最坏情况下队列需要存储所有腐烂橘子。\n\n总结\n多源BFS：所有初始腐烂橘子同时开始扩散，确保分钟计数准确。\n层级处理：通过记录队列大小处理同一分钟的所有腐烂橘子。\n边界判断：扩散时检查网格边界和橘子状态。\n提前终止：当新鲜橘子数为 0 时，可提前结束 BFS。\n\n该解法高效地模拟了橘子腐烂的过程，时间复杂度与网格大小成正比，是最优解法。\n来源\n994. 腐烂的橘子 | 力扣（LeetCode）994. 腐烂的橘子 | 题解 | Krahets994. 腐烂的橘子 | 题解 | 灵茶山艾府\n\n\n","categories":["LeetCode"],"tags":["Java","LeetCode","学习笔记","数组","队列","矩阵","广度优先搜索","LeetCode中等"]},{"title":"前缀树（Trie）实现：插入、搜索与前缀匹配操作（LeetCode 208）","url":"/blog/2025/07/10/implement-trie-prefix-tree/","content":"\n题目描述Trie（发音类似 “try”）或者说 前缀树 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补全和拼写检查。请你实现 Trie 类：\n\nTrie() 初始化前缀树对象。\nvoid insert(String word) 向前缀树中插入字符串 word 。\nboolean search(String word) 如果字符串 word 在前缀树中，返回 true（即，在检索之前已经插入）；否则，返回 false 。\nboolean startsWith(String prefix) 如果之前已经插入的字符串 word 的前缀之一为 prefix ，返回 true ；否则，返回 false 。\n\n示例 1:\n\n输入：[&quot;Trie&quot;, &quot;insert&quot;, &quot;search&quot;, &quot;search&quot;, &quot;startsWith&quot;, &quot;insert&quot;, &quot;search&quot;][[], [&quot;apple&quot;], [&quot;apple&quot;], [&quot;app&quot;], [&quot;app&quot;], [&quot;app&quot;], [&quot;app&quot;]]输出：[null, null, true, false, true, null, true]解释：Trie trie = new Trie();trie.insert(&quot;apple&quot;);trie.search(&quot;apple&quot;);   // 返回 Truetrie.search(&quot;app&quot;);     // 返回 Falsetrie.startsWith(&quot;app&quot;); // 返回 Truetrie.insert(&quot;app&quot;);trie.search(&quot;app&quot;);     // 返回 True\n\n提示:\n\n1 &lt;= word.length, prefix.length &lt;= 2000\nword 和 prefix 仅由小写英文字母组成\ninsert、search 和 startsWith 调用次数总计不超过 3 * 10^4 次\n\n\n\n基于数组的 Trie 实现前缀树（Trie）是一种高效检索字符串数据集中的键的树形数据结构。它广泛应用于搜索引擎、拼写检查、自动补全等场景。Trie 的核心思想是利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较。\nTrie 节点设计class Node &#123;    // 子节点数组，每个位置对应一个字母（a-z）    Node[] son = new Node[26];    // 标记当前节点是否为单词结尾    boolean end;&#125;\n\nTrie 类实现class Trie &#123;    // 根节点，不存储实际字符    private final Node root = new Node();    public Trie() &#123;&#125;        /**     * 向 Trie 中插入一个单词     *      * @param word 要插入的单词     */    public void insert(String word) &#123;        // 从根节点开始        Node cur = root;        for (char c : word.toCharArray()) &#123;            // 将字符转换为数组索引（0-25）            c -= &#x27;a&#x27;;            // 如果当前字符对应的路径不存在            if (cur.son[c] == null) &#123;                // 创建新节点                cur.son[c] = new Node();            &#125;            // 移动到子节点            cur = cur.son[c];        &#125;        // 标记单词结束        cur.end = true;    &#125;        /**     * 搜索 Trie 中是否存在完整单词     *      * @param word 要搜索的单词     * @return 存在返回 true，否则返回 false     */    public boolean search(String word) &#123;        // 需要完全匹配（状态值 2）        return find(word) == 2;    &#125;        /**     * 检查 Trie 中是否有以指定前缀开头的单词     *      * @param prefix 要检查的前缀     * @return 存在返回 true，否则返回 false     */    public boolean startsWith(String prefix) &#123;        // 只要路径存在即可（状态值 1 或 2）        return find(prefix) != 0;    &#125;        /**     * 内部查找方法，返回匹配状态     *      * @param word 要查找的单词或前缀     * @return 0: 未找到, 1: 前缀存在, 2: 完整单词存在     */    private int find(String word) &#123;        Node cur = root;        for (char c : word.toCharArray()) &#123;            // 字符转索引            c -= &#x27;a&#x27;;            if (cur.son[c] == null) &#123;                // 路径中断，未找到                return 0;            &#125;            // 继续向下查找            cur = cur.son[c];        &#125;        // 路径存在，检查是否为完整单词        return cur.end ? 2 : 1;    &#125;&#125;\n\n复杂度分析\n时间复杂度：\n插入操作：O(L)，其中 L 是插入单词的长度。需要遍历单词的每个字符。\n搜索操作：O(L)，其中 L 是搜索单词的长度。需要遍历单词的每个字符。\n前缀搜索：O(L)，其中 L 是前缀的长度。需要遍历前缀的每个字符。\n\n\n空间复杂度：\n最坏情况：O(MN)，其中 M 是单词的平均长度，N 是插入的单词数量。每个字符都需要一个节点。\n最佳情况：当单词共享大量前缀时，空间复杂度会显著降低。\n\n\n\n总结\n节点结构：每个节点包含一个长度为 26 的子节点数组（对应 26 个小写字母）和一个结束标志。\n路径创建：在插入过程中，如果路径不存在则动态创建新节点。\n结束标志：单词插入完成后，在最后一个节点标记结束标志。\n查找优化：使用统一的 find 方法处理完整单词查找和前缀查找，避免代码重复。\n字符转换：通过 c - &#39;a&#39; 将字符转换为数组索引（0-25），高效访问子节点。\n\nTrie 是一种高效处理字符串相关问题的数据结构，特别适合前缀匹配的场景。本文实现的 Trie 结构清晰，操作高效，时间复杂度均为线性级别。理解 Trie 的工作原理对于解决字符串搜索、自动补全等问题至关重要。实际应用中，可以根据需求扩展 Trie 功能，如添加词频统计、删除操作等。\n来源\n208. 实现 Trie (前缀树) | 力扣（LeetCode）208. 实现 Trie (前缀树) | 题解 | 灵茶山艾府\n\n\n","categories":["LeetCode"],"tags":["Java","LeetCode","学习笔记","字符串","树","字典树","LeetCode中等"]},{"title":"二叉树原地展开为链表：简洁递归解法深入分析（LeetCode 114）","url":"/blog/2025/07/14/flatten-binary-tree-to-linked-list/","content":"\n题目描述给你二叉树的根结点 root ，请你将它展开为一个单链表：\n\n展开后的单链表应该同样使用 TreeNode ，其中 right 子指针指向链表中下一个结点，而左子指针始终为 null。\n展开后的单链表应该与二叉树 先序遍历 顺序相同。\n\n示例 1:\n\n\n输入：root = [1, 2, 5, 3, 4, null, 6]输出：[1, null, 2, null, 3, null, 4, null, 5, null, 6]\n\n示例 2:\n\n输入：root = []输出：[]\n\n示例 3:\n\n输入：root = [0]输出：[0]\n\n提示:\n\n树中结点数在范围 [0, 2000] 内\n-100 &lt;= Node.val &lt;= 100\n\n\n\n递归后序遍历核心思路核心思路采用递归后序遍历：\n\n递归展开左右子树\n将左子树插入根节点与右子树之间\n遍历至新链表末端连接右子树\n\n代码实现public void flatten(TreeNode root) &#123;    if (root == null) return;        // 递归展开左右子树    flatten(root.left);    flatten(root.right);        TreeNode left = root.left;   // 保存左子树    TreeNode right = root.right; // 保存右子树        root.left = null;            // 切断左指针    root.right = left;           // 左子树变为右子树        // 遍历至新链表末端    TreeNode cur = root;    while (cur.right != null) &#123;        cur = cur.right;    &#125;    cur.right = right;          // 连接原右子树&#125;\n\n算法流程详解\n递归终止：当前节点为 null 时返回\n后序遍历：\n先递归处理左子树（flatten(root.left)）\n再递归处理右子树（flatten(root.right)）\n\n\n链表重组：\n保存当前左右子树引用\n将左子树作为新的右子树（root.right = left）\n遍历新右子树找到末端节点\n将原右子树接在末端节点后\n\n\n\n关键步骤图示原始结构：   root   /  \\left  right重组后结构：root  \\  left (展开的链表)     \\    right (展开的链表)注：这里把 left 和 right 变为叶子节点，会更好理解\n\n复杂度分析\n时间复杂度：O(n)，每个节点被访问两次，递归展开时访问一次，寻找链表末端时访问一次。\n空间复杂度：O(n)，递归栈深度取决于树的高度，最坏情况（链状树）空间复杂度为 O(n)，平衡树情况为 O(logn)。\n\n关键点总结\n后序遍历顺序：必须保证左右子树都已展开成链表后才能进行根节点的重组。\n链表拼接细节：左子树插入后需遍历到末端再连接右子树，注意切断左指针避免结构混乱。\n原地修改：直接修改节点指针，不新建数据结构。\n\n来源\n114. 二叉树展开为链表 | 力扣（LeetCode）\n\n\n","categories":["LeetCode"],"tags":["Java","LeetCode","学习笔记","链表","树","二叉树","深度优先搜索","LeetCode中等"]},{"title":"全排列问题的递归回溯解法实现（LeetCode 46）","url":"/blog/2025/07/15/permutations/","content":"\n题目描述给定一个不含重复数字的数组 nums ，返回其所有可能的全排列 。你可以按任意顺序返回答案。\n示例 1:\n\n输入：nums = [1, 2, 3]输出：[[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]\n\n示例 2:\n\n输入：nums = [0, 1]输出：[[0, 1], [1, 0]]\n\n示例 3:\n\n输入：nums = [1]输出：[[1]]\n\n提示:\n\n1 &lt;= nums.length &lt;= 6\n-10 &lt;= nums[i] &lt;= 10\nnums 中的所有整数互不相同\n\n\n\n回溯算法（DFS）核心思路全排列问题可以通过回溯算法解决。核心思想是：每次从数组中选取一个未被使用的元素加入当前路径，当路径长度等于数组长度时，将当前路径加入结果集。之后通过回溯撤销选择，尝试其他可能的元素。\n\n初始化结果列表 ans 和当前路径列表 t\n创建布尔数组 vis 标记元素是否已被使用\n使用深度优先搜索（DFS）进行回溯：\n终止条件：当前路径长度等于数组长度，将路径拷贝加入结果集\n遍历选择：遍历数组中的每个元素：\n如果元素未被使用，则将其加入路径并标记为已使用\n递归进入下一层决策树\n回溯：移除路径最后一个元素并取消标记\n\n\n\n\n\n代码实现public static List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123;    List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;();    List&lt;Integer&gt; t = new ArrayList&lt;&gt;();    boolean[] vis = new boolean[nums.length];    dfs(nums, ans, t, vis);    return ans;&#125;public static void dfs(int[] nums, List&lt;List&lt;Integer&gt;&gt; ans, List&lt;Integer&gt; t, boolean[] vis) &#123;    // 当路径长度等于数组长度时，将当前路径加入结果集    if (t.size() == nums.length) &#123;        // 注意创建新列表        ans.add(new ArrayList&lt;&gt;(t));        return;    &#125;    // 遍历所有元素    for (int i = 0; i &lt; nums.length; i++) &#123;        // 如果元素未被使用        if (!vis[i]) &#123;            // 做出选择            t.add(nums[i]);            vis[i] = true;            // 递归进入下一层            dfs(nums, ans, t, vis);            // 撤销选择（回溯）            t.removeLast();            vis[i] = false;        &#125;    &#125;&#125;\n\n关键步骤图示初始状态\nLevel 0:   t = []   vis = [false, false, false]\n第一层递归（选择第一个元素）\n选择1:  t = [1]  vis = [true, false, false]  └─ 进入第二层递归\n第二层递归（选择第二个元素）\n选择2:  t = [1, 2]  vis = [true, true, false]  └─ 进入第三层递归\n第三层递归（选择第三个元素）\n选择3:  t = [1, 2, 3] → 添加到结果集 ✅  vis = [true, true, true]  ├─ 回溯：移除3  │   t = [1, 2]  │   vis = [true, true, false]  └─ 回溯：移除2      t = [1]      vis = [true, false, false]\n第二层递归的其他选择\n选择3:  t = [1, 3]  vis = [true, false, true]  └─ 进入第三层递归      选择2:        t = [1, 3, 2] → 添加到结果集 ✅        vis = [true, true, true]        ├─ 回溯：移除2        │   t = [1, 3]        │   vis = [true, false, true]        └─ 回溯：移除3            t = [1]            vis = [true, false, false]\n第一层递归的其他选择\n选择2:  t = [2]  vis = [false, true, false]  └─ 进入第二层递归      选择1:        t = [2, 1]        vis = [true, true, false]        └─ 进入第三层递归            选择3:              t = [2, 1, 3] → 添加到结果集 ✅              vis = [true, true, true]      选择3:        t = [2, 3]        vis = [false, true, true]        └─ 进入第三层递归            选择1:              t = [2, 3, 1] → 添加到结果集 ✅              vis = [true, true, true]选择3:  t = [3]  vis = [false, false, true]  └─ 进入第二层递归      选择1:        t = [3, 1]        vis = [true, false, true]        └─ 进入第三层递归            选择2:              t = [3, 1, 2] → 添加到结果集 ✅              vis = [true, true, true]      选择2:        t = [3, 2]        vis = [false, true, true]        └─ 进入第三层递归            选择1:              t = [3, 2, 1] → 添加到结果集 ✅              vis = [true, true, true]\n\n复杂度分析\n时间复杂度：O(n*n!)，共有 n! 个排列，每个排列需要 O(n) 时间复制到结果列表中。\n空间复杂度：O(n)，递归栈深度为 n，标记数组 vis 占用 O(n) 空间（结果空间不计入复杂度分析）。\n\n关键点总结\n回溯模板：遵循”选择-递归-撤销”的标准回溯框架\n路径拷贝：ans.add(new ArrayList&lt;&gt;(t)) 创建新列表避免引用问题\n状态标记：使用 vis 数组高效判断元素是否可用\n去重处理：题目已说明数组无重复数字，无需额外去重逻辑\n\n回溯法是解决排列组合问题的经典方法，通过深度优先搜索遍历所有可能性，配合状态标记保证每个元素只使用一次。掌握回溯算法的核心框架和剪枝技巧，能高效解决此类问题。\n来源\n46. 全排列 | 力扣（LeetCode）46. 全排列 | 题解 | liweiwei141946. 全排列 | 题解 | Krahets\n\n\n","categories":["LeetCode"],"tags":["Java","LeetCode","学习笔记","数组","深度优先搜索","LeetCode中等","回溯"]},{"title":"反转链表的指针操作与递归实现（LeetCode 206）","url":"/blog/2025/07/22/reverse-linked-list/","content":"\n题目描述给你单链表的头节点 head ，请你反转链表，并返回反转后的链表。\n示例 1:\n\n\n输入：head = [1, 2, 3, 4, 5]输出：[5, 4, 3, 2, 1]\n\n示例 2:\n\n\n输入：head = [1, 2]输出：[2, 1]\n\n示例 3:\n\n输入：head = []输出：[]\n\n提示:\n\n链表中节点的数目范围是 [0, 5000]\n-5000 &lt;= Node.val &lt;= 5000\n\n\n\n迭代法核心思路通过遍历链表，逐个修改节点指向。使用双指针 pre 和 cur，每次将 cur.next 指向 pre 并同步移动指针，直到遍历完成。\n代码实现class Solution &#123;    public ListNode reverseList(ListNode head) &#123;        ListNode cur = head;        ListNode pre = null;        while (cur != null) &#123;            ListNode tmp = cur.next; // 暂存后继节点            cur.next = pre;          // 反转当前节点的指针            pre = cur;               // pre 移动至当前节点            cur = tmp;               // cur 访问下一节点        &#125;        return pre; // 返回新头节点    &#125;&#125;\n\n动态变化过程以链表 1→2→3→NULL 为例\n初始状态pre = null, cur = 1\nNULL ← ?    1 → 2 → 3 → NULL ↑          ↑pre        cur\n\n第一步暂存 cur.next = 2 → 修改 1.next = pre(null) → 移动 pre=1, cur=2\nNULL ← 1    2 → 3 → NULL       ↑    ↑      pre  cur\n\n第二步暂存 cur.next = 3 → 修改 2.next = pre(1) → 移动 pre=2, cur=3\nNULL ← 1 ← 2    3 → NULL           ↑    ↑          pre  cur\n\n第三步暂存 cur.next = NULL → 修改 3.next = pre(2) → 移动 pre=3, cur=NULL\nNULL ← 1 ← 2 ← 3    NULL               ↑     ↑              pre   cur\n\n结果返回 pre = 3，新链表为 3→2→1→NULL。\n复杂度分析\n时间复杂度：O(n)，遍历链表一次。\n空间复杂度：O(1)，仅使用常量额外空间。\n\n递归法核心思路递归到链表末端，回溯时逐层反转节点指向：\n\n递归终止条件：当前节点为尾节点（head.next == null）。\n回溯过程中，将下一节点的 next 指向当前节点，并断开原指向。\n\n代码实现class Solution &#123;    public ListNode reverseList(ListNode head) &#123;        if (head == null || head.next == null) &#123;            return head; // 终止条件：返回尾节点作为新头节点        &#125;        ListNode newHead = reverseList(head.next); // 递归至下一层        head.next.next = head; // 反转指向：下一节点指向当前节点        head.next = null;      // 断开当前节点原指向        return newHead;        // 始终返回新头节点    &#125;&#125;\n\n动态变化过程以链表 1→2→3→NULL 为例\n递归至最深层当 head=3 时满足终止条件，返回 3 作为 newHead\n1 → 2 → 3 → NULL        ↑      head (返回3)\n\n回溯第一层\n\nhead=2\n执行 head.next.next = head → 3.next = 2\n执行 head.next = null → 2.next = NULL1 → 2    3 → 2 → NULL   // 3指向2，2指向NULL    ↑    ↑  head newHead(3)\n\n\n\n回溯第二层\n\nhead=1\n执行 head.next.next = head → 2.next = 1\n执行 head.next = null → 1.next = NULL  1    2 → 1 → NULL   // 2指向1，1指向NULL  ↑    ↑head newHead(3)\n\n\n\n最终结果返回 newHead = 3，链表变为 3→2→1→NULL。\n复杂度分析\n时间复杂度：O(n)，递归深度为链表长度。\n空间复杂度：O(n)，递归栈深度为链表长度。\n\n总结\n\n\n解法\n时间复杂度\n空间复杂度\n优点\n\n\n\n迭代法\nO(n)\nO(1)\n空间复杂度低\n\n\n递归法\nO(n)\nO(n)\n代码简洁\n\n\n来源\n206. 反转链表 | 力扣（LeetCode）\n\n\n","categories":["LeetCode"],"tags":["Java","LeetCode","学习笔记","链表","双指针","递归","LeetCode中等","回溯","迭代"]},{"title":"链表数字相加的逆序计算：栈实现与进位处理（LeetCode 445）","url":"/blog/2025/07/25/add-two-numbers-ii/","content":"\n题目描述给你两个非空链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。你可以假设除了数字 0 之外，这两个数字都不会以零开头。\n示例 1:\n\n\n输入：l1 = [7, 2, 4, 3], l2 = [5, 6, 4]输出：[7, 8, 0, 7]\n\n示例 2:\n\n输入：l1 = [2, 4, 3], l2 = [5, 6, 4]输出：[8, 0, 7]\n\n示例 3:\n\n输入：l1 = [0], l2 = [0]输出：[0]\n\n提示:\n\n链表的长度范围为 [1, 100]\n0 &lt;= node.val &lt;= 9\n输入数据保证链表代表的数字无前导 0\n\n\n\n栈辅助法核心思路利用栈的 后进先出 特性实现逆序处理：\n\n遍历两个链表，将节点值分别压入两个栈。\n同时弹出栈顶元素进行相加，处理进位。\n使用头插法构建结果链表。\n\n代码实现public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123;    Stack&lt;Integer&gt; stack1 = new Stack&lt;&gt;();    Stack&lt;Integer&gt; stack2 = new Stack&lt;&gt;();        // 将链表节点值压入栈中    while (l1 != null) &#123;        stack1.push(l1.val);        l1 = l1.next;    &#125;    while (l2 != null) &#123;        stack2.push(l2.val);        l2 = l2.next;    &#125;        int carry = 0; // 进位值    ListNode resultHead = null; // 结果链表头节点        // 当栈非空或仍有进位时继续计算    while (!stack1.isEmpty() || !stack2.isEmpty() || carry != 0) &#123;        // 获取栈顶元素（栈空则取0）        int num1 = stack1.isEmpty() ? 0 : stack1.pop();        int num2 = stack2.isEmpty() ? 0 : stack2.pop();                // 计算当前位的和        int sum = num1 + num2 + carry;        carry = sum / 10; // 更新进位        int digit = sum % 10; // 当前位的值                // 使用头插法构建结果链表        ListNode newNode = new ListNode(digit);        newNode.next = resultHead;        resultHead = newNode;    &#125;        return resultHead;&#125;\n\n复杂度分析\n时间复杂度：O(max(m, n))，其中 m 和 n 分别为两个链表的长度。\n空间复杂度：O(m + n)，用于存储两个栈。\n\n链表反转法核心思路通过反转链表实现低位对齐：\n\n反转两个输入链表。\n按照两数相加I的方法计算（低位对齐）\n反转结果链表得到最终答案\n\n参考：\n\n两数相加 I | 笑话人生反转链表的指针操作与递归实现（LeetCode 206）| 笑话人生\n\n代码实现public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123;    // 反转两个链表    l1 = reverseList(l1);    l2 = reverseList(l2);    // 相加得到结果链表（低位在前）    ListNode l3 = addTwo(l1, l2);    // 反转结果链表得到高位在前    return reverseList(l3);&#125;// 反转链表（LeetCode 206）private ListNode reverseList(ListNode head) &#123;    ListNode cur = head, pre = null;    while (cur != null) &#123;        ListNode tmp = cur.next; // 保存下一个节点        cur.next = pre;          // 当前节点指向前一个节点        pre = cur;               // 前节点后移        cur = tmp;               // 当前节点后移    &#125;    return pre; // 返回反转后的头节点&#125;// 两数相加（LeetCode 2）private ListNode addTwo(ListNode l1, ListNode l2) &#123;    ListNode dummy = new ListNode(0); // 虚拟头节点    ListNode cur = dummy;    int carry = 0; // 进位值        while (l1 != null || l2 != null) &#123;        int x = (l1 != null) ? l1.val : 0;        int y = (l2 != null) ? l2.val : 0;        int sum = x + y + carry;                carry = sum / 10; // 计算进位        cur.next = new ListNode(sum % 10); // 创建新节点        cur = cur.next; // 移动当前指针                // 移动链表指针        if (l1 != null) l1 = l1.next;        if (l2 != null) l2 = l2.next;    &#125;        // 处理最后的进位    if (carry &gt; 0) &#123;        cur.next = new ListNode(carry);    &#125;    return dummy.next;&#125;\n\n复杂度分析\n时间复杂度：O(max(m, n))，反转链表和相加操作都是线性时间。\n空间复杂度：O(1)，仅使用固定数量的指针。\n\n总结\n\n\n解法\n时间复杂度\n空间复杂度\n优点\n\n\n\n栈辅助法\nO(max(m, n))\nO(m + n)\n逻辑清晰，但需要额外栈空间\n\n\n链表反转法\nO(max(m, n))\nO(1)\n空间更优，但修改了原始链表\n\n\n两种方法各有优劣：\n\n栈辅助法：不修改原始链表，逻辑清晰，但需要额外空间存储栈。\n链表反转法：空间效率更高，但会修改原始链表结构。\n\n在实际应用中，如果原始链表不可修改，应选择栈辅助法；若空间效率是首要考虑因素，则链表反转法更优。两种方法的时间复杂度相同，都能高效解决该问题。\n来源\n445. 两数相加 II | 力扣（LeetCode）\n\n\n","categories":["LeetCode"],"tags":["Java","LeetCode","学习笔记","链表","双指针","递归","栈","LeetCode中等","回溯","迭代"]},{"title":"两次二分查找定位有序数组元素边界（LeetCode 34）","url":"/blog/2025/08/02/find-first-and-last-position-of-element-in-sorted-array/","content":"\n题目描述给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。如果数组中不存在目标值 target，返回 [-1, -1]。\n你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。\n示例 1:\n\n输入：nums = [5, 7, 7, 8, 8, 10], target = 8输出：[3, 4]\n\n示例 2:\n\n输入：nums = [5, 7, 7, 8, 8, 10], target = 6输出：[-1, -1]\n\n示例 3:\n\n输入：nums = [], target = 0输出：[-1, -1]\n\n提示:\n\n0 &lt;= nums.length &lt;= 10^5\n-10^9 &lt;= nums[i] &lt;= 10^9\nnums 是一个非递减数组\n-10^9 &lt;= target &lt;= 10^9\n\n\n\n一次二分查找 + 线性扩展核心思路使用二分查找找到目标值，然后向左右两边扩展，直到找到边界。\n代码实现public int[] searchRange(int[] nums, int target) &#123;    // 处理空数组的情况    if (nums == null || nums.length == 0) &#123;        return new int[]&#123;-1, -1&#125;;    &#125;    int left = 0;    int right = nums.length - 1;    while (left &lt;= right) &#123;        // 计算中间位置，防止整数溢出        int mid = left + (right - left) / 2;        if (nums[mid] == target) &#123;            // 找到目标值，继续向两边搜索边界            int start = mid, end = mid;            // 向左搜索起始位置            while (start &gt; left &amp;&amp; nums[start - 1] == target) &#123;                start--;            &#125;            // 向右搜索结束位置            while (end &lt; right &amp;&amp; nums[end + 1] == target) &#123;                end++;            &#125;            return new int[] &#123;start, end&#125;;        &#125; else if (nums[mid] &lt; target) &#123;            left = mid + 1;        &#125; else &#123;            right = mid - 1;        &#125;    &#125;    return new int[] &#123;-1, -1&#125;;&#125;\n\n复杂度分析\n时间复杂度：平均情况 O(logn)，但在最坏情况下（整个数组都是目标值）会退化为 O(n)。\n空间复杂度：O(1)，仅使用常数空间存储变量。\n\n两次二分查找核心思路分别使用二分查找寻找左边界和右边界：\n\n查找左边界：第一个等于目标值的位置\n初始化左右指针 left = 0, right = nums.length - 1\n当 left &lt;= right 时循环：\n计算中间位置 mid = left + (right - left) / 2（防止整数溢出）\n如果 nums[mid] &gt;= target，则目标可能在左半部分，调整右指针 right = mid - 1\n否则调整左指针 left = mid + 1\n\n\n循环结束后，检查 left 是否在数组范围内且对应值等于 target\n\n\n查找右边界：最后一个等于目标值的位置\n初始化左右指针 left = 0, right = nums.length - 1\n当 left &lt;= right 时循环：\n计算中间位置 mid = left + (right - left) / 2（防止整数溢出）\n如果 nums[mid] &lt;= target，则目标可能在右半部分，调整左指针 left = mid + 1\n否则调整右指针 right = mid - 1\n\n\n循环结束后，检查 right 是否在数组范围内且对应值等于 target\n\n\n\n代码实现class Solution &#123;    public int[] searchRange(int[] nums, int target) &#123;        // 处理空数组的情况        if (nums == null || nums.length == 0) &#123;            return new int[]&#123;-1, -1&#125;;        &#125;                int leftBound = findLeftBound(nums, target);        int rightBound = findRightBound(nums, target);        return new int[]&#123;leftBound, rightBound&#125;;    &#125;        // 查找左边界：第一个等于 target 的位置    private int findLeftBound(int[] nums, int target) &#123;        int left = 0, right = nums.length - 1;        while (left &lt;= right) &#123;            int mid = left + (right - left) / 2;            if (nums[mid] &gt;= target) &#123;                right = mid - 1; // 向左搜索            &#125; else &#123;                left = mid + 1;            &#125;        &#125;        // 检查 left 是否在数组范围内且等于 target        if (left &lt; nums.length &amp;&amp; nums[left] == target) &#123;            return left;        &#125;        return -1;    &#125;        // 查找右边界：最后一个等于 target 的位置    private int findRightBound(int[] nums, int target) &#123;        int left = 0, right = nums.length - 1;        while (left &lt;= right) &#123;            int mid = left + (right - left) / 2;            if (nums[mid] &lt;= target) &#123;                left = mid + 1; // 向右搜索            &#125; else &#123;                right = mid - 1;            &#125;        &#125;        // 检查 right 是否在数组范围内且等于 target        if (right &gt;= 0 &amp;&amp; nums[right] == target) &#123;            return right;        &#125;        return -1;    &#125;&#125;\n\n复杂度分析\n时间复杂度：O(log n)。两次二分查找，每次时间复杂度为 O(log n)。\n空间复杂度：O(1)。仅使用常数空间存储变量。\n\n总结\n\n\n解法\n时间复杂度\n空间复杂度\n优点\n\n\n\n一次二分查找 + 线性扩展\nO(n)（最坏）O(log n)（最好）\nO(1)\n代码简单，但是受重复元素数量影响，最坏情况时间复杂度 O(n)\n\n\n两次二分查找\nO(log n)（所有情况）\nO(1)\n保证最坏情况下的性能，不受输入数据分布影响\n\n\n最终推荐两次二分查找方法，它严格满足题目要求，在各种情况下都能保持高效稳定的性能，是符合题目要求的解法。\n来源\n34. 在排序数组中查找元素的第一个和最后一个位置 | 力扣（LeetCode）\n\n\n","categories":["LeetCode"],"tags":["Java","LeetCode","学习笔记","数组","二分查找","LeetCode中等"]},{"title":"min-stack","url":"/blog/2025/08/17/min-stack/","content":"\n题目描述设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。实现 MinStack 类:\n\nMinStack() 初始化堆栈对象。\nvoid push(int val) 将元素 val 推入堆栈。\nvoid pop() 删除堆栈顶部的元素。\nint top() 获取堆栈顶部的元素。\nint getMin() 获取堆栈中的最小元素。\n\n示例 1:\n\n输入：[&quot;MinStack&quot;, &quot;push&quot;, &quot;push&quot;, &quot;push&quot;, &quot;getMin&quot;, &quot;pop&quot;, &quot;top&quot;, &quot;getMin&quot;][[], [-2], [0], [-3], [], [], [], []]输出：[null, null, null, null, -3, null, 0, -2]解释：MinStack minStack = new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.getMin();   –&gt; 返回 -3.minStack.pop();minStack.top();      –&gt; 返回 0.minStack.getMin();   –&gt; 返回 -2.\n\n提示:\n\n-2^31 &lt;= val &lt;= 2^31 - 1\npop、top 和 getMin 操作总是在 非空栈 上调用\npush, pop, top, 和 getMin 最多被调用 3 * 10^4 次\n\n\n\n解题思路要设计一个支持常数时间内获取最小元素的栈，我们可以使用两个栈：\n\n主栈（stack）：用于存储所有元素，支持常规的栈操作。\n最小栈（minStack）：用于存储当前主栈中每个状态下的最小值。\n\n关键操作\npush 操作：\n将元素推入主栈。\n如果最小栈为空，或者新元素小于等于最小栈的栈顶元素，则将该元素也推入最小栈。\n\n\npop 操作：\n弹出主栈的栈顶元素。\n如果弹出的元素等于最小栈的栈顶元素，则同时弹出最小栈的栈顶元素（表示当前最小值已从主栈移除）。\n\n\ntop 操作：直接返回主栈的栈顶元素。\ngetMin 操作：直接返回最小栈的栈顶元素（即当前栈中的最小元素）。\n\n为什么使用“小于等于”？当新元素等于最小栈的栈顶元素时，也需要将其推入最小栈。这样可以确保当多个相同的最小值存在时，最小栈中也有多个相同的值，避免在 pop 操作时提前将最小值移除。\n代码实现import java.util.LinkedList;class MinStack &#123;    // 注意不要使用 Stack 类，因为它继承自 Vector，是同步的，会导致一些性能问题    private LinkedList&lt;Integer&gt; stack;    // 主栈    private LinkedList&lt;Integer&gt; minStack; // 最小栈    public MinStack() &#123;        stack = new LinkedList&lt;&gt;();        minStack = new LinkedList&lt;&gt;();    &#125;        public void push(int val) &#123;        stack.push(val);        // 如果最小栈为空，或者新元素小于等于最小栈栈顶元素，则推入最小栈        if (minStack.isEmpty() || val &lt;= minStack.peek()) &#123;            minStack.push(val);        &#125;    &#125;        public void pop() &#123;        int popVal = stack.pop();        // 如果弹出的元素等于最小栈栈顶元素，则同时弹出最小栈栈顶元素        if (popVal == minStack.peek()) &#123;            minStack.pop();        &#125;    &#125;        public int top() &#123;        return stack.peek();    &#125;        public int getMin() &#123;        return minStack.peek();    &#125;&#125;\n\n复杂度分析\n时间复杂度：\npush：O(1)，每次操作只涉及常数次栈操作。\npop：O(1)，每次操作只涉及常数次栈操作。\ntop：O(1)，直接返回主栈栈顶元素。\ngetMin：O(1)，直接返回最小栈栈顶元素。\n\n\n空间复杂度：O(n)，最坏情况下需要两个栈存储所有元素，但最小栈在优化后通常存储元素较少。\n\n总结通过使用两个栈（主栈和最小栈），我们可以在常数时间内完成所有栈操作并获取当前栈中的最小元素。最小栈的维护确保了在每次操作后都能快速获取到最小值，而主栈则负责常规的栈功能。这种方法既高效又易于实现，是解决此类问题的经典方案。\n来源\n155. 最小栈 | 力扣（LeetCode）\n\n\n","categories":["LeetCode"],"tags":["Java","LeetCode","学习笔记","栈","LeetCode中等"]}]