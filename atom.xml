<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>笑话人生</title>
  
  <subtitle>年华易逝 懂得珍惜</subtitle>
  <link href="https://www.cylong.com/atom.xml" rel="self"/>
  
  <link href="https://www.cylong.com/"/>
  <updated>2025-07-09T13:44:07.000Z</updated>
  <id>https://www.cylong.com/</id>
  
  <author>
    <name>cylong</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>腐烂的橘子</title>
    <link href="https://www.cylong.com/blog/2025/07/09/rotting-oranges/"/>
    <id>https://www.cylong.com/blog/2025/07/09/rotting-oranges/</id>
    <published>2025-07-09T13:44:07.000Z</published>
    <updated>2025-07-09T13:44:07.000Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>在给定的 <code>m x n</code> 网格 <code>grid</code> 中，每个单元格可以有以下三个值之一：</p><ul><li>值 <code>0</code> 代表空单元格；</li><li>值 <code>1</code> 代表新鲜橘子；</li><li>值 <code>2</code> 代表腐烂的橘子。</li></ul><p>每分钟，腐烂的橘子 周围 <code>4</code> 个方向上相邻 的新鲜橘子都会腐烂。返回直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 <code>-1</code> 。</p><p><strong>示例 1:</strong></p><img src="/blog/2025/07/09/rotting-oranges/oranges.png" class=""><blockquote><p><strong>输入：</strong><code>grid = [[2, 1, 1],[1, 1, 0],[0, 1, 1]]</code><br><strong>输出：</strong><code>4</code></p></blockquote><p><strong>示例 2:</strong></p><blockquote><p><strong>输入：</strong><code>grid = [[2, 1, 1],[0, 1, 1],[1, 0, 1]]</code><br><strong>输出：</strong><code>-1</code><br><strong>解释：</strong>左下角的橘子（第 <code>2</code> 行， 第 <code>0</code> 列）永远不会腐烂，因为腐烂只会发生在 <code>4</code> 个方向上。</p></blockquote><p><strong>示例 3:</strong></p><blockquote><p><strong>输入：</strong><code>grid = [[0, 2]]</code><br><strong>输出：</strong><code>0</code><br><strong>解释：</strong>因为 <code>0</code> 分钟时已经没有新鲜橘子了，所以答案就是 <code>0</code> 。</p></blockquote><p><strong>提示:</strong></p><ul><li><code>m == grid.length</code></li><li><code>n == grid[i].length</code></li><li><code>1 &lt;= m, n &lt;= 10</code></li><li><code>grid[i][j]</code> 仅为 <code>0</code>、<code>1</code> 或 <code>2</code></li></ul><span id="more"></span><h1 id="多源-BFS（广度优先搜索）"><a href="#多源-BFS（广度优先搜索）" class="headerlink" title="多源 BFS（广度优先搜索）"></a>多源 BFS（广度优先搜索）</h1><h2 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h2><p>使用多源 <code>BFS</code> 模拟橘子腐烂的过程：</p><ol><li><strong>初始化：</strong>遍历整个网格，统计新鲜橘子的数量，并将所有腐烂橘子的坐标加入队列。</li><li><strong>BFS遍历：</strong>从所有腐烂橘子同时开始扩散。<ul><li>每一轮处理当前队列中的所有腐烂橘子（同一分钟）。</li><li>每个腐烂橘子使其上下左右相邻的新鲜橘子腐烂。</li><li>新腐烂的橘子加入队列（下一分钟继续扩散）。</li></ul></li><li><strong>结果判断：</strong><code>BFS</code> 结束后，若还有新鲜橘子剩余，返回 <code>-1</code>；否则返回分钟数。</li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">orangesRotting</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> grid.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cols</span> <span class="operator">=</span> grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">minutes</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 记录新鲜橘子数量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">freshCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// BFS 队列</span></span><br><span class="line">        Queue&lt;<span class="type">int</span>[]&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 四个方向：上、下、左、右</span></span><br><span class="line">        <span class="type">int</span>[][] directions = &#123;&#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 初始化：统计新鲜橘子，并将腐烂橘子入队</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    freshCount++;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (grid[i][j] == <span class="number">2</span>) &#123;</span><br><span class="line">                    queue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;i, j&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// BFS 开始：当还有新鲜橘子且队列不为空时</span></span><br><span class="line">        <span class="keyword">while</span> (freshCount &gt; <span class="number">0</span> &amp;&amp; !queue.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 当前层的橘子数量</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">levelSize</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 处理当前层的所有腐烂橘子</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; levelSize; i++) &#123;</span><br><span class="line">                <span class="type">int</span>[] cur = queue.poll();</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 向四个方向扩散</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span>[] dir : directions) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> cur[<span class="number">0</span>] + dir[<span class="number">0</span>];</span><br><span class="line">                    <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> cur[<span class="number">1</span>] + dir[<span class="number">1</span>];</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 检查边界且是否为新鲜橘子</span></span><br><span class="line">                    <span class="keyword">if</span> (x &gt;= <span class="number">0</span> &amp;&amp; x &lt; rows &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; cols &amp;&amp; grid[x][y] == <span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="comment">// 标记为腐烂</span></span><br><span class="line">                        grid[x][y] = <span class="number">2</span>;</span><br><span class="line">                        <span class="comment">// 新鲜橘子减少</span></span><br><span class="line">                        freshCount--;</span><br><span class="line">                        <span class="comment">// 新腐烂橘子入队</span></span><br><span class="line">                        queue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;x, y&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当前层处理完毕，分钟数增加</span></span><br><span class="line">            minutes++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 若还有剩余新鲜橘子，返回 -1；否则返回分钟数</span></span><br><span class="line">        <span class="keyword">return</span> freshCount == <span class="number">0</span> ? minutes : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li><strong>时间复杂度：</strong><code>O(mn)</code>，每个网格单元最多被访问一次。</li><li><strong>空间复杂度：</strong><code>O(mn)</code>，最坏情况下队列需要存储所有腐烂橘子。</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li><strong>多源BFS：</strong>所有初始腐烂橘子同时开始扩散，确保分钟计数准确。</li><li><strong>层级处理：</strong>通过记录队列大小处理同一分钟的所有腐烂橘子。</li><li><strong>边界判断：</strong>扩散时检查网格边界和橘子状态。</li><li><strong>提前终止：</strong>当新鲜橘子数为 <code>0</code> 时，可提前结束 <code>BFS</code>。</li></ol><p>该解法高效地模拟了橘子腐烂的过程，时间复杂度与网格大小成正比，是最优解法。</p><h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><blockquote><p><a href="https://leetcode.cn/problems/rotting-oranges/description/" title="994. 腐烂的橘子 | 力扣（LeetCode）">994. 腐烂的橘子 | 力扣（LeetCode）</a><br><a href="https://leetcode.cn/problems/rotting-oranges/solutions/3712941/bfszhu-shi-fei-chang-qing-xi-ban-ben-by-jzug4/" title="994. 腐烂的橘子 | 题解 | Bravo">994. 腐烂的橘子 | 题解 | Krahets</a><br><a href="https://leetcode.cn/problems/rotting-oranges/solutions/2773461/duo-yuan-bfsfu-ti-dan-pythonjavacgojsrus-yfmh/" title="994. 腐烂的橘子 | 题解 | 灵茶山艾府">994. 腐烂的橘子 | 题解 | 灵茶山艾府</a></p></blockquote><hr>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;在给定的 &lt;code&gt;m x n&lt;/code&gt; 网格 &lt;code&gt;grid&lt;/code&gt; 中，每个单元格可以有以下三个值之一：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;值 &lt;code&gt;0&lt;/code&gt; 代表空单元格；&lt;/li&gt;
&lt;li&gt;值 &lt;code&gt;1&lt;/code&gt; 代表新鲜橘子；&lt;/li&gt;
&lt;li&gt;值 &lt;code&gt;2&lt;/code&gt; 代表腐烂的橘子。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;每分钟，腐烂的橘子 周围 &lt;code&gt;4&lt;/code&gt; 个方向上相邻 的新鲜橘子都会腐烂。返回直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 &lt;code&gt;-1&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;img src=&quot;/blog/2025/07/09/rotting-oranges/oranges.png&quot; class=&quot;&quot;&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt;&lt;code&gt;grid = [[2, 1, 1],[1, 1, 0],[0, 1, 1]]&lt;/code&gt;&lt;br&gt;&lt;strong&gt;输出：&lt;/strong&gt;&lt;code&gt;4&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt;&lt;code&gt;grid = [[2, 1, 1],[0, 1, 1],[1, 0, 1]]&lt;/code&gt;&lt;br&gt;&lt;strong&gt;输出：&lt;/strong&gt;&lt;code&gt;-1&lt;/code&gt;&lt;br&gt;&lt;strong&gt;解释：&lt;/strong&gt;左下角的橘子（第 &lt;code&gt;2&lt;/code&gt; 行， 第 &lt;code&gt;0&lt;/code&gt; 列）永远不会腐烂，因为腐烂只会发生在 &lt;code&gt;4&lt;/code&gt; 个方向上。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例 3:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt;&lt;code&gt;grid = [[0, 2]]&lt;/code&gt;&lt;br&gt;&lt;strong&gt;输出：&lt;/strong&gt;&lt;code&gt;0&lt;/code&gt;&lt;br&gt;&lt;strong&gt;解释：&lt;/strong&gt;因为 &lt;code&gt;0&lt;/code&gt; 分钟时已经没有新鲜橘子了，所以答案就是 &lt;code&gt;0&lt;/code&gt; 。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;提示:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;m == grid.length&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;n == grid[i].length&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= m, n &amp;lt;= 10&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;grid[i][j]&lt;/code&gt; 仅为 &lt;code&gt;0&lt;/code&gt;、&lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;2&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://www.cylong.com/categories/LeetCode/"/>
    
    
    <category term="Java" scheme="https://www.cylong.com/tags/Java/"/>
    
    <category term="LeetCode" scheme="https://www.cylong.com/tags/LeetCode/"/>
    
    <category term="学习笔记" scheme="https://www.cylong.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="数组" scheme="https://www.cylong.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="队列" scheme="https://www.cylong.com/tags/%E9%98%9F%E5%88%97/"/>
    
    <category term="矩阵" scheme="https://www.cylong.com/tags/%E7%9F%A9%E9%98%B5/"/>
    
    <category term="广度优先搜索" scheme="https://www.cylong.com/tags/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
    <category term="LeetCode中等" scheme="https://www.cylong.com/tags/LeetCode%E4%B8%AD%E7%AD%89/"/>
    
  </entry>
  
  <entry>
    <title>LRU 缓存</title>
    <link href="https://www.cylong.com/blog/2025/07/07/lru-cache/"/>
    <id>https://www.cylong.com/blog/2025/07/07/lru-cache/</id>
    <published>2025-07-07T14:05:52.000Z</published>
    <updated>2025-07-07T14:05:52.000Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>请你设计并实现一个满足 <strong>LRU (最近最少使用) 缓存</strong> 约束的数据结构。<br>实现 <code>LRUCache</code> 类：</p><ul><li><code>LRUCache(int capacity)</code> 以正整数作为容量 <code>capacity</code> 初始化 <code>LRU</code> 缓存。</li><li><code>int get(int key)</code> 如果关键字 <code>key</code> 存在于缓存中，则返回关键字的值，否则返回 <code>-1</code> 。</li><li><code>void put(int key, int value)</code> 如果关键字 <code>key</code> 已经存在，则变更其数据值 <code>value</code> ；如果不存在，则向缓存中插入该组 <code>key-value</code> 。如果插入操作导致关键字数量超过 <code>capacity</code> ，则应该逐出最久未使用的关键字。</li><li>函数 <code>get</code> 和 <code>put</code> 必须以 <code>O(1)</code> 的平均时间复杂度运行。</li></ul><p><strong>示例 1:</strong></p><blockquote><p><strong>输入：</strong><br><code>[&quot;LRUCache&quot;, &quot;put&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;get&quot;, &quot;get&quot;]</code><br><code>[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]</code><br><strong>输出：</strong><code>[null, null, null, 1, null, -1, null, -1, 3, 4]</code><br><strong>解释：</strong><br>LRUCache lRUCache = new LRUCache(2);<br>lRUCache.put(1, 1); // 缓存是 {1=1}<br>lRUCache.put(2, 2); // 缓存是 {1=1, 2=2}<br>lRUCache.get(1);    // 返回 1<br>lRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3}<br>lRUCache.get(2);    // 返回 -1 (未找到)<br>lRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3}<br>lRUCache.get(1);    // 返回 -1 (未找到)<br>lRUCache.get(3);    // 返回 3<br>lRUCache.get(4);    // 返回 4</p></blockquote><p><strong>提示:</strong></p><ul><li><code>1 &lt;= capacity &lt;= 3000</code></li><li><code>0 &lt;= key &lt;= 10000</code></li><li><code>0 &lt;= value &lt;= 10^5</code></li><li>最多调用 <code>2 * 10^5</code> 次 <code>get</code> 和 <code>put</code></li></ul><span id="more"></span><h1 id="哈希表-双向链表"><a href="#哈希表-双向链表" class="headerlink" title="哈希表 + 双向链表"></a>哈希表 + 双向链表</h1><h2 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h2><p>使用 <strong>哈希表</strong> 实现 <code>O(1)</code> 时间复杂度的键值查找，通过 <strong>双向链表</strong> 维护访问顺序：</p><ol><li>链表头部存放最近访问的节点</li><li>链表尾部存放最久未使用的节点</li><li>伪头尾节点简化链表边界操作</li></ol><h2 id="关键操作图解"><a href="#关键操作图解" class="headerlink" title="关键操作图解"></a>关键操作图解</h2><ol><li>添加节点到头部<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">head &lt;-&gt; [node] &lt;-&gt; oldFirst</span><br><span class="line">1. node.prev = head</span><br><span class="line">2. node.next = head.next</span><br><span class="line">3. head.next.prev = node</span><br><span class="line">4. head.next = node</span><br></pre></td></tr></table></figure></li><li>移除节点<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">prevNode &lt;-&gt; [node] &lt;-&gt; nextNode</span><br><span class="line">=&gt; prevNode &lt;-&gt; nextNode</span><br><span class="line">1. node.prev.next = node.next</span><br><span class="line">2. node.next.prev = node.prev</span><br></pre></td></tr></table></figure></li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">DLinkedNode</span> &#123;</span><br><span class="line">        <span class="type">int</span> key;</span><br><span class="line">        <span class="type">int</span> value;</span><br><span class="line">        DLinkedNode prev;</span><br><span class="line">        DLinkedNode next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">DLinkedNode</span><span class="params">()</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">DLinkedNode</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Integer, DLinkedNode&gt; cache = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> capacity;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DLinkedNode head;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DLinkedNode tail;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LRUCache</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.size = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        <span class="comment">// 使用伪头部和伪尾部节点</span></span><br><span class="line">        head = <span class="keyword">new</span> <span class="title class_">DLinkedNode</span>();</span><br><span class="line">        tail = <span class="keyword">new</span> <span class="title class_">DLinkedNode</span>();</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.prev = head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="type">DLinkedNode</span> <span class="variable">node</span> <span class="operator">=</span> cache.get(key);</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果 key 存在，先通过哈希表定位，再移到头部</span></span><br><span class="line">        moveToHead(node);</span><br><span class="line">        <span class="keyword">return</span> node.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="type">DLinkedNode</span> <span class="variable">node</span> <span class="operator">=</span> cache.get(key);</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果 key 不存在，创建一个新的节点</span></span><br><span class="line">            <span class="type">DLinkedNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DLinkedNode</span>(key, value);</span><br><span class="line">            <span class="comment">// 添加进哈希表</span></span><br><span class="line">            cache.put(key, newNode);</span><br><span class="line">            <span class="comment">// 添加至双向链表的头部</span></span><br><span class="line">            addToHead(newNode);</span><br><span class="line">            size++;</span><br><span class="line">            <span class="keyword">if</span> (size &gt; capacity) &#123;</span><br><span class="line">                <span class="comment">// 如果超出容量，删除双向链表的尾部节点</span></span><br><span class="line">                <span class="type">DLinkedNode</span> <span class="variable">tail</span> <span class="operator">=</span> removeTail();</span><br><span class="line">                <span class="comment">// 删除哈希表中对应的项</span></span><br><span class="line">                cache.remove(tail.key);</span><br><span class="line">                size--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部</span></span><br><span class="line">            node.value = value;</span><br><span class="line">            moveToHead(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addToHead</span><span class="params">(DLinkedNode node)</span> &#123;</span><br><span class="line">        node.prev = head;</span><br><span class="line">        node.next = head.next;</span><br><span class="line">        head.next.prev = node;</span><br><span class="line">        head.next = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">removeNode</span><span class="params">(DLinkedNode node)</span> &#123;</span><br><span class="line">        node.prev.next = node.next;</span><br><span class="line">        node.next.prev = node.prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">moveToHead</span><span class="params">(DLinkedNode node)</span> &#123;</span><br><span class="line">        removeNode(node);</span><br><span class="line">        addToHead(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> DLinkedNode <span class="title function_">removeTail</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">DLinkedNode</span> <span class="variable">res</span> <span class="operator">=</span> tail.prev;</span><br><span class="line">        removeNode(res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li><strong>时间复杂度：</strong><code>O(1)</code>，哈希表查找 <code>O(1)</code>，链表操作 <code>O(1)</code>。</li><li><strong>空间复杂度：</strong><code>O(n)</code>，哈希表存储 <code>n</code> 个键值对，双向链表存储 <code>n+2</code> 个节点（含伪头尾）。</li></ul><h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><ol><li>数据库查询缓存</li><li>浏览器页面缓存</li><li>操作系统页面置换算法</li><li>微服务API响应缓存</li></ol><p><strong>关键点总结：</strong>哈希表保证快速访问，双向链表维护访问顺序，伪头尾节点简化边界处理。通过O(1)时间完成核心操作，是工业级LRU缓存的经典实现。</p><h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><blockquote><p><a href="https://leetcode.cn/problems/lru-cache/description/" title="146. LRU 缓存 | 力扣（LeetCode）">146. LRU 缓存 | 力扣（LeetCode）</a></p></blockquote><hr>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;请你设计并实现一个满足 &lt;strong&gt;LRU (最近最少使用) 缓存&lt;/strong&gt; 约束的数据结构。&lt;br&gt;实现 &lt;code&gt;LRUCache&lt;/code&gt; 类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;LRUCache(int capacity)&lt;/code&gt; 以正整数作为容量 &lt;code&gt;capacity&lt;/code&gt; 初始化 &lt;code&gt;LRU&lt;/code&gt; 缓存。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;int get(int key)&lt;/code&gt; 如果关键字 &lt;code&gt;key&lt;/code&gt; 存在于缓存中，则返回关键字的值，否则返回 &lt;code&gt;-1&lt;/code&gt; 。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;void put(int key, int value)&lt;/code&gt; 如果关键字 &lt;code&gt;key&lt;/code&gt; 已经存在，则变更其数据值 &lt;code&gt;value&lt;/code&gt; ；如果不存在，则向缓存中插入该组 &lt;code&gt;key-value&lt;/code&gt; 。如果插入操作导致关键字数量超过 &lt;code&gt;capacity&lt;/code&gt; ，则应该逐出最久未使用的关键字。&lt;/li&gt;
&lt;li&gt;函数 &lt;code&gt;get&lt;/code&gt; 和 &lt;code&gt;put&lt;/code&gt; 必须以 &lt;code&gt;O(1)&lt;/code&gt; 的平均时间复杂度运行。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt;&lt;br&gt;&lt;code&gt;[&amp;quot;LRUCache&amp;quot;, &amp;quot;put&amp;quot;, &amp;quot;put&amp;quot;, &amp;quot;get&amp;quot;, &amp;quot;put&amp;quot;, &amp;quot;get&amp;quot;, &amp;quot;put&amp;quot;, &amp;quot;get&amp;quot;, &amp;quot;get&amp;quot;, &amp;quot;get&amp;quot;]&lt;/code&gt;&lt;br&gt;&lt;code&gt;[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]&lt;/code&gt;&lt;br&gt;&lt;strong&gt;输出：&lt;/strong&gt;&lt;code&gt;[null, null, null, 1, null, -1, null, -1, 3, 4]&lt;/code&gt;&lt;br&gt;&lt;strong&gt;解释：&lt;/strong&gt;&lt;br&gt;LRUCache lRUCache = new LRUCache(2);&lt;br&gt;lRUCache.put(1, 1); // 缓存是 {1=1}&lt;br&gt;lRUCache.put(2, 2); // 缓存是 {1=1, 2=2}&lt;br&gt;lRUCache.get(1);    // 返回 1&lt;br&gt;lRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3}&lt;br&gt;lRUCache.get(2);    // 返回 -1 (未找到)&lt;br&gt;lRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3}&lt;br&gt;lRUCache.get(1);    // 返回 -1 (未找到)&lt;br&gt;lRUCache.get(3);    // 返回 3&lt;br&gt;lRUCache.get(4);    // 返回 4&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;提示:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= capacity &amp;lt;= 3000&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0 &amp;lt;= key &amp;lt;= 10000&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0 &amp;lt;= value &amp;lt;= 10^5&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;最多调用 &lt;code&gt;2 * 10^5&lt;/code&gt; 次 &lt;code&gt;get&lt;/code&gt; 和 &lt;code&gt;put&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://www.cylong.com/categories/LeetCode/"/>
    
    
    <category term="Java" scheme="https://www.cylong.com/tags/Java/"/>
    
    <category term="LeetCode" scheme="https://www.cylong.com/tags/LeetCode/"/>
    
    <category term="学习笔记" scheme="https://www.cylong.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="链表" scheme="https://www.cylong.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
    <category term="哈希表" scheme="https://www.cylong.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
    <category term="LeetCode中等" scheme="https://www.cylong.com/tags/LeetCode%E4%B8%AD%E7%AD%89/"/>
    
    <category term="双向链表" scheme="https://www.cylong.com/tags/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"/>
    
    <category term="缓存" scheme="https://www.cylong.com/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>相交链表</title>
    <link href="https://www.cylong.com/blog/2025/07/01/intersection-of-two-linked-lists/"/>
    <id>https://www.cylong.com/blog/2025/07/01/intersection-of-two-linked-lists/</id>
    <published>2025-06-30T16:41:55.000Z</published>
    <updated>2025-06-30T16:41:55.000Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给你两个单链表的头节点 <code>headA</code> 和 <code>headB</code> ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 <code>null</code> 。题目数据保证整个链式结构中不存在环。</p><p>图示两个链表在节点 <code>c1</code> 开始相交：</p><img src="/blog/2025/07/01/intersection-of-two-linked-lists/160_statement.png" class=""><p><strong>注意：</strong>函数返回结果后，链表必须保持其原始结构 。</p><p><strong>自定义评测：</strong><br>评测系统的输入如下（你设计的程序不适用此输入）：</p><ul><li><code>intersectVal</code> - 相交的起始节点的值。如果不存在相交节点，这一值为 <code>0</code></li><li><code>listA</code> - 第一个链表</li><li><code>listB</code> - 第二个链表</li><li><code>skipA</code> - 在 <code>listA</code> 中（从头节点开始）跳到交叉节点的节点数</li><li><code>skipB</code> - 在 <code>listB</code> 中（从头节点开始）跳到交叉节点的节点数</li><li>评测系统将根据这些输入创建链式数据结构，并将两个头节点 <code>headA</code> 和 <code>headB</code> 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被视作正确答案。</li></ul><p><strong>示例 1:</strong></p><img src="/blog/2025/07/01/intersection-of-two-linked-lists/160_example_1.png" class=""><blockquote><p><strong>输入：</strong><code>intersectVal = 8</code>, <code>listA = [4,1,8,4,5]</code>, <code>listB = [5, 6, 1, 8, 4, 5]</code>, <code>skipA = 2</code>, <code>skipB = 3</code><br><strong>输出：</strong><code>Intersected at &#39;8&#39;</code><br><strong>解释：</strong></p><ul><li>相交节点的值为 <code>8</code> （注意，如果两个链表相交则不能为 <code>0</code>）。</li><li>从各自的表头开始算起，链表 <code>A</code> 为 <code>[4, 1, 8, 4, 5]</code>，链表 <code>B</code> 为 <code>[5, 6, 1, 8, 4, 5]</code>。</li><li>在 <code>A</code> 中，相交节点前有 2 个节点；在 <code>B</code> 中，相交节点前有 3 个节点。</li><li>请注意相交节点的值不为 1，因为在链表 <code>A</code> 和链表 <code>B</code> 之中值为 1 的节点 (<code>A</code> 中第二个节点和 <code>B</code> 中第三个节点) 是不同的节点。换句话说，它们在内存中指向两个不同的位置，而链表 <code>A</code> 和链表 <code>B</code> 中值为 8 的节点 (<code>A</code> 中第三个节点，<code>B</code> 中第四个节点) 在内存中指向相同的位置。</li></ul></blockquote><p><strong>示例 2:</strong></p><img src="/blog/2025/07/01/intersection-of-two-linked-lists/160_example_2.png" class=""><blockquote><p><strong>输入：</strong><code>intersectVal = 2</code>, <code>listA = [1, 9, 1, 2, 4]</code>, <code>listB = [3, 2, 4]</code>, <code>skipA = 3</code>, <code>skipB = 1</code><br><strong>输出：</strong><code>Intersected at &#39;2&#39;</code><br><strong>解释：</strong></p><ul><li>相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。</li><li>从各自的表头开始算起，链表 <code>A</code> 为 <code>[1, 9, 1, 2, 4]</code>，链表 <code>B</code> 为 <code>[3, 2, 4]</code>。</li><li>在 <code>A</code> 中，相交节点前有 3 个节点；在 <code>B</code> 中，相交节点前有 1 个节点。</li></ul></blockquote><p><strong>示例 3:</strong></p><img src="/blog/2025/07/01/intersection-of-two-linked-lists/160_example_3.png" class=""><blockquote><p><strong>输入：</strong><code>intersectVal = 0</code>, <code>listA = [2, 6, 4]</code>, <code>listB = [1, 5]</code>, <code>skipA = 3</code>, <code>skipB = 2</code><br><strong>输出：</strong><code>No intersection</code><br><strong>解释：</strong></p><ul><li>从各自的表头开始算起，链表 <code>A</code> 为 <code>[2, 6, 4]</code>，链表 <code>B</code> 为 <code>[1, 5]</code>。</li><li>由于这两个链表不相交，所以 <code>intersectVal</code> 必须为 0，而 <code>skipA</code> 和 <code>skipB</code> 可以是任意值。</li><li>这两个链表不相交，因此返回 <code>null</code> 。</li></ul></blockquote><p><strong>提示:</strong></p><ul><li><code>listA</code> 中节点数目为 <code>m</code></li><li><code>listB</code> 中节点数目为 <code>n</code></li><li><code>1 &lt;= m, n &lt;= 3 * 10^4</code></li><li><code>1 &lt;= Node.val &lt;= 10^5</code></li><li><code>0 &lt;= skipA &lt;= m</code></li><li><code>0 &lt;= skipB &lt;= n</code></li><li>如果 <code>listA</code> 和 <code>listB</code> 没有交点，<code>intersectVal</code> 为 0</li><li>如果 <code>listA</code> 和 <code>listB</code> 有交点，<code>intersectVal == listA[skipA] == listB[skipB]</code></li></ul><span id="more"></span><h1 id="哈希集合法"><a href="#哈希集合法" class="headerlink" title="哈希集合法"></a>哈希集合法</h1><h2 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h2><p>使用哈希集合存储链表 <code>A</code> 的所有节点，然后遍历链表 <code>B</code> 的每个节点，判断该节点是否在集合中。第一个出现在集合中的节点就是相交节点。</p><p><strong>算法步骤</strong></p><ol><li>创建一个 <code>HashSet</code> 用于存储链表 <code>A</code> 的节点。</li><li>遍历链表 <code>A</code>，将每个节点添加到集合中。</li><li>遍历链表 <code>B</code>，对于每个节点：<ul><li>如果该节点存在于集合中，则返回该节点（相交节点）。</li><li>否则继续遍历下一个节点。</li></ul></li><li>如果遍历完链表 <code>B</code> 都没有找到相交节点，返回 <code>null</code>。</li></ol><p><strong>动态过程示例</strong></p><p>以链表 A：<code>1 → 2 → 3 → 4</code> 和链表 B：<code>5 → 3 → 4</code> 为例（相交节点为 3）：</p><ol><li>遍历 A，将节点 <code>1</code>、<code>2</code>、<code>3</code>、<code>4</code> 加入集合。</li><li>遍历 B：<ul><li>节点 5：不在集合中。</li><li>节点 3：在集合中 → 返回节点 3。</li></ul></li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line">    Set&lt;ListNode&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> headA;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">        set.add(cur);</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    cur = headB;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 这里用 HashSet 可以保证查询复杂度为 O(1)</span></span><br><span class="line">        <span class="keyword">if</span> (set.contains(cur)) &#123;</span><br><span class="line">            <span class="keyword">return</span> cur;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li><strong>时间复杂度：</strong><code>O(m + n)</code>，其中 <code>m</code> 和 <code>n</code> 分别是链表 <code>A</code> 和 <code>B</code> 的长度。需要遍历两个链表各一次。</li><li><strong>空间复杂度：</strong><code>O(m)</code>，存储链表 <code>A</code> 的节点集合。</li></ul><h1 id="双指针法（浪漫相遇法）"><a href="#双指针法（浪漫相遇法）" class="headerlink" title="双指针法（浪漫相遇法）"></a>双指针法（浪漫相遇法）</h1><h2 id="核心思路-1"><a href="#核心思路-1" class="headerlink" title="核心思路"></a>核心思路</h2><p>使用两个指针 <code>pA</code> 和 <code>pB</code> 分别遍历链表 <code>A</code> 和 <code>B</code>。当 <code>pA</code> 到达链表 <code>A</code> 末尾时，重定位到链表 <code>B</code> 的头节点；当 <code>pB</code> 到达链表 <code>B</code> 末尾时，重定位到链表 <code>A</code> 的头节点。若两链表相交，则 <code>pA</code> 和 <code>pB</code> 必在相交点相遇；若不相交，则最终会同时到达 <code>null</code>。</p><p><strong>算法步骤</strong></p><img src="/blog/2025/07/01/intersection-of-two-linked-lists/%E5%9B%BE%E8%A7%A3.png" class=""><p>考虑构建两个节点指针 <code>A</code>​ , <code>B</code> 分别指向两链表头节点 <code>headA</code> , <code>headB</code> ，首个公共节点为 <code>node</code>，做如下操作：</p><ul><li>指针 <code>A</code> 先遍历完链表 <code>headA</code> ，再开始遍历链表 <code>headB</code> ，当走到 <code>node</code> 时，共走步数为：<code>a + (b - c)</code></li><li>指针 <code>B</code> 先遍历完链表 <code>headB</code> ，再开始遍历链表 <code>headA</code> ，当走到 <code>node</code> 时，共走步数为：<code>b + (a - c)</code></li></ul><p>如下式所示，此时指针 <code>A</code> , <code>B</code> 重合，并有两种情况：<code>a + (b - c) = b + (a - c)</code></p><ul><li>若两链表 有 公共尾部 (即 <code>c &gt; 0</code> ) ：指针 <code>A</code> , <code>B</code> 同时指向「第一个公共节点」<code>node</code> 。</li><li>若两链表 无 公共尾部 (即 <code>c = 0</code> ) ：指针 <code>A</code> , <code>B</code> 同时指向 <code>null</code> 。</li></ul><h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (headA == <span class="literal">null</span> || headB == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pA</span> <span class="operator">=</span> headA;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pB</span> <span class="operator">=</span> headB;</span><br><span class="line">    <span class="keyword">while</span> (pA != pB) &#123;</span><br><span class="line">        pA = pA == <span class="literal">null</span> ? headB : pA.next;</span><br><span class="line">        pB = pB == <span class="literal">null</span> ? headA : pB.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li><strong>时间复杂度：</strong><code>O(m + n)</code>，最多遍历两链表各两次。</li><li><strong>空间复杂度：</strong><code>O(1)</code>，仅使用两个指针。</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><table><thead><tr><th>解法</th><th>时间复杂度</th><th>空间复杂度</th><th>适用场景</th></tr></thead><tbody><tr><td>哈希集合法</td><td>O(m + n)</td><td>O(m)</td><td>无空间限制时，代码简单</td></tr><tr><td>双指针法</td><td>O(m + n)</td><td>O(1)</td><td>要求常数空间，逻辑巧妙高效</td></tr></tbody></table><p>双指针法通过重定位指针创造等长路径，巧妙解决了链表长度差异问题，是空间优化的最佳方案。实际应用中，若内存允许可优先选择哈希法（代码更直观），若要求严格空间复杂度则必须使用双指针法。</p><h1 id="力扣的一些浪漫留言"><a href="#力扣的一些浪漫留言" class="headerlink" title="力扣的一些浪漫留言"></a>力扣的一些浪漫留言</h1><ul><li>当我在我的路上走过一遍依然没有遇见你时，那么我会接着来到你走过的路走一遍，如果我们心有灵犀，那么我们终将相遇。 - 局部降雨</li><li>我走过你走过的路，只为和你相拥。 - Flow</li><li>错的人就算走过了对方的路也还是会错过。 - 小虎</li><li>我住长江头，君住长江尾，日夜思君不见君，共饮一江水。君奔长江头，我赴长江尾，辗转轮回未谋面，邂逅时好美！ - 瓦罗兰的文艺复兴</li><li>世界上没有真正的感同身受直到你走过我走过的路。 - Cool PaninipeO</li></ul><h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><blockquote><p><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/description/" title="160. 相交链表 | 力扣（LeetCode）">160. 相交链表 | 力扣（LeetCode）</a><br><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/solutions/12624/intersection-of-two-linked-lists-shuang-zhi-zhen-l/" title="160. 相交链表 | 题解 | Krahets">160. 相交链表 | 题解 | Krahets</a><br><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/solutions/2958778/tu-jie-yi-zhang-tu-miao-dong-xiang-jiao-m6tg1/" title="160. 相交链表 | 题解 | 灵茶山艾府">160. 相交链表 | 题解 | 灵茶山艾府</a></p></blockquote><hr>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;给你两个单链表的头节点 &lt;code&gt;headA&lt;/code&gt; 和 &lt;code&gt;headB&lt;/code&gt; ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 &lt;code&gt;null&lt;/code&gt; 。题目数据保证整个链式结构中不存在环。&lt;/p&gt;
&lt;p&gt;图示两个链表在节点 &lt;code&gt;c1&lt;/code&gt; 开始相交：&lt;/p&gt;
&lt;img src=&quot;/blog/2025/07/01/intersection-of-two-linked-lists/160_statement.png&quot; class=&quot;&quot;&gt;

&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;函数返回结果后，链表必须保持其原始结构 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;自定义评测：&lt;/strong&gt;&lt;br&gt;评测系统的输入如下（你设计的程序不适用此输入）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;intersectVal&lt;/code&gt; - 相交的起始节点的值。如果不存在相交节点，这一值为 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;listA&lt;/code&gt; - 第一个链表&lt;/li&gt;
&lt;li&gt;&lt;code&gt;listB&lt;/code&gt; - 第二个链表&lt;/li&gt;
&lt;li&gt;&lt;code&gt;skipA&lt;/code&gt; - 在 &lt;code&gt;listA&lt;/code&gt; 中（从头节点开始）跳到交叉节点的节点数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;skipB&lt;/code&gt; - 在 &lt;code&gt;listB&lt;/code&gt; 中（从头节点开始）跳到交叉节点的节点数&lt;/li&gt;
&lt;li&gt;评测系统将根据这些输入创建链式数据结构，并将两个头节点 &lt;code&gt;headA&lt;/code&gt; 和 &lt;code&gt;headB&lt;/code&gt; 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被视作正确答案。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;img src=&quot;/blog/2025/07/01/intersection-of-two-linked-lists/160_example_1.png&quot; class=&quot;&quot;&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt;&lt;code&gt;intersectVal = 8&lt;/code&gt;, &lt;code&gt;listA = [4,1,8,4,5]&lt;/code&gt;, &lt;code&gt;listB = [5, 6, 1, 8, 4, 5]&lt;/code&gt;, &lt;code&gt;skipA = 2&lt;/code&gt;, &lt;code&gt;skipB = 3&lt;/code&gt;&lt;br&gt;&lt;strong&gt;输出：&lt;/strong&gt;&lt;code&gt;Intersected at &amp;#39;8&amp;#39;&lt;/code&gt;&lt;br&gt;&lt;strong&gt;解释：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;相交节点的值为 &lt;code&gt;8&lt;/code&gt; （注意，如果两个链表相交则不能为 &lt;code&gt;0&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;从各自的表头开始算起，链表 &lt;code&gt;A&lt;/code&gt; 为 &lt;code&gt;[4, 1, 8, 4, 5]&lt;/code&gt;，链表 &lt;code&gt;B&lt;/code&gt; 为 &lt;code&gt;[5, 6, 1, 8, 4, 5]&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;在 &lt;code&gt;A&lt;/code&gt; 中，相交节点前有 2 个节点；在 &lt;code&gt;B&lt;/code&gt; 中，相交节点前有 3 个节点。&lt;/li&gt;
&lt;li&gt;请注意相交节点的值不为 1，因为在链表 &lt;code&gt;A&lt;/code&gt; 和链表 &lt;code&gt;B&lt;/code&gt; 之中值为 1 的节点 (&lt;code&gt;A&lt;/code&gt; 中第二个节点和 &lt;code&gt;B&lt;/code&gt; 中第三个节点) 是不同的节点。换句话说，它们在内存中指向两个不同的位置，而链表 &lt;code&gt;A&lt;/code&gt; 和链表 &lt;code&gt;B&lt;/code&gt; 中值为 8 的节点 (&lt;code&gt;A&lt;/code&gt; 中第三个节点，&lt;code&gt;B&lt;/code&gt; 中第四个节点) 在内存中指向相同的位置。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;/p&gt;
&lt;img src=&quot;/blog/2025/07/01/intersection-of-two-linked-lists/160_example_2.png&quot; class=&quot;&quot;&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt;&lt;code&gt;intersectVal = 2&lt;/code&gt;, &lt;code&gt;listA = [1, 9, 1, 2, 4]&lt;/code&gt;, &lt;code&gt;listB = [3, 2, 4]&lt;/code&gt;, &lt;code&gt;skipA = 3&lt;/code&gt;, &lt;code&gt;skipB = 1&lt;/code&gt;&lt;br&gt;&lt;strong&gt;输出：&lt;/strong&gt;&lt;code&gt;Intersected at &amp;#39;2&amp;#39;&lt;/code&gt;&lt;br&gt;&lt;strong&gt;解释：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。&lt;/li&gt;
&lt;li&gt;从各自的表头开始算起，链表 &lt;code&gt;A&lt;/code&gt; 为 &lt;code&gt;[1, 9, 1, 2, 4]&lt;/code&gt;，链表 &lt;code&gt;B&lt;/code&gt; 为 &lt;code&gt;[3, 2, 4]&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;在 &lt;code&gt;A&lt;/code&gt; 中，相交节点前有 3 个节点；在 &lt;code&gt;B&lt;/code&gt; 中，相交节点前有 1 个节点。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例 3:&lt;/strong&gt;&lt;/p&gt;
&lt;img src=&quot;/blog/2025/07/01/intersection-of-two-linked-lists/160_example_3.png&quot; class=&quot;&quot;&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt;&lt;code&gt;intersectVal = 0&lt;/code&gt;, &lt;code&gt;listA = [2, 6, 4]&lt;/code&gt;, &lt;code&gt;listB = [1, 5]&lt;/code&gt;, &lt;code&gt;skipA = 3&lt;/code&gt;, &lt;code&gt;skipB = 2&lt;/code&gt;&lt;br&gt;&lt;strong&gt;输出：&lt;/strong&gt;&lt;code&gt;No intersection&lt;/code&gt;&lt;br&gt;&lt;strong&gt;解释：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从各自的表头开始算起，链表 &lt;code&gt;A&lt;/code&gt; 为 &lt;code&gt;[2, 6, 4]&lt;/code&gt;，链表 &lt;code&gt;B&lt;/code&gt; 为 &lt;code&gt;[1, 5]&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;由于这两个链表不相交，所以 &lt;code&gt;intersectVal&lt;/code&gt; 必须为 0，而 &lt;code&gt;skipA&lt;/code&gt; 和 &lt;code&gt;skipB&lt;/code&gt; 可以是任意值。&lt;/li&gt;
&lt;li&gt;这两个链表不相交，因此返回 &lt;code&gt;null&lt;/code&gt; 。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;提示:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;listA&lt;/code&gt; 中节点数目为 &lt;code&gt;m&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;listB&lt;/code&gt; 中节点数目为 &lt;code&gt;n&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= m, n &amp;lt;= 3 * 10^4&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= Node.val &amp;lt;= 10^5&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0 &amp;lt;= skipA &amp;lt;= m&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0 &amp;lt;= skipB &amp;lt;= n&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果 &lt;code&gt;listA&lt;/code&gt; 和 &lt;code&gt;listB&lt;/code&gt; 没有交点，&lt;code&gt;intersectVal&lt;/code&gt; 为 0&lt;/li&gt;
&lt;li&gt;如果 &lt;code&gt;listA&lt;/code&gt; 和 &lt;code&gt;listB&lt;/code&gt; 有交点，&lt;code&gt;intersectVal == listA[skipA] == listB[skipB]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://www.cylong.com/categories/LeetCode/"/>
    
    
    <category term="Java" scheme="https://www.cylong.com/tags/Java/"/>
    
    <category term="LeetCode" scheme="https://www.cylong.com/tags/LeetCode/"/>
    
    <category term="学习笔记" scheme="https://www.cylong.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="链表" scheme="https://www.cylong.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
    <category term="哈希表" scheme="https://www.cylong.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
    <category term="双指针" scheme="https://www.cylong.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
    <category term="LeetCode简单" scheme="https://www.cylong.com/tags/LeetCode%E7%AE%80%E5%8D%95/"/>
    
  </entry>
  
  <entry>
    <title>旋转图像</title>
    <link href="https://www.cylong.com/blog/2025/06/27/rotate-image/"/>
    <id>https://www.cylong.com/blog/2025/06/27/rotate-image/</id>
    <published>2025-06-27T12:42:48.000Z</published>
    <updated>2025-06-27T12:42:48.000Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个 <code>n × n</code> 的二维矩阵 <code>matrix</code> 表示一个图像。请你将图像顺时针旋转 90 度。你必须在 <strong>原地</strong> 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。</p><p><strong>原地算法：</strong>在计算机科学中，一个原地算法（in-place algorithm）是一种使用小的，固定数量的额外之空间来转换资料的算法。当算法执行时，输入的资料通常会被要输出的部分覆盖掉。不是原地算法有时候称为非原地（not-in-place）或不得其所（out-of-place）。</p><p><strong>示例 1:</strong></p><img src="/blog/2025/06/27/rotate-image/mat1.jpg" class=""><blockquote><p><strong>输入：</strong><code>matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]</code><br><strong>输出：</strong><code>[[7, 4, 1], [8, 5, 2], [9, 6, 3]]</code></p></blockquote><p><strong>示例 2:</strong></p><img src="/blog/2025/06/27/rotate-image/mat2.jpg" class=""><blockquote><p><strong>输入：</strong><code>matrix = [[5, 1, 9, 11], [2, 4, 8, 10], [13, 3, 6, 7], [15, 14, 12, 16]]</code><br><strong>输出：</strong><code>[[15, 13, 2, 5], [14, 3, 4, ], [12, 6, 8, 9], [16, 7, 10, 11]]</code></p></blockquote><p><strong>提示:</strong></p><ul><li><code>n == matrix.length == matrix[i].length</code></li><li><code>1 &lt;= n &lt;= 20</code></li><li><code>-1000 &lt;= matrix[i][j] &lt;= 1000</code></li></ul><span id="more"></span><h1 id="原地旋转法"><a href="#原地旋转法" class="headerlink" title="原地旋转法"></a>原地旋转法</h1><h2 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h2><p>通过一次旋转四个元素实现原地旋转。对于每个位置 <code>(i, j)</code>，我们找到旋转后对应的三个位置，使用临时变量完成四个元素的交换。旋转过程如下：</p><ol><li>左上角元素 → 右上角</li><li>右上角元素 → 右下角</li><li>右下角元素 → 左下角</li><li>左下角元素 → 左上角</li></ol><p><strong>旋转公式推导</strong></p><p>设矩阵大小为 <code>n</code>，对于位置 <code>(i, j)</code>：</p><ol><li>左上角：<code>(i, j)</code></li><li>右上角：<code>(j, n-1-i)</code></li><li>右下角：<code>(n-1-i, n-1-j)</code></li><li>左下角：<code>(n-1-j, i)</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">temp = matrix[i][j]</span><br><span class="line">matrix[i][j] = matrix[n-<span class="number">1</span>-j][i]         <span class="comment">// 左下 → 左上</span></span><br><span class="line">matrix[n-<span class="number">1</span>-j][i] = matrix[n-<span class="number">1</span>-i][n-<span class="number">1</span>-j] <span class="comment">// 右下 → 左下</span></span><br><span class="line">matrix[n-<span class="number">1</span>-i][n-<span class="number">1</span>-j] = matrix[j][n-<span class="number">1</span>-i] <span class="comment">// 右上 → 右下</span></span><br><span class="line">matrix[j][n-<span class="number">1</span>-i] = temp                 <span class="comment">// 左上 → 右上</span></span><br></pre></td></tr></table></figure><p><strong>遍历范围优化</strong></p><ul><li>当 <code>n</code> 为偶数时：遍历左上角 <code>1/4</code> 区域</li><li>当 <code>n</code> 为奇数时：遍历左上角 <code>1/4 + 中心轴</code> 区域</li></ul><img src="/blog/2025/06/27/rotate-image/mat3.png" class=""><img src="/blog/2025/06/27/rotate-image/mat4.png" class=""><p><strong>图形化示例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">初始矩阵：</span><br><span class="line">[1, 2, 3]</span><br><span class="line">[4, 5, 6]</span><br><span class="line">[7, 8, 9]</span><br><span class="line"></span><br><span class="line">步骤1：旋转(0,0)元素</span><br><span class="line">  1 → 3的位置，3 → 9的位置，9 → 7的位置，7 → 1的位置</span><br><span class="line">得到：</span><br><span class="line">[7, 2, 1]</span><br><span class="line">[4, 5, 6]</span><br><span class="line">[9, 8, 3]</span><br><span class="line"></span><br><span class="line">步骤2：旋转(0,1)元素</span><br><span class="line">  2 → 6的位置，6 → 8的位置，8 → 4的位置，4 → 2的位置</span><br><span class="line">得到：</span><br><span class="line">[7, 4, 1]</span><br><span class="line">[8, 5, 2]</span><br><span class="line">[9, 6, 3]</span><br><span class="line"></span><br><span class="line">最终结果：</span><br><span class="line">[7, 4, 1]</span><br><span class="line">[8, 5, 2]</span><br><span class="line">[9, 6, 3]</span><br></pre></td></tr></table></figure><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rotate</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> matrix.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n / <span class="number">2</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; (n + <span class="number">1</span>) / <span class="number">2</span>; ++j) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> matrix[i][j];</span><br><span class="line">            matrix[i][j] = matrix[n - j - <span class="number">1</span>][i];</span><br><span class="line">            matrix[n - j - <span class="number">1</span>][i] = matrix[n - i - <span class="number">1</span>][n - j - <span class="number">1</span>];</span><br><span class="line">            matrix[n - i - <span class="number">1</span>][n - j - <span class="number">1</span>] = matrix[j][n - i - <span class="number">1</span>];</span><br><span class="line">            matrix[j][n - i - <span class="number">1</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li><strong>时间复杂度：</strong><code>O(n²)</code>，其中 <code>n</code> 是 <code>matrix</code> 的边长。</li><li><strong>空间复杂度：</strong><code>O(1)</code>，为原地旋转。</li></ul><h1 id="翻转组合法"><a href="#翻转组合法" class="headerlink" title="翻转组合法"></a>翻转组合法</h1><h2 id="核心思路-1"><a href="#核心思路-1" class="headerlink" title="核心思路"></a>核心思路</h2><p>通过两次翻转操作实现旋转：</p><ol><li><strong>水平翻转</strong>（上下翻转）：<code>matrix[i][j] ↔ matrix[n-1-i][j]</code><ul><li>以水平中线为轴交换元素</li><li>行索引变换：<code>i → n-1-i</code></li><li>列索引不变</li></ul></li><li><strong>主对角线翻转</strong>（转置）：<code>matrix[i][j] ↔ matrix[j][i]</code><ul><li>沿主对角线（左上到右下）交换元素</li><li>行列索引互换：<code>(i, j) → (j, i)</code></li><li>只需遍历对角线一侧避免重复</li></ul></li></ol><p><strong>推导步骤</strong></p><ol><li>水平翻转后：<code>(i, j) → (n-1-i, j)</code></li><li>主对角线翻转后：<code>(n-1-i, j) → (j, n-1-i)</code></li><li>与顺时针旋转 90° 的坐标变换一致：<code>(i, j) → (j, n-1-i)</code></li></ol><p><strong>图形化示例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">初始矩阵：</span><br><span class="line">[1, 2, 3]</span><br><span class="line">[4, 5, 6]</span><br><span class="line">[7, 8, 9]</span><br><span class="line"></span><br><span class="line">步骤1：水平翻转</span><br><span class="line">  交换行：第0行 ↔ 第2行</span><br><span class="line">得到：</span><br><span class="line">[7, 8, 9]</span><br><span class="line">[4, 5, 6]</span><br><span class="line">[1, 2, 3]</span><br><span class="line"></span><br><span class="line">步骤2：主对角线翻转</span><br><span class="line">  交换(1,0)和(0,1)：8 ↔ 4</span><br><span class="line">  交换(2,0)和(0,2)：9 ↔ 1 → 但实际顺序：先1和9交换，再2和6交换</span><br><span class="line">  详细过程：</span><br><span class="line">    [7, 8, 9]    [7, 4, 9]    [7, 4, 1]    [7, 4, 1]</span><br><span class="line">    [4, 5, 6] → [8, 5, 6] → [8, 5, 6] → [8, 5, 2]</span><br><span class="line">    [1, 2, 3]    [1, 2, 3]    [9, 2, 3]    [9, 6, 3]</span><br><span class="line"></span><br><span class="line">最终结果：</span><br><span class="line">[7, 4, 1]</span><br><span class="line">[8, 5, 2]</span><br><span class="line">[9, 6, 3]</span><br></pre></td></tr></table></figure><h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rotate</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> matrix.length;</span><br><span class="line">    <span class="comment">// 水平翻转</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n / <span class="number">2</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> matrix[i][j];</span><br><span class="line">            matrix[i][j] = matrix[n - i - <span class="number">1</span>][j];</span><br><span class="line">            matrix[n - i - <span class="number">1</span>][j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 主对角线翻转</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> matrix[i][j];</span><br><span class="line">            matrix[i][j] = matrix[j][i];</span><br><span class="line">            matrix[j][i] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li><strong>时间复杂度：</strong><code>O(n²)</code>，其中 <code>n</code> 是 <code>matrix</code> 的边长。</li><li><strong>空间复杂度：</strong><code>O(1)</code>，为原地旋转。</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><table><thead><tr><th>解法</th><th>时间复杂度</th><th>空间复杂度</th><th>优势</th></tr></thead><tbody><tr><td>原地旋转法</td><td>O(n²)</td><td>O(1)</td><td>通过数学推导直接定位旋转位置，单次循环完成操作</td></tr><tr><td>翻转组合法</td><td>O(n²)</td><td>O(1)</td><td>利用基础操作组合实现旋转，逻辑清晰易理解</td></tr></tbody></table><p>两种方法都满足原地旋转的要求，在实际应用中可根据具体场景选择。翻转组合法更易于理解和扩展（如逆时针旋转只需调整翻转顺序），而原地旋转法在理论上减少了一半的交换操作。</p><h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><blockquote><p><a href="https://leetcode.cn/problems/rotate-image/description/" title="48. 旋转图像 | 力扣（LeetCode）">48. 旋转图像 | 力扣（LeetCode）</a></p></blockquote><hr>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;给定一个 &lt;code&gt;n × n&lt;/code&gt; 的二维矩阵 &lt;code&gt;matrix&lt;/code&gt; 表示一个图像。请你将图像顺时针旋转 90 度。你必须在 &lt;strong&gt;原地&lt;/strong&gt; 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;原地算法：&lt;/strong&gt;在计算机科学中，一个原地算法（in-place algorithm）是一种使用小的，固定数量的额外之空间来转换资料的算法。当算法执行时，输入的资料通常会被要输出的部分覆盖掉。不是原地算法有时候称为非原地（not-in-place）或不得其所（out-of-place）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;img src=&quot;/blog/2025/06/27/rotate-image/mat1.jpg&quot; class=&quot;&quot;&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt;&lt;code&gt;matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]&lt;/code&gt;&lt;br&gt;&lt;strong&gt;输出：&lt;/strong&gt;&lt;code&gt;[[7, 4, 1], [8, 5, 2], [9, 6, 3]]&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;/p&gt;
&lt;img src=&quot;/blog/2025/06/27/rotate-image/mat2.jpg&quot; class=&quot;&quot;&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt;&lt;code&gt;matrix = [[5, 1, 9, 11], [2, 4, 8, 10], [13, 3, 6, 7], [15, 14, 12, 16]]&lt;/code&gt;&lt;br&gt;&lt;strong&gt;输出：&lt;/strong&gt;&lt;code&gt;[[15, 13, 2, 5], [14, 3, 4, ], [12, 6, 8, 9], [16, 7, 10, 11]]&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;提示:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;n == matrix.length == matrix[i].length&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= n &amp;lt;= 20&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-1000 &amp;lt;= matrix[i][j] &amp;lt;= 1000&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://www.cylong.com/categories/LeetCode/"/>
    
    
    <category term="Java" scheme="https://www.cylong.com/tags/Java/"/>
    
    <category term="LeetCode" scheme="https://www.cylong.com/tags/LeetCode/"/>
    
    <category term="学习笔记" scheme="https://www.cylong.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="数组" scheme="https://www.cylong.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="矩阵" scheme="https://www.cylong.com/tags/%E7%9F%A9%E9%98%B5/"/>
    
    <category term="LeetCode中等" scheme="https://www.cylong.com/tags/LeetCode%E4%B8%AD%E7%AD%89/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot 事件驱动编程：ApplicationEventPublisher 原理与实践指南</title>
    <link href="https://www.cylong.com/blog/2025/06/20/application-event-publisher/"/>
    <id>https://www.cylong.com/blog/2025/06/20/application-event-publisher/</id>
    <published>2025-06-20T15:47:57.000Z</published>
    <updated>2025-06-20T15:47:57.000Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h1><p><code>ApplicationEventPublisher</code> 是 Spring 框架的核心接口，用于发布应用事件，实现观察者模式。其核心作用包括：</p><ol><li><strong>事件发布：</strong>允许组件发布自定义事件</li><li><strong>松耦合：</strong>实现发布者与订阅者的解耦</li><li><strong>同步处理：</strong>默认同步执行（可通过 <code>@Async</code> 实现异步）</li><li><strong>继承机制：</strong>事件对象可继承扩展（支持 <code>ApplicationEvent</code> 或任意 <code>POJO</code>）</li></ol><p><strong>工作流程：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[发布者] → (发布事件) → [ApplicationContext] → (路由事件) → [监听器]</span><br></pre></td></tr></table></figure><h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><ol><li><strong>业务解耦：</strong>如用户注册后发送邮件/短信</li><li><strong>状态变更通知：</strong>订单状态变化时更新库存</li><li><strong>审计日志：</strong>关键操作后记录审计信息</li><li><strong>异步任务触发：</strong>耗时操作异步执行</li><li><strong>系统监控：</strong>关键事件触发监控上报</li></ol><span id="more"></span><h1 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h1><h2 id="添加-Maven-依赖"><a href="#添加-Maven-依赖" class="headerlink" title="添加 Maven 依赖"></a>添加 Maven 依赖</h2><p>由于 Spring Boot 已经内置了事件发布机制，我们只需要引入 <code>spring-boot-starter</code> 即可，它包含了 <code>spring-context</code>，其中就有 <code>ApplicationEventPublisher</code>。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>关于 Spring Boot 入门可以参考：<a href="/blog/2025/06/12/spring-boot/" title="Spring Boot 入门指南：从零开始创建 Web 应用">Spring Boot 入门指南：从零开始创建 Web 应用</a></p><h2 id="事件定义（POJO）"><a href="#事件定义（POJO）" class="headerlink" title="事件定义（POJO）"></a>事件定义（POJO）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.Getter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationEvent;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里用了 Lombok 注解，也可以参考上一篇文章</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserRegisterEvent</span> <span class="keyword">extends</span> <span class="title class_">ApplicationEvent</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserRegisterEvent</span><span class="params">(Object source, String username)</span> &#123;</span><br><span class="line">        <span class="comment">// source 通常是事件发布者</span></span><br><span class="line">        <span class="built_in">super</span>(source);</span><br><span class="line">        <span class="built_in">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="事件监听器"><a href="#事件监听器" class="headerlink" title="事件监听器"></a>事件监听器</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserRegisterListener</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听方式1：注解监听指定事件，此时 UserRegisterEvent 无需继承 ApplicationEvent</span></span><br><span class="line">    <span class="meta">@EventListener</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleEvent</span><span class="params">(UserRegisterEvent event)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;[注解监听] 新用户注册: &quot;</span> + event.getUsername());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 监听方式2：实现 ApplicationListener 接口，此时 UserRegisterEvent 需要继承 ApplicationEvent</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmailListener</span> <span class="keyword">implements</span> <span class="title class_">ApplicationListener</span>&lt;UserRegisterEvent&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(UserRegisterEvent event)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;[接口监听] 发送欢迎邮件至: &quot;</span> + event.getUsername());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Spring 4.2 之前，自定义事件必须继承 <code>ApplicationEvent</code>。从 Spring 4.2 开始，事件可以是任意对象，不再强制要求继承 <code>ApplicationEvent</code>。因此，有两种解决方案：</p><ol><li>让 <code>UserRegisterEvent</code> 继承 <code>ApplicationEvent</code>（这样两种监听方式都支持）</li><li>将实现 <code>ApplicationListener</code> 接口的监听器改为使用 <code>@EventListener</code> 注解（推荐，因为更灵活）</li></ol><p>为了保持代码的简洁和现代 Spring 的使用方式，我们通常推荐使用 <code>@EventListener</code> 注解。这里为了演示两种方式，我们让事件类继承 <code>ApplicationEvent</code>，同时，在发布事件的时候，需要传递 <code>source</code>（通常就是发布者对象，但也可以为 <code>null</code>）</p><h2 id="事件发布服务"><a href="#事件发布服务" class="headerlink" title="事件发布服务"></a>事件发布服务</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注入事件发布器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ApplicationEventPublisher publisher;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserService</span><span class="params">(ApplicationEventPublisher publisher)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.publisher = publisher;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerUser</span><span class="params">(String username)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;注册用户: &quot;</span> + username);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发布事件，需传递事件源（通常就是发布者对象 this，但也可以为 null）和业务数据</span></span><br><span class="line">        publisher.publishEvent(<span class="keyword">new</span> <span class="title class_">UserRegisterEvent</span>(<span class="built_in">this</span>, username));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;主流程完成&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="主应用类"><a href="#主应用类" class="headerlink" title="主应用类"></a>主应用类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApplicationEventPublisherDemoApplication</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">ConfigurableApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> SpringApplication.run(ApplicationEventPublisherDemoApplication.class, args);</span><br><span class="line"><span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> context.getBean(UserService.class);</span><br><span class="line">userService.registerUser(<span class="string">&quot;cylong&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h2><ol><li><strong>事件对象：</strong><code>UserRegisterEvent</code> 封装事件数据</li><li><strong>监听器：</strong><ul><li><strong>注解方式：</strong><code>@EventListener</code> 自动匹配事件类型（也就是根据类名匹配）</li><li><strong>接口方式：</strong>实现 <code>ApplicationListener</code> 接口</li></ul></li><li><strong>发布器：</strong><ul><li><code>ApplicationEventPublisher.publishEvent()</code> 触发事件</li><li>Spring 自动注入发布器实例</li></ul></li><li><strong>执行流程：</strong><ul><li>主应用调用 <code>registerUser()</code></li><li>服务内部发布事件</li><li>所有监听器同步执行</li></ul></li></ol><h2 id="运行输出"><a href="#运行输出" class="headerlink" title="运行输出"></a>运行输出</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">注册用户: cylong</span><br><span class="line">[接口监听] 发送欢迎邮件至: cylong</span><br><span class="line">[注解监听] 新用户注册: cylong</span><br><span class="line">主流程完成</span><br></pre></td></tr></table></figure><h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><p>下面将展示三种异常处理方式（局部捕获、全局处理和异步处理）的实现</p><h2 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationEvent;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 自定义事件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderEvent</span> <span class="keyword">extends</span> <span class="title class_">ApplicationEvent</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String orderId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OrderEvent</span><span class="params">(Object source, String orderId)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(source);</span><br><span class="line">        <span class="built_in">this</span>.orderId = orderId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getOrderId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> orderId;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.event.EventListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.Async;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderEventListeners</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.1 局部异常捕获 - 库存服务</span></span><br><span class="line">    <span class="meta">@EventListener</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleInventory</span><span class="params">(OrderEvent event)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;\n[库存服务] 处理订单: &quot;</span> + event.getOrderId());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;error_stock&quot;</span>.equals(event.getOrderId())) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;库存不足，商品A缺货&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;   &gt; 库存锁定成功&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;   ! [库存异常] &quot;</span> + e.getMessage());</span><br><span class="line">            System.out.println(<span class="string">&quot;   &gt; 执行本地补偿: 释放预留资源&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.2 局部异常捕获 - 支付服务</span></span><br><span class="line">    <span class="meta">@EventListener</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handlePayment</span><span class="params">(OrderEvent event)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;\n[支付服务] 处理订单: &quot;</span> + event.getOrderId());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;error_payment&quot;</span>.equals(event.getOrderId())) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;支付失败，信用卡余额不足&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;   &gt; 支付处理成功&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;   ! [支付异常] &quot;</span> + e.getMessage());</span><br><span class="line">            System.out.println(<span class="string">&quot;   &gt; 执行本地补偿: 取消支付预授权&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 用于演示全局异常处理的监听器（不捕获异常）</span></span><br><span class="line">    <span class="meta">@EventListener</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleNotification</span><span class="params">(OrderEvent event)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;\n[通知服务] 处理订单: &quot;</span> + event.getOrderId());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;error_stock&quot;</span>.equals(event.getOrderId())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;通知服务失败: 短信配额不足&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;   &gt; 已发送订单确认通知&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 异步异常处理</span></span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="meta">@EventListener</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleAsyncTask</span><span class="params">(OrderEvent event)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;\n[异步服务] 开始处理: &quot;</span> + event.getOrderId());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;async_error&quot;</span>.equals(event.getOrderId())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;异步任务处理失败: 外部API超时&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;   &gt; 异步任务完成&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.util.ErrorHandler;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 同步事件全局异常处理器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SyncEventErrorHandler</span> <span class="keyword">implements</span> <span class="title class_">ErrorHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleError</span><span class="params">(Throwable t)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;\n[全局同步异常处理器] 捕获异常: &quot;</span> + t.getMessage());</span><br><span class="line">        System.out.println(<span class="string">&quot;   &gt; 执行全局处理: 记录错误日志并告警&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.aop.interceptor.AsyncUncaughtExceptionHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6. 异步事件全局异常处理器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AsyncEventErrorHandler</span> <span class="keyword">implements</span> <span class="title class_">AsyncUncaughtExceptionHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleUncaughtException</span><span class="params">(Throwable ex, Method method, Object... params)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;\n[全局异步异常处理器] 捕获异常: &quot;</span> + ex.getMessage());</span><br><span class="line">        System.out.println(<span class="string">&quot;   &gt; 方法: &quot;</span> + method.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;   &gt; 参数类型: &quot;</span> + params[<span class="number">0</span>].getClass().getSimpleName());</span><br><span class="line">        System.out.println(<span class="string">&quot;   &gt; 执行补偿操作: 记录日志并通知管理员&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationEventPublisher;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationEventPublisher eventPublisher;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">placeOrder</span><span class="params">(String orderId)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;\n[主流程] 开始处理订单: &quot;</span> + orderId);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 模拟核心业务逻辑</span></span><br><span class="line">            System.out.println(<span class="string">&quot;   &gt; 创建订单记录&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 发布订单事件</span></span><br><span class="line">            eventPublisher.publishEvent(<span class="keyword">new</span> <span class="title class_">OrderEvent</span>(<span class="built_in">this</span>, orderId));</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;[主流程] 订单处理完成: &quot;</span> + orderId);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;[主流程异常] &quot;</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.aop.interceptor.AsyncUncaughtExceptionHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.event.ApplicationEventMulticaster;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.event.SimpleApplicationEventMulticaster;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.task.SimpleAsyncTaskExecutor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.AsyncConfigurer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.EnableAsync;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAsync</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EventConfig</span> <span class="keyword">implements</span> <span class="title class_">AsyncConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置异步事件广播器</span></span><br><span class="line">    <span class="meta">@Bean(name = &quot;applicationEventMulticaster&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ApplicationEventMulticaster <span class="title function_">applicationEventMulticaster</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">SimpleApplicationEventMulticaster</span> <span class="variable">eventMulticaster</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleApplicationEventMulticaster</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置同步事件的异常处理器</span></span><br><span class="line">        eventMulticaster.setErrorHandler(<span class="keyword">new</span> <span class="title class_">SyncEventErrorHandler</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置异步执行器</span></span><br><span class="line">        eventMulticaster.setTaskExecutor(<span class="keyword">new</span> <span class="title class_">SimpleAsyncTaskExecutor</span>());</span><br><span class="line">        <span class="keyword">return</span> eventMulticaster;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异步异常处理配置</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> AsyncUncaughtExceptionHandler <span class="title function_">getAsyncUncaughtExceptionHandler</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AsyncEventErrorHandler</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cylong.applicationeventpublisherdemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.CommandLineRunner;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.EnableAsync;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableAsync</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EventExceptionDemoApplication</span> <span class="keyword">implements</span> <span class="title class_">CommandLineRunner</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(EventExceptionDemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OrderService orderService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;\n===== 测试正常订单 =====&quot;</span>);</span><br><span class="line">        orderService.placeOrder(<span class="string">&quot;order_2023001&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">500</span>); <span class="comment">// 等待异步任务完成</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;\n===== 测试库存不足订单 =====&quot;</span>);</span><br><span class="line">        orderService.placeOrder(<span class="string">&quot;error_stock&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;\n===== 测试支付失败订单 =====&quot;</span>);</span><br><span class="line">        orderService.placeOrder(<span class="string">&quot;error_payment&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;\n===== 测试异步异常订单 =====&quot;</span>);</span><br><span class="line">        orderService.placeOrder(<span class="string">&quot;async_error&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>); <span class="comment">// 确保异步任务完成</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="输出结果"><a href="#输出结果" class="headerlink" title="输出结果"></a>输出结果</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">===== 测试正常订单 =====</span><br><span class="line"></span><br><span class="line">[主流程] 开始处理订单: order_2023001</span><br><span class="line">   &gt; 创建订单记录</span><br><span class="line">[主流程] 订单处理完成: order_2023001</span><br><span class="line"></span><br><span class="line">[库存服务] 处理订单: order_2023001</span><br><span class="line"></span><br><span class="line">[支付服务] 处理订单: order_2023001</span><br><span class="line"></span><br><span class="line">[通知服务] 处理订单: order_2023001</span><br><span class="line">   &gt; 已发送订单确认通知</span><br><span class="line">   &gt; 库存锁定成功</span><br><span class="line">   &gt; 支付处理成功</span><br><span class="line"></span><br><span class="line">[异步服务] 开始处理: order_2023001</span><br><span class="line">   &gt; 异步任务完成</span><br><span class="line"></span><br><span class="line">===== 测试库存不足订单 =====</span><br><span class="line"></span><br><span class="line">[主流程] 开始处理订单: error_stock</span><br><span class="line">   &gt; 创建订单记录</span><br><span class="line"></span><br><span class="line">[库存服务] 处理订单: error_stock</span><br><span class="line"></span><br><span class="line">[支付服务] 处理订单: error_stock</span><br><span class="line">   &gt; 支付处理成功</span><br><span class="line">   ! [库存异常] 库存不足，商品A缺货</span><br><span class="line">   &gt; 执行本地补偿: 释放预留资源</span><br><span class="line">[主流程] 订单处理完成: error_stock</span><br><span class="line"></span><br><span class="line">[通知服务] 处理订单: error_stock</span><br><span class="line"></span><br><span class="line">[异步服务] 开始处理: error_stock</span><br><span class="line"></span><br><span class="line">[全局同步异常处理器] 捕获异常: 通知服务失败: 短信配额不足</span><br><span class="line">   &gt; 执行全局处理: 记录错误日志并告警</span><br><span class="line">   &gt; 异步任务完成</span><br><span class="line"></span><br><span class="line">===== 测试支付失败订单 =====</span><br><span class="line"></span><br><span class="line">[主流程] 开始处理订单: error_payment</span><br><span class="line">   &gt; 创建订单记录</span><br><span class="line"></span><br><span class="line">[库存服务] 处理订单: error_payment</span><br><span class="line">   &gt; 库存锁定成功</span><br><span class="line"></span><br><span class="line">[支付服务] 处理订单: error_payment</span><br><span class="line">[主流程] 订单处理完成: error_payment</span><br><span class="line">   ! [支付异常] 支付失败，信用卡余额不足</span><br><span class="line">   &gt; 执行本地补偿: 取消支付预授权</span><br><span class="line"></span><br><span class="line">[通知服务] 处理订单: error_payment</span><br><span class="line">   &gt; 已发送订单确认通知</span><br><span class="line"></span><br><span class="line">[异步服务] 开始处理: error_payment</span><br><span class="line">   &gt; 异步任务完成</span><br><span class="line"></span><br><span class="line">===== 测试异步异常订单 =====</span><br><span class="line"></span><br><span class="line">[主流程] 开始处理订单: async_error</span><br><span class="line">   &gt; 创建订单记录</span><br><span class="line"></span><br><span class="line">[库存服务] 处理订单: async_error</span><br><span class="line">   &gt; 库存锁定成功</span><br><span class="line"></span><br><span class="line">[支付服务] 处理订单: async_error</span><br><span class="line">   &gt; 支付处理成功</span><br><span class="line">[主流程] 订单处理完成: async_error</span><br><span class="line"></span><br><span class="line">[通知服务] 处理订单: async_error</span><br><span class="line">   &gt; 已发送订单确认通知</span><br><span class="line"></span><br><span class="line">[异步服务] 开始处理: async_error</span><br><span class="line"></span><br><span class="line">[全局异步异常处理器] 捕获异常: 异步任务处理失败: 外部API超时</span><br><span class="line">   &gt; 方法: handleAsyncTask</span><br><span class="line">   &gt; 参数类型: OrderEvent</span><br><span class="line">   &gt; 执行补偿操作: 记录日志并通知管理员</span><br></pre></td></tr></table></figure><h2 id="异常处理机制解析"><a href="#异常处理机制解析" class="headerlink" title="异常处理机制解析"></a>异常处理机制解析</h2><ol><li><strong>局部异常捕获：</strong><ul><li>在监听器内部使用 <code>try-catch</code> 块</li><li>示例：库存和支付服务的监听器</li><li>特点：异常不会传播，不影响其他监听器</li><li>适用场景：需要独立处理的业务异常</li></ul></li><li><strong>全局同步异常处理：</strong><ul><li>实现 <code>ErrorHandler</code> 接口</li><li>通过 <code>SimpleApplicationEventMulticaster.setErrorHandler()</code> 注册</li><li>捕获所有未处理的同步事件异常</li><li>示例：<code>SyncEventErrorHandler</code></li><li>特点：集中处理未被捕获的同步异常</li></ul></li><li><strong>全局异步异常处理：</strong><ul><li>实现 <code>AsyncUncaughtExceptionHandler</code> 接口</li><li>通过 <code>AsyncConfigurer</code> 配置</li><li>捕获所有未处理的异步事件异常</li><li>示例：<code>AsyncEventErrorHandler</code></li><li>特点：专用于异步执行场景</li></ul></li></ol><h2 id="三种处理方式适用场景"><a href="#三种处理方式适用场景" class="headerlink" title="三种处理方式适用场景"></a>三种处理方式适用场景</h2><table><thead><tr><th>处理方式</th><th>适用场景</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>局部捕获</td><td>需要独立处理的业务异常</td><td>精确控制，不影响其他监听器</td><td>代码重复可能性高</td></tr><tr><td>全局同步处理</td><td>未捕获的同步异常统一处理</td><td>集中管理，避免异常传播</td><td>无法获取完整上下文</td></tr><tr><td>全局异步处理</td><td>所有未捕获的异步异常</td><td>统一处理异步任务失败</td><td>无法访问原始方法参数</td></tr></tbody></table><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><h2 id="作用域限制"><a href="#作用域限制" class="headerlink" title="作用域限制"></a>作用域限制</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 监听器需是 Spring 管理的 Bean</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserRegisterListener</span> &#123;...&#125;</span><br></pre></td></tr></table></figure><h2 id="事件源（source）的作用"><a href="#事件源（source）的作用" class="headerlink" title="事件源（source）的作用"></a>事件源（source）的作用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可获取事件发布者信息</span></span><br><span class="line"><span class="keyword">if</span> (event.getSource() <span class="keyword">instanceof</span> UserService) &#123;</span><br><span class="line">    <span class="comment">// 特殊处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="监听器执行顺序"><a href="#监听器执行顺序" class="headerlink" title="监听器执行顺序"></a>监听器执行顺序</h2><p>监听器按注册顺序执行（可通过 <code>@Order</code> 调整）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Order(1)</span>  <span class="comment">// 数字越小优先级越高</span></span><br><span class="line"><span class="meta">@EventListener</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">firstListener</span><span class="params">(UserRegisterEvent event)</span> &#123;...&#125;</span><br></pre></td></tr></table></figure><h2 id="异步处理"><a href="#异步处理" class="headerlink" title="异步处理"></a>异步处理</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Async</span>  <span class="comment">// 启用异步</span></span><br><span class="line"><span class="meta">@EventListener</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">asyncHandle</span><span class="params">(UserRegisterEvent event)</span> &#123;</span><br><span class="line">    <span class="comment">// 耗时操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需在配置类添加 <code>@EnableAsync</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableAsync</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApplicationEventPublisherDemoApplication</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">ConfigurableApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> SpringApplication.run(ApplicationEventPublisherDemoApplication.class, args);</span><br><span class="line"><span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> context.getBean(UserService.class);</span><br><span class="line">userService.registerUser(<span class="string">&quot;cylong&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="事件继承"><a href="#事件继承" class="headerlink" title="事件继承"></a>事件继承</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 监听父类事件会同时接收子类事件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VIPRegisterEvent</span> <span class="keyword">extends</span> <span class="title class_">UserRegisterEvent</span> &#123;...&#125;</span><br></pre></td></tr></table></figure><ol><li>监听 <code>UserRegisterEvent</code> 会接收到所有子类事件</li><li>使用 <code>@EventListener(classes = VIPRegisterEvent.class)</code> 限定具体类型</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EventListener(classes = VIPRegisterEvent.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleEvent</span><span class="params">(UserRegisterEvent event)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;[注解监听] 新 VIP 用户注册: &quot;</span> + event.getUsername());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="性能建议"><a href="#性能建议" class="headerlink" title="性能建议"></a>性能建议</h2><ol><li>避免在监听器执行耗时操作（默认同步，可以切换为异步）</li><li>单个事件避免注册过多监听器</li></ol><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><ol><li>监听器异常会传播到发布者</li><li>需要时添加单独异常处理</li></ol><p>通过 <code>ApplicationEventPublisher</code> 可实现优雅的业务解耦，但需根据场景权衡同步/异步机制。在实际项目中，建议将核心业务与辅助操作（邮件、日志等）通过事件分离，提升系统可维护性。</p><hr>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;基本介绍&quot;&gt;&lt;a href=&quot;#基本介绍&quot; class=&quot;headerlink&quot; title=&quot;基本介绍&quot;&gt;&lt;/a&gt;基本介绍&lt;/h1&gt;&lt;p&gt;&lt;code&gt;ApplicationEventPublisher&lt;/code&gt; 是 Spring 框架的核心接口，用于发布应用事件，实现观察者模式。其核心作用包括：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;事件发布：&lt;/strong&gt;允许组件发布自定义事件&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;松耦合：&lt;/strong&gt;实现发布者与订阅者的解耦&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;同步处理：&lt;/strong&gt;默认同步执行（可通过 &lt;code&gt;@Async&lt;/code&gt; 实现异步）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;继承机制：&lt;/strong&gt;事件对象可继承扩展（支持 &lt;code&gt;ApplicationEvent&lt;/code&gt; 或任意 &lt;code&gt;POJO&lt;/code&gt;）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;工作流程：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[发布者] → (发布事件) → [ApplicationContext] → (路由事件) → [监听器]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h1 id=&quot;应用场景&quot;&gt;&lt;a href=&quot;#应用场景&quot; class=&quot;headerlink&quot; title=&quot;应用场景&quot;&gt;&lt;/a&gt;应用场景&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;业务解耦：&lt;/strong&gt;如用户注册后发送邮件/短信&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;状态变更通知：&lt;/strong&gt;订单状态变化时更新库存&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;审计日志：&lt;/strong&gt;关键操作后记录审计信息&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;异步任务触发：&lt;/strong&gt;耗时操作异步执行&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;系统监控：&lt;/strong&gt;关键事件触发监控上报&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="Java" scheme="https://www.cylong.com/categories/Java/"/>
    
    
    <category term="Java" scheme="https://www.cylong.com/tags/Java/"/>
    
    <category term="Spring" scheme="https://www.cylong.com/tags/Spring/"/>
    
    <category term="SpringBoot" scheme="https://www.cylong.com/tags/SpringBoot/"/>
    
    <category term="后端框架" scheme="https://www.cylong.com/tags/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6/"/>
    
    <category term="事件驱动" scheme="https://www.cylong.com/tags/%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8/"/>
    
    <category term="ApplicationEventPublisher" scheme="https://www.cylong.com/tags/ApplicationEventPublisher/"/>
    
    <category term="观察者模式" scheme="https://www.cylong.com/tags/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>矩阵置零</title>
    <link href="https://www.cylong.com/blog/2025/06/13/set-matrix-zeroes/"/>
    <id>https://www.cylong.com/blog/2025/06/13/set-matrix-zeroes/</id>
    <published>2025-06-12T16:18:52.000Z</published>
    <updated>2025-06-12T16:18:52.000Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个 <code>m x n</code> 的矩阵，如果一个元素为 <code>0</code> ，则将其所在行和列的所有元素都设为 <code>0</code> 。请使用 <strong>原地算法</strong>。</p><p><strong>原地算法：</strong>在计算机科学中，一个原地算法（in-place algorithm）是一种使用小的，固定数量的额外之空间来转换资料的算法。当算法执行时，输入的资料通常会被要输出的部分覆盖掉。不是原地算法有时候称为非原地（not-in-place）或不得其所（out-of-place）。</p><p><strong>示例 1:</strong></p><img src="/blog/2025/06/13/set-matrix-zeroes/mat1.jpg" class=""><blockquote><p><strong>输入：</strong><code>matrix = [[1, 1, 1], [1, 0, 1], [1, 1, 1]]</code><br><strong>输出：</strong><code>[[1, 0, 1], [0, 0, 0], [1, 0, 1]]</code></p></blockquote><p><strong>示例 2:</strong></p><img src="/blog/2025/06/13/set-matrix-zeroes/mat2.jpg" class=""><blockquote><p><strong>输入：</strong><code>matrix = [[0, 1, 2, 0], [3, 4, 5, 2], [1, 3, 1, 5]]</code><br><strong>输出：</strong><code>[[0, 0, 0, 0], [0, 4, 5, 0], [0, 3, 1, 0]]</code></p></blockquote><p><strong>提示:</strong></p><ul><li><code>m == matrix.length</code></li><li><code>n == matrix[0].length</code></li><li><code>1 &lt;= m, n &lt;= 200</code></li><li><code>-2^31 &lt;= matrix[i][j] &lt;= 2^31 - 1</code></li></ul><span id="more"></span><h1 id="辅助数组法"><a href="#辅助数组法" class="headerlink" title="辅助数组法"></a>辅助数组法</h1><p>使用两个辅助数组分别记录需要置零的行和列。首先遍历矩阵，当遇到元素为 <code>0</code> 时，将对应的行标记和列标记设置为 <code>true</code>。然后再次遍历矩阵，根据行标记和列标记将相应元素置为 <code>0</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setZeroes</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取矩阵的行数和列数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">rowLen</span> <span class="operator">=</span> matrix.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">colLen</span> <span class="operator">=</span> matrix[<span class="number">0</span>].length;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建两个布尔数组，分别用于标记需要置零的行和列</span></span><br><span class="line">    <span class="type">boolean</span>[] row = <span class="keyword">new</span> <span class="title class_">boolean</span>[rowLen];</span><br><span class="line">    <span class="type">boolean</span>[] col = <span class="keyword">new</span> <span class="title class_">boolean</span>[colLen];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 第一次遍历：标记包含 0 的行和列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; rowLen; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; colLen; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                row[i] = <span class="literal">true</span>; <span class="comment">// 标记第 i 行需要置零</span></span><br><span class="line">                col[j] = <span class="literal">true</span>; <span class="comment">// 标记第 j 列需要置零</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 第二次遍历：根据标记数组将相应行和列的元素置零</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; rowLen; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; colLen; j++) &#123;</span><br><span class="line">            <span class="comment">// 如果当前行或列被标记，则将元素置为 0</span></span><br><span class="line">            <span class="keyword">if</span> (row[i] || col[j]) &#123;</span><br><span class="line">                matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li><strong>时间复杂度：</strong><code>O(m × n)</code>，其中 <code>m</code> 和 <code>n</code> 分别是矩阵的行数和列数。我们遍历了两次矩阵。</li><li><strong>空间复杂度：</strong><code>O(m + n)</code>，使用了两个辅助数组分别存储行和列的标记。</li></ul><h1 id="原地标记法（优化空间）"><a href="#原地标记法（优化空间）" class="headerlink" title="原地标记法（优化空间）"></a>原地标记法（优化空间）</h1><p>使用矩阵的第一行和第一列作为标记数组，代替上面解法中的额外数组。首先检查第一行和第一列是否需要置零，然后用第一行记录各列是否需要置零，第一列记录各行是否需要置零。最后根据标记处理除第一行第一列外的元素，再单独处理第一行和第一列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setZeroes</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">rowLen</span> <span class="operator">=</span> matrix.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">colLen</span> <span class="operator">=</span> matrix[<span class="number">0</span>].length;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查第一列是否有 0</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">colHasZero</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; rowLen; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix[i][<span class="number">0</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">            colHasZero = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查第一行是否有 0</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">rowHasZero</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; colLen; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix[<span class="number">0</span>][j] == <span class="number">0</span>) &#123;</span><br><span class="line">            rowHasZero = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用第一行和第一列标记其他行列的 0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; rowLen; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; colLen; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 这里其实也是先把有零的第一行和第一列位置置零了</span></span><br><span class="line">                matrix[i][<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// 标记第 i 行需要置零</span></span><br><span class="line">                matrix[<span class="number">0</span>][j] = <span class="number">0</span>; <span class="comment">// 标记第 j 列需要置零</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据标记设置除第一行和第一列外的元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; rowLen; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; colLen; j++) &#123;</span><br><span class="line">            <span class="comment">// 如果当前行或列被标记，则将元素置为 0</span></span><br><span class="line">            <span class="keyword">if</span> (matrix[i][<span class="number">0</span>] == <span class="number">0</span> || matrix[<span class="number">0</span>][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 处理第一列置零</span></span><br><span class="line">    <span class="keyword">if</span> (colHasZero) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; rowLen; i++) &#123;</span><br><span class="line">            matrix[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 处理第一行置零</span></span><br><span class="line">    <span class="keyword">if</span> (rowHasZero) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; colLen; j++) &#123;</span><br><span class="line">            matrix[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li><strong>时间复杂度：</strong><code>O(m × n)</code>，其中 <code>m</code> 和 <code>n</code> 分别是矩阵的行数和列数。我们遍历了多次矩阵，但时间复杂度仍是线性级别。</li><li><strong>空间复杂度：</strong><code>O(1)</code>，仅使用常数级别的额外空间。</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><table><thead><tr><th>解法</th><th>时间复杂度</th><th>空间复杂度</th><th>优势</th><th>劣势</th></tr></thead><tbody><tr><td>辅助数组法</td><td>O(m × n)</td><td>O(m + n)</td><td>思路清晰，实现简单，两次遍历矩阵即可完成</td><td>使用了额外的 O(m + n) 空间，不是原地算法</td></tr><tr><td>原地标记法</td><td>O(m × n)</td><td>O(1)</td><td>空间复杂度最优，仅使用常数空间，符合原地算法</td><td>实现逻辑相对复杂，需要多次遍历矩阵</td></tr></tbody></table><p>两种方法各有优劣，在实际应用中可根据具体场景选择最合适的解法。对于面试场景，掌握两种方法并能解释其优劣会更有优势。</p><h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><blockquote><p><a href="https://leetcode.cn/problems/set-matrix-zeroes/description/" title="73. 矩阵置零 | 力扣（LeetCode）">73. 矩阵置零 | 力扣（LeetCode）</a></p></blockquote><hr>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;给定一个 &lt;code&gt;m x n&lt;/code&gt; 的矩阵，如果一个元素为 &lt;code&gt;0&lt;/code&gt; ，则将其所在行和列的所有元素都设为 &lt;code&gt;0&lt;/code&gt; 。请使用 &lt;strong&gt;原地算法&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;原地算法：&lt;/strong&gt;在计算机科学中，一个原地算法（in-place algorithm）是一种使用小的，固定数量的额外之空间来转换资料的算法。当算法执行时，输入的资料通常会被要输出的部分覆盖掉。不是原地算法有时候称为非原地（not-in-place）或不得其所（out-of-place）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;img src=&quot;/blog/2025/06/13/set-matrix-zeroes/mat1.jpg&quot; class=&quot;&quot;&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt;&lt;code&gt;matrix = [[1, 1, 1], [1, 0, 1], [1, 1, 1]]&lt;/code&gt;&lt;br&gt;&lt;strong&gt;输出：&lt;/strong&gt;&lt;code&gt;[[1, 0, 1], [0, 0, 0], [1, 0, 1]]&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;/p&gt;
&lt;img src=&quot;/blog/2025/06/13/set-matrix-zeroes/mat2.jpg&quot; class=&quot;&quot;&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt;&lt;code&gt;matrix = [[0, 1, 2, 0], [3, 4, 5, 2], [1, 3, 1, 5]]&lt;/code&gt;&lt;br&gt;&lt;strong&gt;输出：&lt;/strong&gt;&lt;code&gt;[[0, 0, 0, 0], [0, 4, 5, 0], [0, 3, 1, 0]]&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;提示:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;m == matrix.length&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;n == matrix[0].length&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= m, n &amp;lt;= 200&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-2^31 &amp;lt;= matrix[i][j] &amp;lt;= 2^31 - 1&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://www.cylong.com/categories/LeetCode/"/>
    
    
    <category term="Java" scheme="https://www.cylong.com/tags/Java/"/>
    
    <category term="LeetCode" scheme="https://www.cylong.com/tags/LeetCode/"/>
    
    <category term="学习笔记" scheme="https://www.cylong.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="数组" scheme="https://www.cylong.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="矩阵" scheme="https://www.cylong.com/tags/%E7%9F%A9%E9%98%B5/"/>
    
    <category term="LeetCode中等" scheme="https://www.cylong.com/tags/LeetCode%E4%B8%AD%E7%AD%89/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot 入门指南：从零开始创建 Web 应用</title>
    <link href="https://www.cylong.com/blog/2025/06/12/spring-boot/"/>
    <id>https://www.cylong.com/blog/2025/06/12/spring-boot/</id>
    <published>2025-06-12T07:10:26.000Z</published>
    <updated>2025-06-12T07:10:26.000Z</updated>
    
    <content type="html"><![CDATA[<hr><blockquote><p>本文面向 Java 初学者，详细介绍 Spring Boot 框架原理、应用场景及从零搭建 Web 应用的完整流程。</p></blockquote><h1 id="Spring-Boot-框架简介"><a href="#Spring-Boot-框架简介" class="headerlink" title="Spring Boot 框架简介"></a>Spring Boot 框架简介</h1><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>Spring Boot 是 Spring 框架的扩展，通过 <strong>约定优于配置</strong> 的理念解决传统 Spring 应用配置复杂的问题，简化 Spring 应用的初始搭建和开发过程。通过自动配置和起步依赖（Starter Dependencies）来减少开发者的配置工作，Spring Boot 内嵌了 Tomcat、Jetty 或 Undertow 等服务器，因此无需部署 WAR 文件即可运行。核心思想是 <strong>让开发更简单</strong> 。</p><h2 id="核心特性"><a href="#核心特性" class="headerlink" title="核心特性"></a>核心特性</h2><ol><li><strong>自动配置</strong>：通过 <code>@EnableAutoConfiguration</code> 自动配置 Bean（基于项目中的 jar 依赖自动配置 Spring 应用）</li><li><strong>起步依赖</strong>：通过提供预定义的依赖描述符（如 <code>spring-boot-starter-web</code> 包含了开发 Web 应用所需的依赖）简化构建配置，解决版本冲突。</li><li><strong>内嵌服务</strong>：内置 Tomcat/Jetty/Undertow 等服务器，无需部署 WAR，直接运行一个独立的应用即可。</li><li><strong>Actuator</strong>：提供生产级监控和管理功能，如监控应用的健康状况、信息查看等。</li></ol><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[启动类] → [@SpringBootApplication] </span><br><span class="line">    → 扫描 @Component → 加载 @Configuration </span><br><span class="line">    → 读取 spring.factories → 应用自动配置</span><br><span class="line">    → 启动内嵌容器</span><br></pre></td></tr></table></figure><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>Spring Boot 适用于构建微服务架构、RESTful API、企业级应用等。</p><span id="more"></span><h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><h2 id="软件版本"><a href="#软件版本" class="headerlink" title="软件版本"></a>软件版本</h2><ol><li><strong>开发工具</strong>：IntelliJ IDEA 2021+</li><li><strong>Java环境</strong>：JDK 1.8 或以上版本（建议使用 JDK 11 或 17）</li><li><strong>构建工具</strong>：Maven 3.6+（IDEA 一般自带，但需确保配置正确）</li></ol><h2 id="配置-Maven-的-settings-xml"><a href="#配置-Maven-的-settings-xml" class="headerlink" title="配置 Maven 的 settings.xml"></a>配置 Maven 的 settings.xml</h2><p>Maven的 <code>settings.xml</code>文件用于配置全局的 Maven 设置，如仓库镜像、代理等。通常位于Maven 安装目录的 <code>conf</code> 文件夹下，或者用户目录下的 <code>.m2</code> 文件夹（如 <code>~/.m2/settings.xml</code>），在 <code>IDEA → Settings</code> 中可以直接查看文件路径：</p><img src="/blog/2025/06/12/spring-boot/m2-settings-path.png" class=""><p>配置样例如下：</p><figure class="highlight xml"><figcaption><span>settings.xml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/SETTINGS/1.0.0&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/SETTINGS/1.0.0 </span></span></span><br><span class="line"><span class="string"><span class="tag">          http://maven.apache.org/xsd/settings-1.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 添加阿里云镜像加速 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirrors</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>aliyun<span class="tag">&lt;/<span class="name">id</span>&gt;</span> <span class="comment">&lt;!-- 镜像的唯一标识 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>Aliyun Public Repository<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://maven.aliyun.com/repository/public<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>*<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span> <span class="comment">&lt;!-- 匹配哪些仓库，`*` 表示所有仓库都使用该镜像 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirrors</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="IDEA-配置"><a href="#IDEA-配置" class="headerlink" title="IDEA 配置"></a>IDEA 配置</h2><ol><li>配置 Maven 路径：<code>File → Settings → Build, Execution, Deployment → Build Tools → Maven</code></li><li>设置 JDK 版本：<code>File → Project Structure → SDKs</code></li></ol><h1 id="创建-Spring-Boot-项目"><a href="#创建-Spring-Boot-项目" class="headerlink" title="创建 Spring Boot 项目"></a>创建 Spring Boot 项目</h1><h2 id="项目初始化"><a href="#项目初始化" class="headerlink" title="项目初始化"></a>项目初始化</h2><p>在 IDEA 中创建 Spring Boot 项目有两种常用方式：</p><ol><li>通过 Spring Initializr 网站（<a href="https://start.spring.io/">https://start.spring.io/</a>）生成项目，然后导入 IDEA。<img src="/blog/2025/06/12/spring-boot/spring-initializr-web.png" class=""></li><li>打开 <code>IDEA → New → Project → Spring Boot</code>，配置项目信息<img src="/blog/2025/06/12/spring-boot/new-project.png" class=""></li><li>添加依赖<ul><li><strong>Spring Web</strong>：用于构建Web应用</li><li><strong>Lombok</strong>：非必须，主要用于简化代码<img src="/blog/2025/06/12/spring-boot/dependencies.png" class=""></li></ul></li></ol><h2 id="项目结构解析"><a href="#项目结构解析" class="headerlink" title="项目结构解析"></a>项目结构解析</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SpringBootDemo</span><br><span class="line">├── src/main/java</span><br><span class="line">│   └── com/cylong/springbootdemo</span><br><span class="line">│       ├── SpringBootDemoApplication.java  # 主启动类</span><br><span class="line">│       └── controller</span><br><span class="line">│           ├── HelloController.java # 控制器</span><br><span class="line">│           └── Student.java         # 这里主要用于展示 Lombok 简化代码作用</span><br><span class="line">├── src/main/resources</span><br><span class="line">│   ├── application.properties # 配置文件</span><br><span class="line">│   ├── static                 # 静态资源（HTML, CSS, JS）</span><br><span class="line">│   └── templates              # 模板文件（Thymeleaf）</span><br><span class="line">├── src/test                   # 测试代码</span><br><span class="line">└── pom.xml                    # Maven 配置</span><br></pre></td></tr></table></figure><h1 id="核心配置文件详解"><a href="#核心配置文件详解" class="headerlink" title="核心配置文件详解"></a>核心配置文件详解</h1><h2 id="pom-xml-解析"><a href="#pom-xml-解析" class="headerlink" title="pom.xml 解析"></a>pom.xml 解析</h2><figure class="highlight xml"><figcaption><span>pom.xml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 继承 Spring Boot 默认配置，它提供了依赖管理，这样我们在添加其他 Spring Boot 依赖时就不需要指定版本号了 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 通常填写公司或者个人域名的倒序，例如：com.example --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.cylong<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 项目名称 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>SpringBootDemo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>SpringBootDemo<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>SpringBootDemo<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>24<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- Web 开发核心依赖，（如 Spring MVC，内嵌 Tomcat 等） --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 测试依赖 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- Lombok 依赖--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 打包插件（生成可执行 Jar） --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">annotationProcessorPaths</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">path</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">annotationProcessorPaths</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">exclude</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="application-properties-解析"><a href="#application-properties-解析" class="headerlink" title="application.properties 解析"></a>application.properties 解析</h2><figure class="highlight yml"><figcaption><span>application.properties</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 应用名称</span></span><br><span class="line"><span class="string">spring.application.name=SpringBootDemo</span></span><br><span class="line"><span class="comment"># 修改端口 默认8080</span></span><br><span class="line"><span class="string">server.port=9090</span></span><br><span class="line"><span class="comment"># 配置上下文，URL变为：http://localhost:9090/demo/hello</span></span><br><span class="line"><span class="comment"># 如果不配置，默认是：http://localhost:9090/hello</span></span><br><span class="line"><span class="string">server.servlet.context-path=/demo</span></span><br><span class="line"><span class="comment"># 自定义属性</span></span><br><span class="line"><span class="string">welcome.message=Hello</span> <span class="string">Spring</span> <span class="string">Boot</span></span><br></pre></td></tr></table></figure><h1 id="编写第一个-Web-接口"><a href="#编写第一个-Web-接口" class="headerlink" title="编写第一个 Web 接口"></a>编写第一个 Web 接口</h1><h2 id="创建控制器"><a href="#创建控制器" class="headerlink" title="创建控制器"></a>创建控制器</h2><figure class="highlight java"><figcaption><span>HelloController.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cylong.springbootdemo.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表明这是一个控制器，并且返回的数据直接写入响应体（如 JSON 或字符串）</span></span><br><span class="line"><span class="meta">@RestController</span> <span class="comment">// = @Controller + @ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// application.properties 中自定义属性</span></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;welcome.message&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String welcomeMsg;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 映射 GET 请求到 /hello 路径</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        student.setNo(<span class="string">&quot;1000&quot;</span>);</span><br><span class="line">        student.setName(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> welcomeMsg + <span class="string">&quot; &quot;</span> + student.getName() + <span class="string">&quot; 访问成功！&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>Student.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cylong.springbootdemo.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 学号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String no;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 姓名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里 <code>@Data</code> 是 Lombok 提供的一个组合注解，它主要用于简化 Java Bean 的编写。当你在类上使用 <code>@Data</code> 注解时，Lombok 会在编译时自动为类生成以下方法：</p><ol><li>所有字段的 <code>getter</code> 方法（对于非 <code>static</code> 字段）</li><li>所有非 <code>final</code> 字段的 <code>setter</code> 方法</li><li><code>equals()</code> 方法</li><li><code>hashCode()</code> 方法</li><li><code>toString()</code> 方法</li></ol><h2 id="创建启动类"><a href="#创建启动类" class="headerlink" title="创建启动类"></a>创建启动类</h2><figure class="highlight java"><figcaption><span>SpringBootDemoApplication.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cylong.springbootdemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 核心注解：启用自动配置和组件扫描</span></span><br><span class="line"><span class="comment">// 组合了 @Configuration + @EnableAutoConfiguration + @ComponentScan</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringBootDemoApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 启动 Spring 应用</span></span><br><span class="line">        SpringApplication.run(SpringBootDemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="运行与测试"><a href="#运行与测试" class="headerlink" title="运行与测试"></a>运行与测试</h1><h2 id="启动应用"><a href="#启动应用" class="headerlink" title="启动应用"></a>启动应用</h2><ol><li>右键 <code>SpringBootDemoApplication → Run &#39;SpringBootDemoApplication&#39;</code> 或者使用 IDEA 工具栏的运行按钮。</li><li>查看控制台输出：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  .   ____          _            __ _ _</span><br><span class="line"> /\\ / ___&#x27;_ __ _ _(_)_ __  __ _ \ \ \ \</span><br><span class="line">( ( )\___ | &#x27;_ | &#x27;_| | &#x27;_ \/ _` | \ \ \ \</span><br><span class="line"> \\/  ___)| |_)| | | | | || (_| |  ) ) ) )</span><br><span class="line">  &#x27;  |____| .__|_| |_|_| |_\__, | / / / /</span><br><span class="line"> =========|_|==============|___/=/_/_/_/</span><br><span class="line"></span><br><span class="line"> :: Spring Boot ::                (v3.5.0)</span><br><span class="line"></span><br><span class="line">2025-06-15T06:53:46.411+08:00  INFO 22460 --- [SpringBootDemo] [           main] c.c.s.SpringBootDemoApplication          : Starting SpringBootDemoApplication using Java 24.0.1 with PID 22460 (D:\Github\IdeaProjects\SpringBootDemo\target\classes started by win in D:\Github\IdeaProjects\SpringBootDemo)</span><br><span class="line">2025-06-15T06:53:46.413+08:00  INFO 22460 --- [SpringBootDemo] [           main] c.c.s.SpringBootDemoApplication          : No active profile set, falling back to 1 default profile: &quot;default&quot;</span><br><span class="line">2025-06-15T06:53:46.865+08:00  INFO 22460 --- [SpringBootDemo] [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat initialized with port 9090 (http)</span><br><span class="line">2025-06-15T06:53:46.875+08:00  INFO 22460 --- [SpringBootDemo] [           main] o.apache.catalina.core.StandardService   : Starting service [Tomcat]</span><br><span class="line">2025-06-15T06:53:46.875+08:00  INFO 22460 --- [SpringBootDemo] [           main] o.apache.catalina.core.StandardEngine    : Starting Servlet engine: [Apache Tomcat/10.1.41]</span><br><span class="line">2025-06-15T06:53:46.904+08:00  INFO 22460 --- [SpringBootDemo] [           main] o.a.c.c.C.[Tomcat].[localhost].[/demo]   : Initializing Spring embedded WebApplicationContext</span><br><span class="line">2025-06-15T06:53:46.904+08:00  INFO 22460 --- [SpringBootDemo] [           main] w.s.c.ServletWebServerApplicationContext : Root WebApplicationContext: initialization completed in 462 ms</span><br><span class="line">2025-06-15T06:53:47.124+08:00  INFO 22460 --- [SpringBootDemo] [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port 9090 (http) with context path &#x27;/demo&#x27;</span><br><span class="line">2025-06-15T06:53:47.129+08:00  INFO 22460 --- [SpringBootDemo] [           main] c.c.s.SpringBootDemoApplication          : Started SpringBootDemoApplication in 1.0 seconds (process running for 1.349)</span><br></pre></td></tr></table></figure></li></ol><h2 id="浏览器访问"><a href="#浏览器访问" class="headerlink" title="浏览器访问"></a>浏览器访问</h2><p>应用启动后，默认端口是 8080。我上文配置文件修改了端口号为 9090，并且设置了 <code>context-path=/demo</code>，所以打开浏览器访问：<a href="http://localhost:9090/demo/hello">http://localhost:9090/demo/hello</a> （默认是：<a href="http://localhost:8080/hello">http://localhost:8080/hello</a>）</p><p>页面输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello Spring Boot 张三 访问成功！</span><br></pre></td></tr></table></figure><h2 id="项目打包部署"><a href="#项目打包部署" class="headerlink" title="项目打包部署"></a>项目打包部署</h2><ol><li><p>bash 执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成可执行 JAR</span></span><br><span class="line">mvn clean package <span class="comment"># 生成 target/SpringBootDemo-0.0.1-SNAPSHOT.jar</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行应用</span></span><br><span class="line">java -jar target/SpringBootDemo-0.0.1-SNAPSHOT.jar</span><br></pre></td></tr></table></figure></li><li><p>或者直接图形化界面打包：</p></li></ol><img src="/blog/2025/06/12/spring-boot/maven-package.png" class=""><h1 id="常见问题排查"><a href="#常见问题排查" class="headerlink" title="常见问题排查"></a>常见问题排查</h1><ol><li>端口冲突：修改 <code>server.port=9090</code>，默认是 <code>8080</code></li><li>404 错误：<ul><li>检查 <code>@RestController</code> 注解</li><li>确认 URL 包含 <code>context-path</code></li></ul></li><li>依赖下载失败：<ul><li>检查 Maven 镜像配置</li><li>执行 <code>mvn clean install -U</code></li></ul></li></ol><hr>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;本文面向 Java 初学者，详细介绍 Spring Boot 框架原理、应用场景及从零搭建 Web 应用的完整流程。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;Spring-Boot-框架简介&quot;&gt;&lt;a href=&quot;#Spring-Boot-框架简介&quot; class=&quot;headerlink&quot; title=&quot;Spring Boot 框架简介&quot;&gt;&lt;/a&gt;Spring Boot 框架简介&lt;/h1&gt;&lt;h2 id=&quot;基本原理&quot;&gt;&lt;a href=&quot;#基本原理&quot; class=&quot;headerlink&quot; title=&quot;基本原理&quot;&gt;&lt;/a&gt;基本原理&lt;/h2&gt;&lt;p&gt;Spring Boot 是 Spring 框架的扩展，通过 &lt;strong&gt;约定优于配置&lt;/strong&gt; 的理念解决传统 Spring 应用配置复杂的问题，简化 Spring 应用的初始搭建和开发过程。通过自动配置和起步依赖（Starter Dependencies）来减少开发者的配置工作，Spring Boot 内嵌了 Tomcat、Jetty 或 Undertow 等服务器，因此无需部署 WAR 文件即可运行。核心思想是 &lt;strong&gt;让开发更简单&lt;/strong&gt; 。&lt;/p&gt;
&lt;h2 id=&quot;核心特性&quot;&gt;&lt;a href=&quot;#核心特性&quot; class=&quot;headerlink&quot; title=&quot;核心特性&quot;&gt;&lt;/a&gt;核心特性&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;自动配置&lt;/strong&gt;：通过 &lt;code&gt;@EnableAutoConfiguration&lt;/code&gt; 自动配置 Bean（基于项目中的 jar 依赖自动配置 Spring 应用）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;起步依赖&lt;/strong&gt;：通过提供预定义的依赖描述符（如 &lt;code&gt;spring-boot-starter-web&lt;/code&gt; 包含了开发 Web 应用所需的依赖）简化构建配置，解决版本冲突。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;内嵌服务&lt;/strong&gt;：内置 Tomcat/Jetty/Undertow 等服务器，无需部署 WAR，直接运行一个独立的应用即可。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Actuator&lt;/strong&gt;：提供生产级监控和管理功能，如监控应用的健康状况、信息查看等。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;工作原理&quot;&gt;&lt;a href=&quot;#工作原理&quot; class=&quot;headerlink&quot; title=&quot;工作原理&quot;&gt;&lt;/a&gt;工作原理&lt;/h2&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[启动类] → [@SpringBootApplication] &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    → 扫描 @Component → 加载 @Configuration &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    → 读取 spring.factories → 应用自动配置&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    → 启动内嵌容器&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h2 id=&quot;应用场景&quot;&gt;&lt;a href=&quot;#应用场景&quot; class=&quot;headerlink&quot; title=&quot;应用场景&quot;&gt;&lt;/a&gt;应用场景&lt;/h2&gt;&lt;p&gt;Spring Boot 适用于构建微服务架构、RESTful API、企业级应用等。&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="https://www.cylong.com/categories/Java/"/>
    
    
    <category term="Java" scheme="https://www.cylong.com/tags/Java/"/>
    
    <category term="Spring" scheme="https://www.cylong.com/tags/Spring/"/>
    
    <category term="SpringBoot" scheme="https://www.cylong.com/tags/SpringBoot/"/>
    
    <category term="JavaWeb" scheme="https://www.cylong.com/tags/JavaWeb/"/>
    
    <category term="后端框架" scheme="https://www.cylong.com/tags/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6/"/>
    
    <category term="RESTfulAPI" scheme="https://www.cylong.com/tags/RESTfulAPI/"/>
    
  </entry>
  
  <entry>
    <title>最大子数组和</title>
    <link href="https://www.cylong.com/blog/2025/06/09/maximum-subarray/"/>
    <id>https://www.cylong.com/blog/2025/06/09/maximum-subarray/</id>
    <published>2025-06-09T14:40:57.000Z</published>
    <updated>2025-06-09T14:40:57.000Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p><strong>子数组</strong> 是数组中的一个连续部分。</p><p><strong>示例 1:</strong></p><blockquote><p><strong>输入：</strong><code>nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]</code><br><strong>输出：</strong>6<br><strong>解释：</strong>连续子数组 <code>[4, -1, 2, 1]</code> 的和最大，为 <code>6</code> 。</p></blockquote><p><strong>示例 2:</strong></p><blockquote><p><strong>输入：</strong><code>nums = [1]</code><br><strong>输出：</strong>1</p></blockquote><p><strong>示例 3:</strong></p><blockquote><p><strong>输入：</strong><code>nums = [5, 4, -1, 7, 8]</code><br><strong>输出：</strong>23</p></blockquote><p><strong>提示:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 10^5</code></li><li><code>-10^4 &lt;= nums[i] &lt;= 10^4</code></li></ul><span id="more"></span><h1 id="暴力枚举"><a href="#暴力枚举" class="headerlink" title="暴力枚举"></a>暴力枚举</h1><p>最简单的思路，通过两层循环遍历所有可能的连续子数组，计算每个子数组的和并记录最大值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; nums.length; j++) &#123;</span><br><span class="line">            sum += nums[j];</span><br><span class="line">            max = Math.max(max, sum);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li><strong>时间复杂度：</strong><code>O(n²)</code>，其中 <code>n</code> 是数组长度。需要两层循环遍历所有子数组。</li><li><strong>空间复杂度：</strong><code>O(1)</code>，仅使用常数级别的额外空间。</li></ul><h1 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h1><p>参考前缀和的定义：<a href="/blog/2025/06/03/range-sum-query-immutable/" title="303. 区域和检索 - 数组不可变 | 笑话人生">303. 区域和检索 - 数组不可变 | 笑话人生</a></p><p>利用前缀和的思想，由于子数组的元素和等于两个前缀和的差，遍历数组计算前缀和，同时维护当前最小前缀和。最大子数组和即为当前前缀和与最小前缀和的差值的最大值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">prefixSum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">minPrefixSum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        prefixSum += nums[i];</span><br><span class="line">        max = Math.max(max, prefixSum - minPrefixSum);</span><br><span class="line">        minPrefixSum = Math.min(minPrefixSum, prefixSum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li><strong>时间复杂度：</strong><code>O(n)</code>，只需一次遍历数组。</li><li><strong>空间复杂度：</strong><code>O(1)</code>，仅使用常数级别的额外空间。</li></ul><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p>定义 <code>dp[i]</code> 表示以 <code>nums[i]</code> 结尾的最大子数组和。状态转移方程为：<code>dp[i] = Math.max(dp[i - 1], 0) + nums[i]</code>。最终结果为 <code>dp</code> 数组中的最大值。可以简单的理解为，如果 <code>nums[i]</code> 左边的子数组和 <code>dp[i - 1] &lt; 0</code>，那么加上 <code>nums[i]</code> 的值会导致子数组和更小，所以这个时候取 <code>nums[i]</code> 的值即可，否则就将 <code>nums[i]</code> 的值加入 <code>dp[i - 1]</code> 的子数组和。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">    dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> dp[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        dp[i] = Math.max(dp[i - <span class="number">1</span>], <span class="number">0</span>) + nums[i];</span><br><span class="line">        max = Math.max(max, dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li><strong>时间复杂度：</strong><code>O(n)</code>，只需一次遍历数组。</li><li><strong>空间复杂度：</strong><code>O(n)</code>，需要额外的 <code>dp</code> 数组存储中间结果。</li></ul><h1 id="动态规划（空间优化）"><a href="#动态规划（空间优化）" class="headerlink" title="动态规划（空间优化）"></a>动态规划（空间优化）</h1><p>在以上动态规划的基础上进行空间优化。由于 <code>dp[i]</code> 只依赖于 <code>dp[i - 1]</code>，因此可以用一个变量代替 <code>dp</code> 数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">dp</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        dp = Math.max(dp, <span class="number">0</span>) + nums[i];</span><br><span class="line">        max = Math.max(max, dp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析-3"><a href="#复杂度分析-3" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li><strong>时间复杂度：</strong><code>O(n)</code>，只需一次遍历数组。</li><li><strong>空间复杂度：</strong><code>O(1)</code>，仅使用常数级别的额外空间。</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><table><thead><tr><th>解法</th><th>时间复杂度</th><th>空间复杂度</th><th>特点</th></tr></thead><tbody><tr><td>暴力枚举</td><td>O(n²)</td><td>O(1)</td><td>思路简单，效率低</td></tr><tr><td>前缀和</td><td>O(n)</td><td>O(1)</td><td>利用前缀和思想</td></tr><tr><td>动态规划</td><td>O(n)</td><td>O(n)</td><td>标准动态规划解法</td></tr><tr><td>动态规划优化</td><td>O(n)</td><td>O(1)</td><td>最优解法，推荐使用</td></tr></tbody></table><h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><blockquote><p><a href="https://leetcode.cn/problems/maximum-subarray/description/" title="53. 最大子数组和 | 力扣（LeetCode）">53. 最大子数组和 | 力扣（LeetCode）</a><br><a href="https://leetcode.cn/problems/maximum-subarray/solutions/2533977/qian-zhui-he-zuo-fa-ben-zhi-shi-mai-mai-abu71/?envType=study-plan-v2&envId=top-100-liked" title="53. 最大子数组和 | 题解 | 灵茶山艾府">53. 最大子数组和 | 题解 | 灵茶山艾府</a></p></blockquote><hr>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;给你一个整数数组 &lt;code&gt;nums&lt;/code&gt; ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;子数组&lt;/strong&gt; 是数组中的一个连续部分。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt;&lt;code&gt;nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]&lt;/code&gt;&lt;br&gt;&lt;strong&gt;输出：&lt;/strong&gt;6&lt;br&gt;&lt;strong&gt;解释：&lt;/strong&gt;连续子数组 &lt;code&gt;[4, -1, 2, 1]&lt;/code&gt; 的和最大，为 &lt;code&gt;6&lt;/code&gt; 。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt;&lt;code&gt;nums = [1]&lt;/code&gt;&lt;br&gt;&lt;strong&gt;输出：&lt;/strong&gt;1&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例 3:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt;&lt;code&gt;nums = [5, 4, -1, 7, 8]&lt;/code&gt;&lt;br&gt;&lt;strong&gt;输出：&lt;/strong&gt;23&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;提示:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= nums.length &amp;lt;= 10^5&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-10^4 &amp;lt;= nums[i] &amp;lt;= 10^4&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://www.cylong.com/categories/LeetCode/"/>
    
    
    <category term="Java" scheme="https://www.cylong.com/tags/Java/"/>
    
    <category term="LeetCode" scheme="https://www.cylong.com/tags/LeetCode/"/>
    
    <category term="学习笔记" scheme="https://www.cylong.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="数组" scheme="https://www.cylong.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="动态规划" scheme="https://www.cylong.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="LeetCode中等" scheme="https://www.cylong.com/tags/LeetCode%E4%B8%AD%E7%AD%89/"/>
    
    <category term="前缀和" scheme="https://www.cylong.com/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    
    <category term="子数组" scheme="https://www.cylong.com/tags/%E5%AD%90%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>和为 K 的子数组</title>
    <link href="https://www.cylong.com/blog/2025/06/05/subarray-sum-equals-k/"/>
    <id>https://www.cylong.com/blog/2025/06/05/subarray-sum-equals-k/</id>
    <published>2025-06-05T15:43:23.000Z</published>
    <updated>2025-06-05T15:43:23.000Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你统计并返回 该数组中和为 <code>k</code> 的子数组的个数 。</p><p><strong>子数组</strong> 是数组中元素的连续非空序列。</p><p><strong>示例 1:</strong></p><blockquote><p><strong>输入：</strong><code>nums = [1, 1, 1]</code>, <code>k = 2</code><br><strong>输出：</strong><code>2</code></p></blockquote><p><strong>示例 2:</strong></p><blockquote><p><strong>输入：</strong><code>nums = [1, 2, 3]</code>, <code>k = 3</code><br><strong>输出：</strong><code>2</code></p></blockquote><p><strong>提示:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 2 * 10^4</code></li><li><code>-1000 &lt;= nums[i] &lt;= 1000</code></li><li><code>-10^7 &lt;= k &lt;= 10^7</code></li></ul><span id="more"></span><h1 id="暴力枚举（双重循环）"><a href="#暴力枚举（双重循环）" class="headerlink" title="暴力枚举（双重循环）"></a>暴力枚举（双重循环）</h1><p>最直观的方法是枚举所有可能的连续子数组，计算它们的和并统计等于 <code>k</code> 的个数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">subarraySum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; nums.length; j++) &#123;</span><br><span class="line">            sum += nums[j];</span><br><span class="line">            <span class="keyword">if</span> (sum == k) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li><strong>时间复杂度：</strong><code>O(n²)</code>，其中 <code>n</code> 是数组长度。外层循环遍历每个元素作为起始点，内层循环遍历从起始点开始的所有子数组。</li><li><strong>空间复杂度：</strong><code>O(1)</code>，只使用了常数级别的额外空间。</li></ul><h1 id="前缀和-哈希表"><a href="#前缀和-哈希表" class="headerlink" title="前缀和 + 哈希表"></a>前缀和 + 哈希表</h1><p>在做这道题之前，我们先看之前做过的两道题：</p><ol><li><a href="/blog/2025/06/03/range-sum-query-immutable/" title="303. 区域和检索 - 数组不可变 | 笑话人生">303. 区域和检索 - 数组不可变 | 笑话人生</a></li><li><a href="/blog/2019/11/06/two-sum/" title="1. 两数之和 | 笑话人生">1. 两数之和 | 笑话人生</a></li></ol><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>利用 <strong>前缀和</strong> 技术优化计算过程：</p><ol><li>计算数组的前缀和数组 <code>prefix</code>，其中：<ul><li><code>prefix[0] = 0</code>，表示空数组的和，用于处理从第一个元素开始的子数组</li><li><code>prefix[i + 1] = nums[0] + nums[1] + ... + nums[i]（i ≥ 0）</code></li></ul></li><li>对于任意子数组 <code>nums[i..j]</code>（包含下标 <code>i</code> 到 <code>j</code>），其和可表示为 <code>prefix[j + 1] - prefix[i]</code></li><li>问题转化为：寻找满足 <code>prefix[j + 1] - prefix[i] = k</code> 且 <code>0 ≤ i &lt; j + 1 ≤ n</code> 的索引对 <code>(i, j)</code> 的数量</li><li>使用哈希表存储每个前缀和出现的次数，遍历时查询 <code>prefix[j] - k</code> 的出现次数并累加（这其实就是上面的两数之和）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">subarraySum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="type">int</span>[] prefix = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 计算前缀和</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        prefix[i + <span class="number">1</span>] = prefix[i] + nums[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 设置容量可以快 2ms</span></span><br><span class="line">    Map&lt;Integer, Integer&gt; countMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> p : prefix) &#123;</span><br><span class="line">        <span class="comment">// 查找前缀和为 p - k 的出现次数</span></span><br><span class="line">        count += countMap.getOrDefault(p - k, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 更新当前前缀和的出现次数</span></span><br><span class="line">        countMap.put(p, countMap.getOrDefault(p, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="示例解析"><a href="#示例解析" class="headerlink" title="示例解析"></a>示例解析</h2><p>以 <code>nums = [1, 1, 1]</code>, <code>k=2</code> 为例：</p><ol><li>前缀和数组：<code>prefix = [0, 1, 2, 3]</code></li><li>遍历过程：<ul><li><code>p=0</code>：查找 <code>-2</code> → 不存在，<code>count=0</code>；更新 <code>map&#123;0:1&#125;</code></li><li><code>p=1</code>：查找 <code>-1</code> → 不存在，<code>count=0</code>；更新 <code>map&#123;0:1, 1:1&#125;</code></li><li><code>p=2</code>：查找 <code>0</code> → 存在1次，<code>count=1</code>；更新 <code>map&#123;0:1, 1:1, 2:1&#125;</code></li><li><code>p=3</code>：查找 <code>1</code> → 存在1次，<code>count=2</code>；更新 <code>map&#123;0:1, 1:1, 2:1, 3:1&#125;</code></li></ul></li><li>返回结果：<code>2</code></li></ol><h2 id="常见问题解答"><a href="#常见问题解答" class="headerlink" title="常见问题解答"></a>常见问题解答</h2><ol><li>为什么需要 <code>prefix[0] = 0</code>？<br>考虑子数组从第一个元素开始的情况：子数组<code> nums[0..j]</code> 的和应为 <code>prefix[j + 1] - prefix[0]</code> 没有 <code>prefix[0]</code> 就无法表示从数组开头开始的子数组</li><li>哈希表如何处理重复前缀和？当不同位置产生相同的前缀和时，哈希表记录出现次数。例如：<ul><li><code>nums = [0, 0, 0]</code>, <code>k=0</code></li><li>前缀和：<code>[0, 0, 0, 0]</code></li><li>遍历时：<ul><li><code>p=0</code>：查找 <code>0</code> → 初始不存在，<code>count=0</code>；记录 <code>0:1</code></li><li><code>p=0</code>：查找 <code>0</code> → 存在1次，<code>count=1</code>；记录 <code>0:2</code></li><li><code>p=0</code>：查找 <code>0</code> → 存在2次，<code>count=3</code>；记录 <code>0:3</code></li><li><code>p=0</code>：查找 <code>0</code> → 存在3次，<code>count=6</code>；记录 <code>0:4</code></li></ul></li><li>返回结果：6（正确对应6个子数组）</li></ul></li></ol><h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li><strong>时间复杂度：</strong><code>O(n)</code>，其中 <code>n</code> 是数组长度。遍历数组两次（计算前缀和和统计子数组数量）。</li><li><strong>空间复杂度：</strong><code>O(n)</code>，哈希表最多存储 <code>n + 1</code> 个键值对。</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>暴力枚举简单直接，适合小规模数据（<code>n ≤ 1000</code>）</li><li>前缀和 + 哈希表是更高效的通用解法，时间复杂度 <code>O(n)</code>，能处理较大规模数据（<code>n ≤ 2×10⁴</code>）</li><li>实际应用中优先选择方法二，其线性时间复杂度能有效应对常见场景</li><li>关键点在于理解前缀和定义和索引映射关系：子数组和 = <code>prefix[j + 1] - prefix[i]</code></li></ol><h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><blockquote><p><a href="https://leetcode.cn/problems/subarray-sum-equals-k/description/" title="560. 和为 K 的子数组 | 力扣（LeetCode）">560. 和为 K 的子数组 | 力扣（LeetCode）</a><br><a href="https://leetcode.cn/problems/subarray-sum-equals-k/solutions/1/qian-zhui-he-ha-xi-biao-cong-liang-ci-bi-4mwr/?envType=study-plan-v2&envId=top-100-liked" title="560. 和为 K 的子数组 | 题解 | 灵茶山艾府">560. 和为 K 的子数组 | 题解 | 灵茶山艾府</a></p></blockquote><hr>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;给你一个整数数组 &lt;code&gt;nums&lt;/code&gt; 和一个整数 &lt;code&gt;k&lt;/code&gt; ，请你统计并返回 该数组中和为 &lt;code&gt;k&lt;/code&gt; 的子数组的个数 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;子数组&lt;/strong&gt; 是数组中元素的连续非空序列。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt;&lt;code&gt;nums = [1, 1, 1]&lt;/code&gt;, &lt;code&gt;k = 2&lt;/code&gt;&lt;br&gt;&lt;strong&gt;输出：&lt;/strong&gt;&lt;code&gt;2&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt;&lt;code&gt;nums = [1, 2, 3]&lt;/code&gt;, &lt;code&gt;k = 3&lt;/code&gt;&lt;br&gt;&lt;strong&gt;输出：&lt;/strong&gt;&lt;code&gt;2&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;提示:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= nums.length &amp;lt;= 2 * 10^4&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-1000 &amp;lt;= nums[i] &amp;lt;= 1000&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-10^7 &amp;lt;= k &amp;lt;= 10^7&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://www.cylong.com/categories/LeetCode/"/>
    
    
    <category term="Java" scheme="https://www.cylong.com/tags/Java/"/>
    
    <category term="LeetCode" scheme="https://www.cylong.com/tags/LeetCode/"/>
    
    <category term="学习笔记" scheme="https://www.cylong.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="数组" scheme="https://www.cylong.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="哈希表" scheme="https://www.cylong.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
    <category term="LeetCode简单" scheme="https://www.cylong.com/tags/LeetCode%E7%AE%80%E5%8D%95/"/>
    
    <category term="前缀和" scheme="https://www.cylong.com/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    
  </entry>
  
  <entry>
    <title>区域和检索 - 数组不可变</title>
    <link href="https://www.cylong.com/blog/2025/06/03/range-sum-query-immutable/"/>
    <id>https://www.cylong.com/blog/2025/06/03/range-sum-query-immutable/</id>
    <published>2025-06-03T15:20:55.000Z</published>
    <updated>2025-06-03T15:20:55.000Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个整数数组  <code>nums</code>，处理以下类型的多个查询:</p><p>计算索引 <code>left</code> 和 <code>right</code> （包含 <code>left</code> 和 <code>right</code>）之间的 <code>nums</code> 元素的和 ，其中 <code>left &lt;= right</code>。</p><p>实现 <code>NumArray</code> 类：</p><ul><li><code>NumArray(int[] nums)</code> 使用数组 <code>nums</code> 初始化对象</li><li><code>int sumRange(int i, int j)</code> 返回数组 <code>nums</code> 中索引 <code>left</code> 和 <code>right</code> 之间的元素的总和 ，包含 <code>left</code> 和 <code>right</code> 两点（也就是 <code>nums[left] + nums[left + 1] + ... + nums[right]</code> )</li></ul><p><strong>示例 1:</strong></p><blockquote><p><strong>输入：</strong><br><code>[&quot;NumArray&quot;, &quot;sumRange&quot;, &quot;sumRange&quot;, &quot;sumRange&quot;]</code><br><code>[[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]]</code><br><strong>输出：</strong><br><code>[null, 1, -1, -3]</code><br><strong>解释：</strong><br><code>NumArray numArray = new NumArray([-2, 0, 3, -5, 2, -1]);</code><br><code>numArray.sumRange(0, 2); // return 1 ((-2) + 0 + 3)</code><br><code>numArray.sumRange(2, 5); // return -1 (3 + (-5) + 2 + (-1)) </code><br><code>numArray.sumRange(0, 5); // return -3 ((-2) + 0 + 3 + (-5) + 2 + (-1))</code></p></blockquote><p><strong>提示:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 10^4</code></li><li><code>-10^5 &lt;= nums[i] &lt;= 10^5</code></li><li><code>0 &lt;= i &lt;= j &lt; nums.length</code></li><li>最多调用 <code>10*4</code> 次 <code>sumRange</code> 方法</li></ul><span id="more"></span><h1 id="直接计算"><a href="#直接计算" class="headerlink" title="直接计算"></a>直接计算</h1><p>最简单的思路，每次调用 <code>sumRange()</code> 时，直接遍历 <code>left</code> 到 <code>right</code> 的元素并求和。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumArray</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] nums;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NumArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.nums = nums;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumRange</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left; i &lt;= right; i++) &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li><strong>时间复杂度：</strong><code>O(mn)</code>，其中 <code>m</code> 为查询次数，<code>n</code> 为数组长度。</li><li><strong>空间复杂度：</strong><code>O(1)</code>，不考虑存储输入的数组。</li></ul><h1 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h1><p>前缀和是一种高效处理区间求和问题的预处理技术，其核心思想是通过数学变换将区间求和转化为两个端点的差值计算。下面我们通过数学推导详细解释前缀和的工作原理。</p><h2 id="步骤1：定义前缀和数组"><a href="#步骤1：定义前缀和数组" class="headerlink" title="步骤1：定义前缀和数组"></a>步骤1：定义前缀和数组</h2><p>给定数组 <code>nums[0...n-1]</code>，我们定义前缀和数组 <code>prefix</code>：</p><blockquote><p><code>prefix[0] = 0</code><br><code>prefix[1] = nums[0]</code><br><code>prefix[2] = nums[0] + nums[1]</code><br>…<br><code>prefix[i] = nums[0] + nums[1] + ... + nums[i-1]</code><br>…<br><code>prefix[n] = nums[0] + ... + nums[n-1]</code></p></blockquote><h2 id="步骤2：区间和与前缀和的数学关系"><a href="#步骤2：区间和与前缀和的数学关系" class="headerlink" title="步骤2：区间和与前缀和的数学关系"></a>步骤2：区间和与前缀和的数学关系</h2><p>考虑区间 <code>[left, right]</code> 的和：</p><blockquote><p><code>sum(left, right)</code><br><code>= nums[left] + nums[left+1] + ... + nums[right]</code><br><code>= (nums[0] + ... + nums[left-1] + nums[left] + ... + nums[right]) - (nums[0] + ... + nums[left-1])</code><br><code>= prefix[right+1] - prefix[left]</code></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumArray</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] prefix;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NumArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 多一位存储0位置</span></span><br><span class="line">        prefix = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 递推关系：当前前缀和 = 前一个前缀和 + 当前元素</span></span><br><span class="line">            prefix[i + <span class="number">1</span>] = prefix[i] + nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumRange</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> prefix[right + <span class="number">1</span>] - prefix[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="前缀和的核心优势"><a href="#前缀和的核心优势" class="headerlink" title="前缀和的核心优势"></a>前缀和的核心优势</h2><ol><li><strong>查询高效化：</strong>将 <code>O(n)</code> 的求和操作转化为 <code>O(1)</code> 的差值计算。</li><li><strong>预处理思想：</strong>一次构建多次使用，特别适合查询密集型场景。</li><li><strong>数学简洁性：</strong>通过简单的数组差值实现复杂区间计算。</li></ol><h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li><strong>时间复杂度：</strong><code>O(n)</code>，初始化前缀和数组，其中 <code>n</code> 是数组长度。<code>sumRange</code> 是 <code>O(1)</code>。</li><li><strong>空间复杂度：</strong><code>O(n)</code>，存储前缀和数组。</li></ul><h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><blockquote><p><a href="https://leetcode.cn/problems/range-sum-query-immutable/description/" title="303. 区域和检索 - 数组不可变 | 力扣（LeetCode）">303. 区域和检索 - 数组不可变 | 力扣（LeetCode）</a></p></blockquote><hr>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;给定一个整数数组  &lt;code&gt;nums&lt;/code&gt;，处理以下类型的多个查询:&lt;/p&gt;
&lt;p&gt;计算索引 &lt;code&gt;left&lt;/code&gt; 和 &lt;code&gt;right&lt;/code&gt; （包含 &lt;code&gt;left&lt;/code&gt; 和 &lt;code&gt;right&lt;/code&gt;）之间的 &lt;code&gt;nums&lt;/code&gt; 元素的和 ，其中 &lt;code&gt;left &amp;lt;= right&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;实现 &lt;code&gt;NumArray&lt;/code&gt; 类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;NumArray(int[] nums)&lt;/code&gt; 使用数组 &lt;code&gt;nums&lt;/code&gt; 初始化对象&lt;/li&gt;
&lt;li&gt;&lt;code&gt;int sumRange(int i, int j)&lt;/code&gt; 返回数组 &lt;code&gt;nums&lt;/code&gt; 中索引 &lt;code&gt;left&lt;/code&gt; 和 &lt;code&gt;right&lt;/code&gt; 之间的元素的总和 ，包含 &lt;code&gt;left&lt;/code&gt; 和 &lt;code&gt;right&lt;/code&gt; 两点（也就是 &lt;code&gt;nums[left] + nums[left + 1] + ... + nums[right]&lt;/code&gt; )&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt;&lt;br&gt;&lt;code&gt;[&amp;quot;NumArray&amp;quot;, &amp;quot;sumRange&amp;quot;, &amp;quot;sumRange&amp;quot;, &amp;quot;sumRange&amp;quot;]&lt;/code&gt;&lt;br&gt;&lt;code&gt;[[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]]&lt;/code&gt;&lt;br&gt;&lt;strong&gt;输出：&lt;/strong&gt;&lt;br&gt;&lt;code&gt;[null, 1, -1, -3]&lt;/code&gt;&lt;br&gt;&lt;strong&gt;解释：&lt;/strong&gt;&lt;br&gt;&lt;code&gt;NumArray numArray = new NumArray([-2, 0, 3, -5, 2, -1]);&lt;/code&gt;&lt;br&gt;&lt;code&gt;numArray.sumRange(0, 2); // return 1 ((-2) + 0 + 3)&lt;/code&gt;&lt;br&gt;&lt;code&gt;numArray.sumRange(2, 5); // return -1 (3 + (-5) + 2 + (-1)) &lt;/code&gt;&lt;br&gt;&lt;code&gt;numArray.sumRange(0, 5); // return -3 ((-2) + 0 + 3 + (-5) + 2 + (-1))&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;提示:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= nums.length &amp;lt;= 10^4&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-10^5 &amp;lt;= nums[i] &amp;lt;= 10^5&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0 &amp;lt;= i &amp;lt;= j &amp;lt; nums.length&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;最多调用 &lt;code&gt;10*4&lt;/code&gt; 次 &lt;code&gt;sumRange&lt;/code&gt; 方法&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://www.cylong.com/categories/LeetCode/"/>
    
    
    <category term="Java" scheme="https://www.cylong.com/tags/Java/"/>
    
    <category term="LeetCode" scheme="https://www.cylong.com/tags/LeetCode/"/>
    
    <category term="学习笔记" scheme="https://www.cylong.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="数组" scheme="https://www.cylong.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="LeetCode简单" scheme="https://www.cylong.com/tags/LeetCode%E7%AE%80%E5%8D%95/"/>
    
    <category term="前缀和" scheme="https://www.cylong.com/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    
  </entry>
  
  <entry>
    <title>字母异位词分组</title>
    <link href="https://www.cylong.com/blog/2025/05/30/group-anagrams/"/>
    <id>https://www.cylong.com/blog/2025/05/30/group-anagrams/</id>
    <published>2025-05-29T16:28:11.000Z</published>
    <updated>2025-05-29T16:28:11.000Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给你一个字符串数组，请你将 <strong>字母异位词</strong> 组合在一起。可以按任意顺序返回结果列表。</p><p><strong>字母异位词</strong> 是由重新排列源单词的所有字母得到的一个新单词。</p><p><strong>示例 1:</strong></p><blockquote><p><strong>输入：</strong><code>strs = [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;]</code><br><strong>输出：</strong><code>[[&quot;bat&quot;], [&quot;nat&quot;, &quot;tan&quot;], [&quot;ate&quot;, &quot;eat&quot;, &quot;tea&quot;]]</code></p></blockquote><p><strong>示例 2:</strong></p><blockquote><p><strong>输入：</strong><code>strs = [&quot;&quot;]</code><br><strong>输出：</strong><code>[[&quot;&quot;]]</code></p></blockquote><p><strong>示例 3:</strong></p><blockquote><p><strong>输入：</strong><code>strs = [&quot;a&quot;]</code><br><strong>输出：</strong><code>[[&quot;a&quot;]]</code></p></blockquote><p><strong>提示:</strong></p><ul><li><code>1 &lt;= strs.length &lt;= 104</code></li><li><code>0 &lt;= strs[i].length &lt;= 100</code></li><li><code>strs[i]</code> 仅包含小写字母</li></ul><span id="more"></span><h1 id="排序-哈希表"><a href="#排序-哈希表" class="headerlink" title="排序 + 哈希表"></a>排序 + 哈希表</h1><p>字母异位词指字母相同，但排列不同的字符串。所以对每个字符串排序，将排序后的字符串作为 <code>key</code>，原字符串添加到该 <code>key</code> 对应的列表中。（如 <code>&quot;eat&quot;</code> 和 <code>&quot;tea&quot;</code> 的 <code>key</code> 都为 <code>&quot;aet&quot;</code>）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">groupAnagrams</span><span class="params">(String[] strs)</span> &#123;</span><br><span class="line">    Map&lt;String, List&lt;String&gt;&gt; resultMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String str : strs) &#123;</span><br><span class="line">        <span class="type">char</span>[] chars = str.toCharArray();</span><br><span class="line">        Arrays.sort(chars);</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(chars);</span><br><span class="line">        <span class="keyword">if</span> (!resultMap.containsKey(key)) &#123;</span><br><span class="line">            resultMap.put(key, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        resultMap.get(key).add(str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(resultMap.values());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li><strong>时间复杂度：</strong><code>O(nk logk)</code>，假设有 <code>n</code> 个字符串，每个字符串最大长度为 <code>k</code>。排序每个字符串的时间复杂度为<code>O(k logk)</code>，所以总时间复杂度为<code>O(nk logk)</code>。</li><li><strong>空间复杂度：</strong><code>O(nk)</code>，哈希表存储所有字符串（最坏情况无重复 <code>key</code>）。</li></ul><h1 id="字符计数-哈希表"><a href="#字符计数-哈希表" class="headerlink" title="字符计数 + 哈希表"></a>字符计数 + 哈希表</h1><p>字母异位词指字母相同，但排列不同的字符串，所以，每个字符串里字母的数量是相等的，故可以统计每个字符串中每个字符出现的次数，然后生成一个表示字符频次的字符串作为 <code>key</code>（例如：<code>&quot;a1b2&quot;</code>），然后将原字符串添加到该 <code>key</code> 对应的列表中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">groupAnagrams</span><span class="params">(String[] strs)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] count = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">    Map&lt;String, List&lt;String&gt;&gt; resultMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String str : strs) &#123;</span><br><span class="line">        Arrays.fill(count, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : str.toCharArray()) &#123;</span><br><span class="line">            <span class="comment">// 统计每个字符出现的次数</span></span><br><span class="line">            count[c - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 拼接每个字符出现的次数，作为 Map 的 key</span></span><br><span class="line">            <span class="keyword">if</span> (count[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                sb.append((<span class="type">char</span>) (<span class="string">&#x27;a&#x27;</span> + i));</span><br><span class="line">                sb.append(count[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> sb.toString();</span><br><span class="line">        <span class="keyword">if</span> (!resultMap.containsKey(key)) &#123;</span><br><span class="line">            resultMap.put(key, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        resultMap.get(key).add(str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 入参：[&quot;eatt&quot;, &quot;teat&quot;, &quot;tan&quot;, &quot;atet&quot;, &quot;nat&quot;, &quot;bat&quot;]</span></span><br><span class="line">    <span class="comment">// resultMap 结果为：&#123;a1b1t1=[bat], a1n1t1=[tan, nat], a1e1t2=[eatt, teat, atet]&#125;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(resultMap.values());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li><strong>时间复杂度：</strong><code>O(nk)</code>，哈希表存储所有字符串（最坏情况无重复 key）。</li><li><strong>空间复杂度：</strong><code>O(1)</code>。</li></ul><h1 id="关键结论"><a href="#关键结论" class="headerlink" title="关键结论"></a>关键结论</h1><ul><li><strong>排序 + 哈希表：</strong>代码简洁，但排序开销随字符串变长而增大。</li><li><strong>计数 + 哈希表：</strong>避免排序，通过字符频次编码更高效处理长字符串。</li><li><strong>实际选择：</strong>若字符串平均长度小，选方法一；若长度大，选方法二。</li></ul><p>通过哈希表将字母异位词映射到相同 <code>key</code>，两种方法均能高效解决分组问题！</p><h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><blockquote><p><a href="https://leetcode.cn/problems/group-anagrams/description/" title="49. 字母异位词分组 | 力扣（LeetCode）">49. 字母异位词分组 | 力扣（LeetCode）</a></p></blockquote><hr>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;给你一个字符串数组，请你将 &lt;strong&gt;字母异位词&lt;/strong&gt; 组合在一起。可以按任意顺序返回结果列表。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;字母异位词&lt;/strong&gt; 是由重新排列源单词的所有字母得到的一个新单词。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt;&lt;code&gt;strs = [&amp;quot;eat&amp;quot;, &amp;quot;tea&amp;quot;, &amp;quot;tan&amp;quot;, &amp;quot;ate&amp;quot;, &amp;quot;nat&amp;quot;, &amp;quot;bat&amp;quot;]&lt;/code&gt;&lt;br&gt;&lt;strong&gt;输出：&lt;/strong&gt;&lt;code&gt;[[&amp;quot;bat&amp;quot;], [&amp;quot;nat&amp;quot;, &amp;quot;tan&amp;quot;], [&amp;quot;ate&amp;quot;, &amp;quot;eat&amp;quot;, &amp;quot;tea&amp;quot;]]&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt;&lt;code&gt;strs = [&amp;quot;&amp;quot;]&lt;/code&gt;&lt;br&gt;&lt;strong&gt;输出：&lt;/strong&gt;&lt;code&gt;[[&amp;quot;&amp;quot;]]&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例 3:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt;&lt;code&gt;strs = [&amp;quot;a&amp;quot;]&lt;/code&gt;&lt;br&gt;&lt;strong&gt;输出：&lt;/strong&gt;&lt;code&gt;[[&amp;quot;a&amp;quot;]]&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;提示:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= strs.length &amp;lt;= 104&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0 &amp;lt;= strs[i].length &amp;lt;= 100&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;strs[i]&lt;/code&gt; 仅包含小写字母&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://www.cylong.com/categories/LeetCode/"/>
    
    
    <category term="Java" scheme="https://www.cylong.com/tags/Java/"/>
    
    <category term="LeetCode" scheme="https://www.cylong.com/tags/LeetCode/"/>
    
    <category term="学习笔记" scheme="https://www.cylong.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="数组" scheme="https://www.cylong.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="哈希表" scheme="https://www.cylong.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
    <category term="字符串" scheme="https://www.cylong.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    <category term="排序" scheme="https://www.cylong.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
    <category term="LeetCode中等" scheme="https://www.cylong.com/tags/LeetCode%E4%B8%AD%E7%AD%89/"/>
    
  </entry>
  
  <entry>
    <title>分类求和并作差</title>
    <link href="https://www.cylong.com/blog/2025/05/28/divisible-and-non-divisible-sums-difference/"/>
    <id>https://www.cylong.com/blog/2025/05/28/divisible-and-non-divisible-sums-difference/</id>
    <published>2025-05-27T16:19:46.000Z</published>
    <updated>2025-05-27T16:19:46.000Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给你两个正整数 <code>n</code> 和 <code>m</code> 。现定义两个整数 <code>num1</code> 和 <code>num2</code> ，如下所示：</p><p><code>num1</code>：范围 <code>[1, n]</code> 内所有 无法被 <code>m</code> 整除 的整数之和。<br><code>num2</code>：范围 <code>[1, n]</code> 内所有 能够被 <code>m</code> 整除 的整数之和。</p><p>返回整数 <code>num1 - num2</code> 。</p><p><strong>示例 1:</strong></p><blockquote><p><strong>输入：</strong>n = 10, m = 3<br><strong>输出：</strong>19<br><strong>解释：</strong>在这个示例中：<br>范围 <code>[1, 10]</code> 内无法被 3 整除的整数为 <code>[1, 2, 4, 5, 7, 8, 10]</code> ，num1 = 这些整数之和 = 37 。<br>范围 <code>[1, 10]</code> 内能够被 3 整除的整数为 <code>[3, 6, 9]</code> ，num2 = 这些整数之和 = 18 。<br>返回 37 - 18 = 19 作为答案。</p></blockquote><p><strong>示例 2:</strong></p><blockquote><p><strong>输入：</strong>n = 5, m = 6<br><strong>输出：</strong>15<br><strong>解释：</strong>在这个示例中：<br>范围 <code>[1, 5]</code> 内无法被 6 整除的整数为 <code>[1, 2, 3, 4, 5]</code> ，num1 = 这些整数之和 =  15 。<br>范围 <code>[1, 5]</code> 内能够被 6 整除的整数为 <code>[]</code> ，num2 = 这些整数之和 = 0 。<br>返回 15 - 0 = 15 作为答案。</p></blockquote><p><strong>示例 3:</strong></p><blockquote><p><strong>输入：</strong>n = 5, m = 1<br><strong>输出：</strong>-15<br><strong>解释：</strong>在这个示例中：<br>范围 <code>[1, 5]</code> 内无法被 1 整除的整数为 <code>[]</code> ，num1 = 这些整数之和 = 0 。<br>范围 <code>[1, 5]</code> 内能够被 1 整除的整数为 <code>[1, 2, 3, 4, 5]</code> ，num2 = 这些整数之和 = 15 。<br>返回 0 - 15 = -15 作为答案。</p></blockquote><p><strong>提示:</strong></p><ul><li><code>1 &lt;= n, m &lt;= 1000</code></li></ul><span id="more"></span><h1 id="普通遍历"><a href="#普通遍历" class="headerlink" title="普通遍历"></a>普通遍历</h1><p>最直观方法遍历 <code>1</code> 到 <code>n</code> 的每个数，分别累加能被 <code>m</code> 整除的数的和 <code>sum_div</code> 和不能整除的数的和 <code>sum_non_div</code> ，最后返回 <code>sum_non_div - sum_div</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">differenceOfSums</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum_div</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum_non_div</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i % m == <span class="number">0</span>) &#123;</span><br><span class="line">            sum_div += i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sum_non_div += i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sum_non_div - sum_div;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li><strong>时间复杂度：</strong><code>O(n)</code>，需遍历 <code>1</code> 到 <code>n</code> 的所有数。</li><li><strong>空间复杂度：</strong><code>O(1)</code>，仅使用常数空间。</li></ul><h1 id="数学公式"><a href="#数学公式" class="headerlink" title="数学公式"></a>数学公式</h1><p>利用数学公式直接计算，避免遍历：</p><ol><li>总和：<code>1</code> 到 <code>n</code> 的和为 <code>total = n * (n + 1) / 2</code>。</li><li>整除和：能被 <code>m</code> 整除的数形如 <code>m, 2m, 3m, ..., km</code>（其中 <code>k = n / m</code>），和为 <code>m * (k * (k + 1) / 2)</code>。</li><li>差值：非整除和 - 整除和 = <code>(total - sum_div) - sum_div = total - 2 * sum_div</code>。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">differenceOfSums</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span> &#123;</span><br><span class="line">    <span class="comment">// 计算 1 到 n 的总和</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">total</span> <span class="operator">=</span> (<span class="type">long</span>) n * (n + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 计算可整除数的个数k</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> n / m;</span><br><span class="line">    <span class="comment">// 可整除数的和</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">divisibleSum</span> <span class="operator">=</span> (<span class="type">long</span>) m * k * (k + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 返回差值</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int</span>) (total - <span class="number">2</span> * divisibleSum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li><strong>时间复杂度：</strong><code>O(1)</code>。</li><li><strong>空间复杂度：</strong><code>O(1)</code>。</li></ul><h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><blockquote><p><a href="https://leetcode.cn/problems/divisible-and-non-divisible-sums-difference/description/" title="2894. 分类求和并作差 | 力扣（LeetCode）">2894. 分类求和并作差 | 力扣（LeetCode）</a></p></blockquote><hr>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;给你两个正整数 &lt;code&gt;n&lt;/code&gt; 和 &lt;code&gt;m&lt;/code&gt; 。现定义两个整数 &lt;code&gt;num1&lt;/code&gt; 和 &lt;code&gt;num2&lt;/code&gt; ，如下所示：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;num1&lt;/code&gt;：范围 &lt;code&gt;[1, n]&lt;/code&gt; 内所有 无法被 &lt;code&gt;m&lt;/code&gt; 整除 的整数之和。&lt;br&gt;&lt;code&gt;num2&lt;/code&gt;：范围 &lt;code&gt;[1, n]&lt;/code&gt; 内所有 能够被 &lt;code&gt;m&lt;/code&gt; 整除 的整数之和。&lt;/p&gt;
&lt;p&gt;返回整数 &lt;code&gt;num1 - num2&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt;n = 10, m = 3&lt;br&gt;&lt;strong&gt;输出：&lt;/strong&gt;19&lt;br&gt;&lt;strong&gt;解释：&lt;/strong&gt;在这个示例中：&lt;br&gt;范围 &lt;code&gt;[1, 10]&lt;/code&gt; 内无法被 3 整除的整数为 &lt;code&gt;[1, 2, 4, 5, 7, 8, 10]&lt;/code&gt; ，num1 = 这些整数之和 = 37 。&lt;br&gt;范围 &lt;code&gt;[1, 10]&lt;/code&gt; 内能够被 3 整除的整数为 &lt;code&gt;[3, 6, 9]&lt;/code&gt; ，num2 = 这些整数之和 = 18 。&lt;br&gt;返回 37 - 18 = 19 作为答案。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt;n = 5, m = 6&lt;br&gt;&lt;strong&gt;输出：&lt;/strong&gt;15&lt;br&gt;&lt;strong&gt;解释：&lt;/strong&gt;在这个示例中：&lt;br&gt;范围 &lt;code&gt;[1, 5]&lt;/code&gt; 内无法被 6 整除的整数为 &lt;code&gt;[1, 2, 3, 4, 5]&lt;/code&gt; ，num1 = 这些整数之和 =  15 。&lt;br&gt;范围 &lt;code&gt;[1, 5]&lt;/code&gt; 内能够被 6 整除的整数为 &lt;code&gt;[]&lt;/code&gt; ，num2 = 这些整数之和 = 0 。&lt;br&gt;返回 15 - 0 = 15 作为答案。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例 3:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt;n = 5, m = 1&lt;br&gt;&lt;strong&gt;输出：&lt;/strong&gt;-15&lt;br&gt;&lt;strong&gt;解释：&lt;/strong&gt;在这个示例中：&lt;br&gt;范围 &lt;code&gt;[1, 5]&lt;/code&gt; 内无法被 1 整除的整数为 &lt;code&gt;[]&lt;/code&gt; ，num1 = 这些整数之和 = 0 。&lt;br&gt;范围 &lt;code&gt;[1, 5]&lt;/code&gt; 内能够被 1 整除的整数为 &lt;code&gt;[1, 2, 3, 4, 5]&lt;/code&gt; ，num2 = 这些整数之和 = 15 。&lt;br&gt;返回 0 - 15 = -15 作为答案。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;提示:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= n, m &amp;lt;= 1000&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://www.cylong.com/categories/LeetCode/"/>
    
    
    <category term="Java" scheme="https://www.cylong.com/tags/Java/"/>
    
    <category term="LeetCode" scheme="https://www.cylong.com/tags/LeetCode/"/>
    
    <category term="学习笔记" scheme="https://www.cylong.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="数学公式" scheme="https://www.cylong.com/tags/%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/"/>
    
    <category term="LeetCode简单" scheme="https://www.cylong.com/tags/LeetCode%E7%AE%80%E5%8D%95/"/>
    
  </entry>
  
  <entry>
    <title>连接两字母单词得到的最长回文串</title>
    <link href="https://www.cylong.com/blog/2025/05/25/longest-palindrome-by-concatenating-two-letter-words/"/>
    <id>https://www.cylong.com/blog/2025/05/25/longest-palindrome-by-concatenating-two-letter-words/</id>
    <published>2025-05-25T13:31:32.000Z</published>
    <updated>2025-05-25T13:31:32.000Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给你一个字符串数组 <code>words</code> 。<code>words</code> 中每个元素都是一个包含两个小写英文字母的单词。请你从 <code>words</code> 中选择一些元素并按任意顺序连接它们，并得到一个尽可能长的回文串 。每个元素至多只能使用一次。请你返回你能得到的最长回文串的长度 。如果没办法得到任何一个回文串，请你返回 <code>0</code> 。</p><p><strong>说明:</strong> 回文串指的是从前往后和从后往前读一样的字符串。</p><p><strong>示例 1:</strong></p><blockquote><p><strong>输入：</strong><code>words = [&quot;lc&quot;, &quot;cl&quot;, &quot;gg&quot;]</code><br><strong>输出：</strong>6<br><strong>解释：</strong>一个最长的回文串为 <code>&quot;lc&quot; + &quot;gg&quot; + &quot;cl&quot; = &quot;lcggcl&quot;</code> ，长度为 6 。<code>&quot;clgglc&quot;</code> 是另一个可以得到的最长回文串。</p></blockquote><p><strong>示例 2:</strong></p><blockquote><p><strong>输入：</strong><code>words = [&quot;ab&quot;, &quot;ty&quot;, &quot;yt&quot;, &quot;lc&quot;, &quot;cl&quot;, &quot;ab&quot;]</code><br><strong>输出：</strong>8<br><strong>解释：</strong>最长回文串是 <code>&quot;ty&quot; + &quot;lc&quot; + &quot;cl&quot; + &quot;yt&quot; = &quot;tylcclyt&quot;</code> ，长度为 8 。<code>&quot;lcyttycl&quot;</code> 是另一个可以得到的最长回文串。</p></blockquote><p><strong>示例 3:</strong></p><blockquote><p><strong>输入：</strong><code>words = [&quot;cc&quot;, &quot;ll&quot;, &quot;xx&quot;]</code><br><strong>输出：</strong>2<br><strong>解释：</strong>最长回文串是 <code>&quot;cc&quot;</code> ，长度为 2 。<code>&quot;ll&quot;</code> 是另一个可以得到的最长回文串。<code>&quot;xx&quot;</code> 也是。</p></blockquote><p><strong>提示:</strong></p><ul><li><code>1 &lt;= words.length &lt;= 10^5</code></li><li><code>words[i].length == 2</code></li><li><code>words[i]</code> 仅包含小写英文字母。</li></ul><span id="more"></span><h1 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h1><ol><li>统计单词出现次数：使用哈希表记录每个单词的出现次数。</li><li>处理互为反转的单词对：对于每个单词，检查其反转是否存在。若存在，取两者出现次数的较小值，每对贡献 <code>4</code> 个字符（每个单词长度为 <code>2</code> ）。</li><li>处理对称单词：对于两个字符相同的单词（如 <code>&quot;aa&quot;</code>），可以成对使用（贡献 <code>4</code> 个字符），若有剩余且未使用中间点，可单独作为中间对称点（贡献 <code>2</code> 个字符）。</li><li>避免重复处理：使用集合记录已处理的单词，确保每对单词只处理一次。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestPalindrome</span><span class="params">(String[] words)</span> &#123;</span><br><span class="line">    <span class="comment">// 记录最长回文长度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">maxLen</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 标记是否已使用中间对称点</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">center</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 记录已处理的单词</span></span><br><span class="line">    List&lt;String&gt; processed = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 使用 HashMap 统计每个单词的出现次数</span></span><br><span class="line">    Map&lt;String, Integer&gt; wordCount = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 记录所有 word 的次数</span></span><br><span class="line">    Arrays.stream(words).forEach(word -&gt; wordCount.put(word, wordCount.getOrDefault(word, <span class="number">0</span>) + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (String word : wordCount.keySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (processed.contains(word)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> wordCount.get(word);</span><br><span class="line">        <span class="type">String</span> <span class="variable">reversed</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(word).reverse().toString();</span><br><span class="line">        <span class="comment">// 若单词字符相同（如&quot;aa&quot;），计算可成对使用的次数，剩余次数作为中间对称点。</span></span><br><span class="line">        <span class="keyword">if</span> (word.equals(reversed)) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">pairs</span> <span class="operator">=</span> count / <span class="number">2</span>;</span><br><span class="line">            maxLen += pairs * <span class="number">4</span>;</span><br><span class="line">            <span class="keyword">if</span> (!center &amp;&amp; count % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                maxLen += <span class="number">2</span>;</span><br><span class="line">                center = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            processed.add(word);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 找到反转单词，取较小次数计算贡献，避免重复处理。</span></span><br><span class="line">            <span class="keyword">if</span> (wordCount.containsKey(reversed)) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">reversedCount</span> <span class="operator">=</span> wordCount.get(reversed);</span><br><span class="line">                <span class="type">int</span> <span class="variable">pairs</span> <span class="operator">=</span> Math.min(count, reversedCount);</span><br><span class="line">                maxLen += pairs * <span class="number">4</span>;</span><br><span class="line">                processed.add(word);</span><br><span class="line">                processed.add(reversed);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxLen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li><strong>时间复杂度：</strong><code>O(n)</code>，遍历 <code>words</code> 数组并构建哈希表 <code>wordCount</code>，时间复杂度为 <code>O(n)</code>，遍历哈希表的键集合，假设不同的单词数量为 <code>m</code>，每个单词的处理包括生成反转字符串、哈希表查询等操作。由于每个单词长度为 <code>2</code>，生成反转字符串和哈希表操作均为 <code>O(1)</code>，总时间复杂度为 <code>O(m)</code>。最坏情况下，所有单词均不同（即 <code>m = n</code>），时间复杂度为 <code>O(n)</code>。其中 <code>n</code> 是数组长度。</li><li><strong>空间复杂度：</strong><code>O(n)</code>，<code>wordCount</code> 存储所有单词及其频率，占用 <code>O(m)</code> 空间。<code>processed</code> 集合存储已处理的单词，需要 <code>O(m)</code> 空间。总体空间复杂度：<code>O(m)</code>，即 <code>O(n)</code>（<code>m</code> 最大为 <code>n</code>）。</li></ul><h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><blockquote><p><a href="https://leetcode.cn/problems/longest-palindrome-by-concatenating-two-letter-words/description/" title="2131. 连接两字母单词得到的最长回文串 | 力扣（LeetCode）">2131. 连接两字母单词得到的最长回文串 | 力扣（LeetCode）</a></p></blockquote><hr>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;给你一个字符串数组 &lt;code&gt;words&lt;/code&gt; 。&lt;code&gt;words&lt;/code&gt; 中每个元素都是一个包含两个小写英文字母的单词。请你从 &lt;code&gt;words&lt;/code&gt; 中选择一些元素并按任意顺序连接它们，并得到一个尽可能长的回文串 。每个元素至多只能使用一次。请你返回你能得到的最长回文串的长度 。如果没办法得到任何一个回文串，请你返回 &lt;code&gt;0&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说明:&lt;/strong&gt; 回文串指的是从前往后和从后往前读一样的字符串。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt;&lt;code&gt;words = [&amp;quot;lc&amp;quot;, &amp;quot;cl&amp;quot;, &amp;quot;gg&amp;quot;]&lt;/code&gt;&lt;br&gt;&lt;strong&gt;输出：&lt;/strong&gt;6&lt;br&gt;&lt;strong&gt;解释：&lt;/strong&gt;一个最长的回文串为 &lt;code&gt;&amp;quot;lc&amp;quot; + &amp;quot;gg&amp;quot; + &amp;quot;cl&amp;quot; = &amp;quot;lcggcl&amp;quot;&lt;/code&gt; ，长度为 6 。&lt;code&gt;&amp;quot;clgglc&amp;quot;&lt;/code&gt; 是另一个可以得到的最长回文串。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt;&lt;code&gt;words = [&amp;quot;ab&amp;quot;, &amp;quot;ty&amp;quot;, &amp;quot;yt&amp;quot;, &amp;quot;lc&amp;quot;, &amp;quot;cl&amp;quot;, &amp;quot;ab&amp;quot;]&lt;/code&gt;&lt;br&gt;&lt;strong&gt;输出：&lt;/strong&gt;8&lt;br&gt;&lt;strong&gt;解释：&lt;/strong&gt;最长回文串是 &lt;code&gt;&amp;quot;ty&amp;quot; + &amp;quot;lc&amp;quot; + &amp;quot;cl&amp;quot; + &amp;quot;yt&amp;quot; = &amp;quot;tylcclyt&amp;quot;&lt;/code&gt; ，长度为 8 。&lt;code&gt;&amp;quot;lcyttycl&amp;quot;&lt;/code&gt; 是另一个可以得到的最长回文串。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例 3:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt;&lt;code&gt;words = [&amp;quot;cc&amp;quot;, &amp;quot;ll&amp;quot;, &amp;quot;xx&amp;quot;]&lt;/code&gt;&lt;br&gt;&lt;strong&gt;输出：&lt;/strong&gt;2&lt;br&gt;&lt;strong&gt;解释：&lt;/strong&gt;最长回文串是 &lt;code&gt;&amp;quot;cc&amp;quot;&lt;/code&gt; ，长度为 2 。&lt;code&gt;&amp;quot;ll&amp;quot;&lt;/code&gt; 是另一个可以得到的最长回文串。&lt;code&gt;&amp;quot;xx&amp;quot;&lt;/code&gt; 也是。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;提示:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= words.length &amp;lt;= 10^5&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;words[i].length == 2&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;words[i]&lt;/code&gt; 仅包含小写英文字母。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://www.cylong.com/categories/LeetCode/"/>
    
    
    <category term="Java" scheme="https://www.cylong.com/tags/Java/"/>
    
    <category term="LeetCode" scheme="https://www.cylong.com/tags/LeetCode/"/>
    
    <category term="学习笔记" scheme="https://www.cylong.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="贪心算法" scheme="https://www.cylong.com/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
    <category term="LeetCode中等" scheme="https://www.cylong.com/tags/LeetCode%E4%B8%AD%E7%AD%89/"/>
    
  </entry>
  
  <entry>
    <title>最长回文子串</title>
    <link href="https://www.cylong.com/blog/2025/05/24/longest-palindromic-substring/"/>
    <id>https://www.cylong.com/blog/2025/05/24/longest-palindromic-substring/</id>
    <published>2025-05-24T04:02:04.000Z</published>
    <updated>2025-05-24T04:02:04.000Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的 <strong>回文子串</strong>。</p><p><strong>说明:</strong></p><ul><li>如果字符串向前和向后读都相同，则它满足回文性。</li><li>子字符串是字符串中连续的非空字符序列。</li></ul><p><strong>示例 1:</strong></p><blockquote><p><strong>输入：</strong><code>s = &quot;babad&quot;</code><br><strong>输出：</strong><code>&quot;bab&quot;</code><br><strong>解释：</strong><code>&quot;aba&quot;</code> 同样是符合题意的答案。</p></blockquote><p><strong>示例 2:</strong></p><blockquote><p><strong>输入：</strong><code>s = &quot;cbbd&quot;</code><br><strong>输出：</strong><code>&quot;bb&quot;</code></p></blockquote><p><strong>提示:</strong></p><ul><li><code>1 &lt;= s.length &lt;= 1000</code></li><li><code>s</code> 仅由数字和英文字母组成</li></ul><span id="more"></span><h1 id="暴力法（不推荐）"><a href="#暴力法（不推荐）" class="headerlink" title="暴力法（不推荐）"></a>暴力法（不推荐）</h1><p>枚举所有子串，检查是否为回文，记录最长的一个。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">longestPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">null</span> || s.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxLen</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; s.length(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (longestPalindrome(s, i, j) &amp;&amp; (j - i + <span class="number">1</span> &gt; maxLen)) &#123;</span><br><span class="line">                maxLen = j - i + <span class="number">1</span>;</span><br><span class="line">                start = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.substring(start, start + maxLen);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">longestPalindrome</span><span class="params">(String s, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(start++) != s.charAt(end--)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li><strong>时间复杂度：</strong><code>O(n³)</code>，共有 <code>O(n²)</code> 个子串（两层循环：<code>i</code> 从 <code>0</code> 到 <code>n-1</code>，<code>j</code> 从 <code>i</code> 到 <code>n-1</code>）。每个子串检查是否为回文需要 <code>O(n)</code> 时间（如长度为 <code>k</code> 的子串需比较 <code>k/2</code> 次）。<br>总时间 = <code>O(n²) × O(n) = O(n³)</code>。</li><li><strong>空间复杂度：</strong><code>O(n)</code>，仅需常数空间存储临时变量（如 <code>maxLen</code>, <code>start</code>）。</li></ul><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p>利用二维数组 <code>dp[i][j]</code> 记录子串 <code>s[i...j]</code> 是否为回文，逐步扩展长度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">longestPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">null</span> || s.length() &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.length();</span><br><span class="line">    <span class="type">boolean</span>[][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[len][len];</span><br><span class="line">    <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxLen</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 长度为1的子串全都是回文串</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        dp[i][i] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断长度为2的子串是否是回文串</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i) == s.charAt(i + <span class="number">1</span>)) &#123;</span><br><span class="line">            dp[i][i + <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">            start = i;</span><br><span class="line">            maxLen = <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断长度为3及更长的子串是否是回文串</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">3</span>; l &lt;= len; l++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len - l + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + l - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == s.charAt(j) &amp;&amp; dp[i + <span class="number">1</span>][j - <span class="number">1</span>]) &#123;</span><br><span class="line">                dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                start = i;</span><br><span class="line">                maxLen = l;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> s.substring(start, start + maxLen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li><strong>时间复杂度：</strong><code>O(n²)</code>，外层循环遍历子串长度 <code>l</code>（从 <code>3</code> 到 <code>n</code>），内层循环遍历起始点 <code>i</code>，总时间 = <code>O(n²)</code>。</li><li><strong>空间复杂度：</strong><code>O(n²)</code>，需一个二维数组 <code>dp[n][n]</code> 存储所有子串的状态。</li></ul><h1 id="中心扩展法"><a href="#中心扩展法" class="headerlink" title="中心扩展法"></a>中心扩展法</h1><p>以每个字符或每两个字符为中心，向两侧扩展寻找最长回文。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">longestPalindrome1</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">null</span> || s.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="comment">// 奇数长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len1</span> <span class="operator">=</span> expand(s, i, i);</span><br><span class="line">        <span class="comment">// 偶数长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len2</span> <span class="operator">=</span> expand(s, i, i + <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> Math.max(len1, len2);</span><br><span class="line">        <span class="keyword">if</span> (len &gt; end - start) &#123;</span><br><span class="line">            start = i - (len - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            end = i + len / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.substring(start, end + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">expand</span><span class="params">(String s, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; right &lt; s.length() &amp;&amp; s.charAt(left) == s.charAt(right)) &#123;</span><br><span class="line">        left--;</span><br><span class="line">        right++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> right - left - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li><strong>时间复杂度：</strong><code>O(n²)</code>，共有 <code>2n-1</code> 个中心（每个字符作为奇中心，每两个字符之间作为偶中心），每个中心最多扩展 <code>O(n)</code> 次（如全相同字符时，扩展到边界）。<br>总时间 = <code>O(2n) × O(n) = O(n²)</code>。</li><li><strong>空间复杂度：</strong><code>O(1)</code>，仅需常数空间记录扩展的左右指针和最长回文的起止点。</li></ul><h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><blockquote><p><a href="https://leetcode.cn/problems/longest-palindromic-substring/" title="5. 最长回文子串 | 力扣（LeetCode）">5. 最长回文子串 | 力扣（LeetCode）</a></p></blockquote><hr>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;给你一个字符串 &lt;code&gt;s&lt;/code&gt;，找到 &lt;code&gt;s&lt;/code&gt; 中最长的 &lt;strong&gt;回文子串&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说明:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果字符串向前和向后读都相同，则它满足回文性。&lt;/li&gt;
&lt;li&gt;子字符串是字符串中连续的非空字符序列。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt;&lt;code&gt;s = &amp;quot;babad&amp;quot;&lt;/code&gt;&lt;br&gt;&lt;strong&gt;输出：&lt;/strong&gt;&lt;code&gt;&amp;quot;bab&amp;quot;&lt;/code&gt;&lt;br&gt;&lt;strong&gt;解释：&lt;/strong&gt;&lt;code&gt;&amp;quot;aba&amp;quot;&lt;/code&gt; 同样是符合题意的答案。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt;&lt;code&gt;s = &amp;quot;cbbd&amp;quot;&lt;/code&gt;&lt;br&gt;&lt;strong&gt;输出：&lt;/strong&gt;&lt;code&gt;&amp;quot;bb&amp;quot;&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;提示:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= s.length &amp;lt;= 1000&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;s&lt;/code&gt; 仅由数字和英文字母组成&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://www.cylong.com/categories/LeetCode/"/>
    
    
    <category term="Java" scheme="https://www.cylong.com/tags/Java/"/>
    
    <category term="LeetCode" scheme="https://www.cylong.com/tags/LeetCode/"/>
    
    <category term="学习笔记" scheme="https://www.cylong.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="字符串" scheme="https://www.cylong.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    <category term="动态规划" scheme="https://www.cylong.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="LeetCode中等" scheme="https://www.cylong.com/tags/LeetCode%E4%B8%AD%E7%AD%89/"/>
    
  </entry>
  
  <entry>
    <title>找到字符串中所有字母异位词</title>
    <link href="https://www.cylong.com/blog/2025/03/02/find-all-anagrams-in-a-string/"/>
    <id>https://www.cylong.com/blog/2025/03/02/find-all-anagrams-in-a-string/</id>
    <published>2025-03-02T15:00:44.000Z</published>
    <updated>2025-03-02T15:00:44.000Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定两个字符串 <code>s</code> 和 <code>p</code>，找到 <code>s</code> 中所有 <code>p</code> 的 <strong>异位词</strong> 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。</p><p><strong>字母异位词</strong> 是通过重新排列不同单词或短语的字母而形成的单词或短语，并使用所有原字母一次。</p><p><strong>示例 1:</strong></p><blockquote><p><strong>输入：</strong><code>s = &quot;cbaebabacd&quot;</code>, <code>p = &quot;abc&quot;</code><br><strong>输出：</strong><code>[0, 6]</code><br><strong>解释:</strong><br>起始索引等于 <code>0</code> 的子串是 <code>&quot;cba&quot;</code>, 它是 <code>&quot;abc&quot;</code> 的异位词。<br>起始索引等于 <code>6</code> 的子串是 <code>&quot;bac&quot;</code>, 它是 <code>&quot;abc&quot;</code> 的异位词。</p></blockquote><p><strong>示例 2:</strong></p><blockquote><p><strong>输入：</strong><code>s = &quot;abab&quot;</code>, <code>p = &quot;ab&quot;</code><br><strong>输出：</strong><code>[0, 1, 2]</code><br><strong>解释:</strong><br>起始索引等于 <code>0</code> 的子串是 <code>&quot;ab&quot;</code>, 它是 <code>&quot;ab&quot;</code> 的异位词。<br>起始索引等于 <code>1</code> 的子串是 <code>&quot;ba&quot;</code>, 它是 <code>&quot;ab&quot;</code> 的异位词。<br>起始索引等于 <code>2</code> 的子串是 <code>&quot;ab&quot;</code>, 它是 <code>&quot;ab&quot;</code> 的异位词。</p></blockquote><p><strong>提示:</strong></p><ul><li><code>1 &lt;= s.length</code>, <code>p.length &lt;= 3 * 10^4</code></li><li><code>s</code> 和 <code>p</code> 仅包含小写字母</li></ul><span id="more"></span><h1 id="固定窗口滑动-计数数组"><a href="#固定窗口滑动-计数数组" class="headerlink" title="固定窗口滑动 + 计数数组"></a>固定窗口滑动 + 计数数组</h1><ol><li><strong>初始化处理：</strong></li></ol><ul><li>若 <code>s</code> 长度小于 <code>p</code>，直接返回空列表。</li><li>创建两个长度为 <code>26</code> 的数组 <code>pCount</code> 和 <code>sCount</code>，分别统计 <code>p</code> 的字符频次和 <code>s</code> 中前 <code>p.length()</code> 个字符的频次。</li></ul><ol start="2"><li><strong>首次匹配检查：</strong></li></ol><ul><li>比较 <code>pCount</code> 和 <code>sCount</code>，若相等说明起始索引 <code>0</code> 是异位词，加入结果列表。</li></ul><ol start="3"><li><strong>滑动窗口：</strong></li></ol><ul><li>窗口长度固定为 <code>p.length()</code>，每次右移一位：<ul><li>移除窗口最左侧字符（对应频次减 <code>1</code>）。</li><li>加入窗口右侧新字符（对应频次加 <code>1</code>）。</li></ul></li><li>每次窗口移动后，比较 <code>pCount</code> 和 <code>sCount</code>，若相等则记录当前窗口起始索引（<code>i + 1</code>）。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">findAnagrams</span><span class="params">(String s, String p)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">null</span> || p == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">sLen</span> <span class="operator">=</span> s.length();</span><br><span class="line">    <span class="type">int</span> <span class="variable">pLen</span> <span class="operator">=</span> p.length();</span><br><span class="line">    <span class="keyword">if</span> (sLen &lt; pLen) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 统计 p 和 s 的前 pLen 个字符出现的次数，如果相等，则说明是异位词</span></span><br><span class="line">    <span class="type">int</span>[] pCount = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="type">int</span>[] sCount = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; pLen; i++) &#123;</span><br><span class="line">        pCount[p.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        sCount[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;Integer&gt; anagrams = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (Arrays.equals(pCount, sCount)) &#123;</span><br><span class="line">        anagrams.add(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定长滑动窗口，每次移动一个字符，判断是否是异位词</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length() - p.length(); i++) &#123;</span><br><span class="line">        sCount[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">        sCount[s.charAt(i + p.length()) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        <span class="keyword">if</span> (Arrays.equals(pCount, sCount)) &#123;</span><br><span class="line">            anagrams.add(i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> anagrams;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li><strong>时间复杂度：</strong><code>O(26n)</code>，其中 <code>n</code> 是 <code>s</code> 的长度。因为每次窗口移动后，我们都要比较两个长度为 <code>26</code> 的数组（<code>Arrays.equals</code> 内部会循环 <code>26</code> 次）。</li><li><strong>空间复杂度：</strong><code>O(1)</code>，固定使用两个长度为 <code>26</code> 的数组（常数空间）。</li></ul><h1 id="不固定窗口滑动-计数数组"><a href="#不固定窗口滑动-计数数组" class="headerlink" title="不固定窗口滑动 + 计数数组"></a>不固定窗口滑动 + 计数数组</h1><p>以下参考大佬的解法：<a href="https://leetcode.cn/problems/find-all-anagrams-in-a-string/solutions/1/liang-chong-fang-fa-ding-chang-hua-chuan-14pd/" title="438. 找到字符串中所有字母异位词 | 题解 | 灵茶山艾府">438. 找到字符串中所有字母异位词 | 题解 | 灵茶山艾府</a></p><ol><li><strong>频次数组预处理：</strong></li></ol><ul><li>统计 <code>p</code> 的字符频次到数组 <code>pCount</code>。</li></ul><ol start="2"><li><strong>双指针滑动窗口：</strong></li></ol><ul><li>使用双指针 <code>left</code> 和 <code>right</code>，<code>right</code> 向右移动，将遇到的字符在 <code>pCount</code> 中减 <code>1</code>（相当于进入窗口）。</li><li>如果某个字符在 <code>pCount</code> 中的值小于 <code>0</code>，说明当前窗口中这个字符的数量超过了 <code>p</code> 中该字符的数量，或者 <code>p</code> 中根本没有这个字符。那么就需要移动 <code>left</code> 指针，将 <code>left</code> 指向的字符在 <code>pCount</code> 中加 <code>1</code>（相当于移出窗口），直到 <code>pCount[c]</code> 不再小于 <code>0</code>（即调整到当前字符数量正常）。</li><li>当窗口长度（<code>right - left + 1</code>）等于 <code>p</code> 的长度时，说明我们找到了一个异位词子串，将 <code>left</code> 加入结果列表。</li></ul><p><strong>注意：</strong>这种方法中，<code>pCount</code> 数组被复用，我们通过加减操作来维护窗口内字符的计数。当窗口长度等于 <code>p</code> 的长度时，由于我们保证了窗口内每个字符的出现次数都不超过 <code>p</code> 中的出现次数（通过 <code>while</code> 循环调整），并且窗口长度恰好等于 <code>p</code> 的长度，那么窗口内的字符串必然是 <code>p</code> 的一个异位词。因为如果窗口内某个字符的出现次数大于 <code>p</code> 中的出现次数，我们会通过 <code>left</code> 右移来减少它，直到它等于 <code>p</code> 中的出现次数（即不再为负）。而当窗口长度等于 <code>p</code> 的长度时，每个字符的出现次数恰好等于 <code>p</code> 中的出现次数（因为如果少了，那么 <code>pCount</code> 中对应的值应该是正数，但我们的操作中，进入窗口减 <code>1</code>，移出窗口加 <code>1</code>，并且我们保证了没有负值，所以每个字符都不多不少）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">findAnagrams</span><span class="params">(String s, String p)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; anagrams = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 统计 p 的每种字母的出现次数</span></span><br><span class="line">    <span class="type">int</span>[] pCount = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : p.toCharArray()) &#123;</span><br><span class="line">        pCount[c - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>; right &lt; s.length(); right++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(right) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="comment">// 右端点字母进入窗口</span></span><br><span class="line">        pCount[c]--;</span><br><span class="line">        <span class="comment">// 字母 c 太多了，left右移，直到窗口中字母 c 的出现次数为 0</span></span><br><span class="line">        <span class="keyword">while</span> (pCount[c] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            pCount[s.charAt(left) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// s&#x27; 和 p 的每种字母的出现次数都相同</span></span><br><span class="line">        <span class="keyword">if</span> (right - left + <span class="number">1</span> == p.length()) &#123;</span><br><span class="line">            <span class="comment">// s&#x27; 左端点下标加入答案</span></span><br><span class="line">            anagrams.add(left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> anagrams;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li><strong>时间复杂度：</strong><code>O(m + n)</code>，其中 <code>m</code> 是 <code>s</code> 的长度，<code>n</code> 是 <code>p</code> 的长度。虽然写了个二重循环，但是内层循环中对 <code>left</code> 加一的总执行次数不会超过 <code>m</code> 次，所以滑窗的时间复杂度为 <code>O(m)</code>。</li><li><strong>空间复杂度：</strong><code>O(1)</code>，使用固定大小的数组（ <code>26</code> 个整数）。</li></ul><h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><blockquote><p><a href="https://leetcode.cn/problems/find-all-anagrams-in-a-string/description/" title="438. 找到字符串中所有字母异位词 | 力扣（LeetCode）">438. 找到字符串中所有字母异位词 | 力扣（LeetCode）</a></p></blockquote><hr>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;给定两个字符串 &lt;code&gt;s&lt;/code&gt; 和 &lt;code&gt;p&lt;/code&gt;，找到 &lt;code&gt;s&lt;/code&gt; 中所有 &lt;code&gt;p&lt;/code&gt; 的 &lt;strong&gt;异位词&lt;/strong&gt; 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;字母异位词&lt;/strong&gt; 是通过重新排列不同单词或短语的字母而形成的单词或短语，并使用所有原字母一次。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt;&lt;code&gt;s = &amp;quot;cbaebabacd&amp;quot;&lt;/code&gt;, &lt;code&gt;p = &amp;quot;abc&amp;quot;&lt;/code&gt;&lt;br&gt;&lt;strong&gt;输出：&lt;/strong&gt;&lt;code&gt;[0, 6]&lt;/code&gt;&lt;br&gt;&lt;strong&gt;解释:&lt;/strong&gt;&lt;br&gt;起始索引等于 &lt;code&gt;0&lt;/code&gt; 的子串是 &lt;code&gt;&amp;quot;cba&amp;quot;&lt;/code&gt;, 它是 &lt;code&gt;&amp;quot;abc&amp;quot;&lt;/code&gt; 的异位词。&lt;br&gt;起始索引等于 &lt;code&gt;6&lt;/code&gt; 的子串是 &lt;code&gt;&amp;quot;bac&amp;quot;&lt;/code&gt;, 它是 &lt;code&gt;&amp;quot;abc&amp;quot;&lt;/code&gt; 的异位词。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt;&lt;code&gt;s = &amp;quot;abab&amp;quot;&lt;/code&gt;, &lt;code&gt;p = &amp;quot;ab&amp;quot;&lt;/code&gt;&lt;br&gt;&lt;strong&gt;输出：&lt;/strong&gt;&lt;code&gt;[0, 1, 2]&lt;/code&gt;&lt;br&gt;&lt;strong&gt;解释:&lt;/strong&gt;&lt;br&gt;起始索引等于 &lt;code&gt;0&lt;/code&gt; 的子串是 &lt;code&gt;&amp;quot;ab&amp;quot;&lt;/code&gt;, 它是 &lt;code&gt;&amp;quot;ab&amp;quot;&lt;/code&gt; 的异位词。&lt;br&gt;起始索引等于 &lt;code&gt;1&lt;/code&gt; 的子串是 &lt;code&gt;&amp;quot;ba&amp;quot;&lt;/code&gt;, 它是 &lt;code&gt;&amp;quot;ab&amp;quot;&lt;/code&gt; 的异位词。&lt;br&gt;起始索引等于 &lt;code&gt;2&lt;/code&gt; 的子串是 &lt;code&gt;&amp;quot;ab&amp;quot;&lt;/code&gt;, 它是 &lt;code&gt;&amp;quot;ab&amp;quot;&lt;/code&gt; 的异位词。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;提示:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= s.length&lt;/code&gt;, &lt;code&gt;p.length &amp;lt;= 3 * 10^4&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;s&lt;/code&gt; 和 &lt;code&gt;p&lt;/code&gt; 仅包含小写字母&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://www.cylong.com/categories/LeetCode/"/>
    
    
    <category term="Java" scheme="https://www.cylong.com/tags/Java/"/>
    
    <category term="LeetCode" scheme="https://www.cylong.com/tags/LeetCode/"/>
    
    <category term="学习笔记" scheme="https://www.cylong.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="哈希表" scheme="https://www.cylong.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
    <category term="字符串" scheme="https://www.cylong.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    <category term="滑动窗口" scheme="https://www.cylong.com/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
    <category term="LeetCode中等" scheme="https://www.cylong.com/tags/LeetCode%E4%B8%AD%E7%AD%89/"/>
    
  </entry>
  
  <entry>
    <title>移动零</title>
    <link href="https://www.cylong.com/blog/2025/03/01/move-zeroes/"/>
    <id>https://www.cylong.com/blog/2025/03/01/move-zeroes/</id>
    <published>2025-03-01T13:59:48.000Z</published>
    <updated>2025-03-01T13:59:48.000Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p><p><strong>请注意，</strong>必须在不复制数组的情况下原地对数组进行操作。</p><p><strong>示例 1:</strong></p><blockquote><p><strong>输入：</strong><code>nums = [0, 1, 0, 3, 12]</code><br><strong>输出：</strong><code>[1, 3, 12, 0, 0]</code></p></blockquote><p><strong>示例 2:</strong></p><blockquote><p><strong>输入：</strong><code>nums = [0]</code><br><strong>输出：</strong><code>[0]</code></p></blockquote><p><strong>提示:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 10^4</code></li><li><code>-2^31 &lt;= nums[i] &lt;= 2^31 - 1</code></li></ul><span id="more"></span><h1 id="双指针（交换法）"><a href="#双指针（交换法）" class="headerlink" title="双指针（交换法）"></a>双指针（交换法）</h1><p>使用两个指针，<code>left</code> 和 <code>right</code>，<code>right</code> 指针用于遍历数组，<code>left</code> 指针用于指向当前已经处理好的序列的尾部（即非零序列的末尾，也就是下一个非零元素要放置的位置）。当 <code>right</code> 指针遇到非零元素时，就将其与 <code>left</code> 指针指向的元素交换，然后 <code>left</code> 指针右移。这样，非零元素被逐渐交换到前面，而 <code>0</code> 被交换到后面。</p><p><strong>注意：</strong>交换后，<code>left</code> 指向的位置可能是 <code>0</code>（如果之前 <code>left</code> 指向的是 <code>0</code>）或者非零（如果 <code>left</code> 和 <code>right</code> 相同，即自己交换自己，此时不会改变），但无论如何，<code>left</code> 指针的左侧都是非零元素，并且保持了原有顺序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">moveZeroes</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>; right &lt; nums.length; right++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[right] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 避免不必要的自交换</span></span><br><span class="line">            <span class="keyword">if</span> (left != right) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[left];</span><br><span class="line">                nums[left] = nums[right];</span><br><span class="line">                nums[right] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 数组变化过程</span></span><br><span class="line">    <span class="comment">// 输入：[0, 1, 0, 3, 12]</span></span><br><span class="line">    <span class="comment">// [0, 1, 0, 3, 12]</span></span><br><span class="line">    <span class="comment">// [1, 0, 0, 3, 12]</span></span><br><span class="line">    <span class="comment">// [1, 0, 0, 3, 12]</span></span><br><span class="line">    <span class="comment">// [1, 3, 0, 0, 12]</span></span><br><span class="line">    <span class="comment">// [1, 3, 12, 0, 0]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行过程（以 <code>[0, 1, 0, 3, 12]</code> 为例）<br><code>[0, 1, 0, 3, 12]</code> - <code>right=0: 0</code> → 跳过<br><code>[1, 0, 0, 3, 12]</code> - <code>right=1: 1</code> → 与 <code>left(0)</code> 交换<br><code>[1, 0, 0, 3, 12]</code> - <code>right=2: 0</code> → 跳过<br><code>[1, 3, 0, 0, 12]</code> - <code>right=3: 3</code> → 与 <code>left(1)</code> 交换<br><code>[1, 3, 12, 0, 0]</code> - <code>right=4: 12</code> → 与 <code>left(2)</code> 交换</p><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li><strong>时间复杂度：</strong><code>O(n)</code>，只需一次遍历数组。</li><li><strong>空间复杂度：</strong><code>O(1)</code>，原地操作，仅使用常数空间。</li></ul><h1 id="双指针（覆盖法）"><a href="#双指针（覆盖法）" class="headerlink" title="双指针（覆盖法）"></a>双指针（覆盖法）</h1><p>使用一个指针 <code>cur</code>，表示当前非零元素应该存放的位置。遍历数组，当遇到非零元素时，将其复制到 <code>cur</code> 位置，然后 <code>cur</code> 指针右移。遍历完成后，所有非零元素都被按顺序移动到了数组的前部，然后将 <code>cur</code> 之后的元素全部置为 <code>0</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">moveZeroes</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 第一阶段：移动非零元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] != <span class="number">0</span>) &#123;</span><br><span class="line">            nums[cur++] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 第二阶段：填充零</span></span><br><span class="line">    <span class="keyword">while</span> (cur &lt; nums.length) &#123;</span><br><span class="line">        nums[cur++] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 数组变化过程</span></span><br><span class="line">    <span class="comment">// 输入：[0, 1, 0, 3, 12]</span></span><br><span class="line">    <span class="comment">// [0, 1, 0, 3, 12]</span></span><br><span class="line">    <span class="comment">// [1, 0, 0, 3, 12]</span></span><br><span class="line">    <span class="comment">// [1, 0, 0, 3, 12]</span></span><br><span class="line">    <span class="comment">// [1, 3, 0, 0, 12]</span></span><br><span class="line">    <span class="comment">// [1, 3, 12, 0, 0]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行过程（以 <code>[0, 1, 0, 3, 12]</code> 为例）</p><p><strong>第一阶段：</strong></p><ul><li><code>i=0: 0</code> → 跳过</li><li><code>i=1: 1</code> → <code>nums[0]=1</code> (<code>cur=1</code>)</li><li><code>i=2: 0</code> → 跳过</li><li><code>i=3: 3</code> → <code>nums[1]=3</code> (<code>cur=2</code>)</li><li><code>i=4: 12</code> → <code>nums[2]=12</code> (<code>cur=3</code>)</li></ul><p><strong>第二阶段：</strong></p><ul><li>填充 <code>nums[3]=0</code>, <code>nums[4]=0</code></li><li>结果: <code>[1, 3, 12, 0, 0]</code></li></ul><h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li><strong>时间复杂度：</strong><code>O(n)</code>，两次独立遍历数组。</li><li><strong>空间复杂度：</strong><code>O(1)</code>，原地操作，仅使用常数空间。</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>两种方法都有效地解决了移动零的问题：</p><ol><li>交换法更高效，单次遍历完成操作，代码更简洁</li><li>覆盖法写操作更少，但需要两次遍历</li></ol><p>在实际应用中，交换法通常是更优选择，因为它只需要一次遍历且代码更简洁。理解这两种双指针策略有助于解决类似的数组重排问题，如移除指定元素、删除排序数组中的重复项等。</p><h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><blockquote><p><a href="https://leetcode.cn/problems/move-zeroes/description/" title="283. 移动零 | 力扣（LeetCode）">283. 移动零 | 力扣（LeetCode）</a></p></blockquote><hr>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;给定一个数组 &lt;code&gt;nums&lt;/code&gt;，编写一个函数将所有 &lt;code&gt;0&lt;/code&gt; 移动到数组的末尾，同时保持非零元素的相对顺序。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;请注意，&lt;/strong&gt;必须在不复制数组的情况下原地对数组进行操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt;&lt;code&gt;nums = [0, 1, 0, 3, 12]&lt;/code&gt;&lt;br&gt;&lt;strong&gt;输出：&lt;/strong&gt;&lt;code&gt;[1, 3, 12, 0, 0]&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt;&lt;code&gt;nums = [0]&lt;/code&gt;&lt;br&gt;&lt;strong&gt;输出：&lt;/strong&gt;&lt;code&gt;[0]&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;提示:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= nums.length &amp;lt;= 10^4&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-2^31 &amp;lt;= nums[i] &amp;lt;= 2^31 - 1&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://www.cylong.com/categories/LeetCode/"/>
    
    
    <category term="Java" scheme="https://www.cylong.com/tags/Java/"/>
    
    <category term="LeetCode" scheme="https://www.cylong.com/tags/LeetCode/"/>
    
    <category term="学习笔记" scheme="https://www.cylong.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="数组" scheme="https://www.cylong.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="双指针" scheme="https://www.cylong.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
    <category term="LeetCode简单" scheme="https://www.cylong.com/tags/LeetCode%E7%AE%80%E5%8D%95/"/>
    
  </entry>
  
  <entry>
    <title>连接两棵树后最大目标节点数目 Ⅰ</title>
    <link href="https://www.cylong.com/blog/2025/02/28/maximize-the-number-of-target-nodes-after-connecting-trees-i/"/>
    <id>https://www.cylong.com/blog/2025/02/28/maximize-the-number-of-target-nodes-after-connecting-trees-i/</id>
    <published>2025-02-28T14:52:11.000Z</published>
    <updated>2025-02-28T14:52:11.000Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>有两棵 <strong>无向树</strong>，分别有 <code>n</code> 和 <code>m</code> 个树节点。两棵树中的节点编号分别为 <code>[0, n - 1]</code> 和 <code>[0, m - 1]</code> 中的整数。</p><p>给你两个二维整数 <code>edges1</code> 和 <code>edges2</code> ，长度分别为 <code>n - 1</code> 和 <code>m - 1</code> ，其中 <code>edges1[i] = [ai, bi]</code> 表示第一棵树中节点 <code>ai</code> 和 <code>bi</code> 之间有一条边，<code>edges2[i] = [ui, vi]</code> 表示第二棵树中节点 <code>ui</code> 和 <code>vi</code> 之间有一条边。同时给你一个整数 <code>k</code> 。如果节点 <code>u</code> 和节点 <code>v</code> 之间路径的边数小于等于 <code>k</code> ，那么我们称节点 <code>u</code> 是节点 <code>v</code> 的 <strong>目标节点</strong> 。一个节点一定是它自己的 <strong>目标节点</strong> 。</p><p>请你返回一个长度为 <code>n</code> 的整数数组 <code>answer</code> ，<code>answer[i]</code> 表示将第一棵树中的一个节点与第二棵树中的一个节点连接一条边后，第一棵树中节点 <code>i</code> 的目标节点数目的最大值 。</p><p><strong>注意：</strong>每个查询相互独立。意味着进行下一次查询之前，你需要先把刚添加的边给删掉。</p><p><strong>示例 1:</strong></p><blockquote><p><strong>输入：</strong><code>edges1 = [[0, 1], [0, 2], [2, 3], [2, 4]], edges2 = [[0, 1], [0, 2], [0, 3], [2, 7], [1, 4], [4, 5], [4, 6]]</code>, <code>k = 2</code><br><strong>输出：</strong><code>[9, 7, 9, 8, 8]</code><br><strong>解释：</strong></p><ul><li>对于 <code>i = 0</code> ，连接第一棵树中的节点 0 和第二棵树中的节点 0 。</li><li>对于 <code>i = 1</code> ，连接第一棵树中的节点 1 和第二棵树中的节点 0 。</li><li>对于 <code>i = 2</code> ，连接第一棵树中的节点 2 和第二棵树中的节点 4 。</li><li>对于 <code>i = 3</code> ，连接第一棵树中的节点 3 和第二棵树中的节点 4 。</li><li>对于 <code>i = 4</code> ，连接第一棵树中的节点 4 和第二棵树中的节点 4 。</li></ul></blockquote><img src="/blog/2025/02/28/maximize-the-number-of-target-nodes-after-connecting-trees-i/3372-1.png" class=""><p><strong>示例 2:</strong></p><blockquote><p><strong>输入：</strong><code>edges1 = [[0, 1], [0, 2], [0, 3], [0, 4]], edges2 = [[0, 1], [1, 2], [2, 3]]</code>, <code>k = 1</code><br><strong>输出：</strong><code>[6, 3, 3, 3, 3]</code><br><strong>解释：</strong>对于每个 <code>i</code> ，连接第一棵树中的节点 <code>i</code> 和第二棵树中的任意一个节点。</p></blockquote><img src="/blog/2025/02/28/maximize-the-number-of-target-nodes-after-connecting-trees-i/3372-2.png" class=""><p><strong>提示:</strong></p><ul><li><code>2 &lt;= n, m &lt;= 1000</code></li><li><code>edges1.length == n - 1</code></li><li><code>edges2.length == m - 1</code></li><li><code>edges1[i].length == edges2[i].length == 2</code></li><li><code>edges1[i] = [ai, bi]</code></li><li><code>0 &lt;= ai, bi &lt; n</code></li><li><code>edges2[i] = [ui, vi]</code></li><li><code>0 &lt;= ui, vi &lt; m</code></li><li>输入保证 <code>edges1</code> 和 <code>edges2</code> 都表示合法的树。</li><li><code>0 &lt;= k &lt;= 1000</code></li></ul><span id="more"></span><h1 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h1><ol><li><strong>第一棵树内部目标节点计算：</strong>对于第一棵树中的每个节点 <code>i</code>，计算在不添加新边的情况下，距离 <code>i</code> 不超过 <code>k</code> 的节点数（包括自身）。这部分节点不受添加边的影响，因为新边连接的是另一棵树。</li><li><strong>第二棵树内部目标节点计算：</strong>对于第二棵树中的每个节点 <code>j</code>，计算距离 <code>j</code> 不超过 <code>k-1</code> 的节点数（包括自身）。这是因为添加边后，从第一棵树节点 <code>i</code> 到第二棵树节点 <code>v</code> 的路径为 <code>i → a → b → v</code>，其中 <code>a</code> 和 <code>b</code> 是添加边的两个端点，路径长度为 <code>d1(i, a) + 1 + d2(b, v)</code>。为最大化第二棵树部分的贡献，选择 <code>a = i</code>（即连接点选在 <code>i</code>），这样路径长度简化为 <code>1 + d2(b, v)</code>。因此，第二棵树部分最多贡献距离 <code>b</code> 不超过 <code>k-1</code> 的节点数。</li><li><strong>最大化第二棵树贡献：</strong>取第二棵树中所有节点在距离 <code>k-1</code> 内节点数的最大值 <code>maxCount2</code>。</li><li><strong>合并结果：</strong>对于第一棵树中的每个节点 <code>i</code>，其目标节点最大值为 <code>count1[i] + maxCount2</code>，其中 <code>count1[i]</code> 是第一棵树内部距离 <code>i</code> 不超过 <code>k</code> 的节点数。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] maxTargetNodes(<span class="type">int</span>[][] edges1, <span class="type">int</span>[][] edges2, <span class="type">int</span> k) &#123;</span><br><span class="line">    <span class="comment">// 计算第一课无向树中每个节点的目标节点数</span></span><br><span class="line">    <span class="type">int</span>[] count1 = count(edges1, k);</span><br><span class="line">    <span class="comment">// 计算第一课无向树中每个节点的目标节点数</span></span><br><span class="line">    <span class="type">int</span>[] count2 = count(edges2, k - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 计算第二课无向树中每个节点的目标节点数的最大值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">maxCount2</span> <span class="operator">=</span> Arrays.stream(count2).max().orElse(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> edges1.length + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        result[i] = count1[i] + maxCount2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] count(<span class="type">int</span>[][] edges, <span class="type">int</span> k) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> edges.length + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 构建无向树</span></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        graph.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>[] edge : edges) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> edge[<span class="number">0</span>], v = edge[<span class="number">1</span>];</span><br><span class="line">        graph.get(u).add(v);</span><br><span class="line">        graph.get(v).add(u);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        result[i] = dfs(i, -<span class="number">1</span>, graph, k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> parent, List&lt;List&lt;Integer&gt;&gt; graph, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (k &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> v : graph.get(u)) &#123;</span><br><span class="line">        <span class="comment">// 防止回溯到父节点，避免无限递归和重复计数</span></span><br><span class="line">        <span class="keyword">if</span> (v == parent) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        count += dfs(v, u, graph, k - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li><strong>时间复杂度：</strong><code>O(n² + m²)</code>，其中 <code>n</code> 和 <code>m</code> 分别是两棵树的节点数。计算 <code>count1</code> 和 <code>count2</code> 时，对每个节点进行 BFS，每次 BFS 最坏 <code>O(n)</code> 或 <code>O(m)</code>，总时间复杂度为 <code>O(n²)</code> 和 <code>O(m²)</code>。</li><li><strong>空间复杂度：</strong><code>O(n + m)</code>，用于存储树的邻接表 <code>O(n + m)</code> 和 BFS 的队列及访问标记 <code>O(n)</code> 或 <code>O(m)</code>。</li></ul><h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><blockquote><p><a href="https://leetcode.cn/problems/maximize-the-number-of-target-nodes-after-connecting-trees-i/description/" title="3372. 连接两棵树后最大目标节点数目 Ⅰ | 力扣（LeetCode）">3372. 连接两棵树后最大目标节点数目 Ⅰ | 力扣（LeetCode）</a></p></blockquote><hr>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;有两棵 &lt;strong&gt;无向树&lt;/strong&gt;，分别有 &lt;code&gt;n&lt;/code&gt; 和 &lt;code&gt;m&lt;/code&gt; 个树节点。两棵树中的节点编号分别为 &lt;code&gt;[0, n - 1]&lt;/code&gt; 和 &lt;code&gt;[0, m - 1]&lt;/code&gt; 中的整数。&lt;/p&gt;
&lt;p&gt;给你两个二维整数 &lt;code&gt;edges1&lt;/code&gt; 和 &lt;code&gt;edges2&lt;/code&gt; ，长度分别为 &lt;code&gt;n - 1&lt;/code&gt; 和 &lt;code&gt;m - 1&lt;/code&gt; ，其中 &lt;code&gt;edges1[i] = [ai, bi]&lt;/code&gt; 表示第一棵树中节点 &lt;code&gt;ai&lt;/code&gt; 和 &lt;code&gt;bi&lt;/code&gt; 之间有一条边，&lt;code&gt;edges2[i] = [ui, vi]&lt;/code&gt; 表示第二棵树中节点 &lt;code&gt;ui&lt;/code&gt; 和 &lt;code&gt;vi&lt;/code&gt; 之间有一条边。同时给你一个整数 &lt;code&gt;k&lt;/code&gt; 。如果节点 &lt;code&gt;u&lt;/code&gt; 和节点 &lt;code&gt;v&lt;/code&gt; 之间路径的边数小于等于 &lt;code&gt;k&lt;/code&gt; ，那么我们称节点 &lt;code&gt;u&lt;/code&gt; 是节点 &lt;code&gt;v&lt;/code&gt; 的 &lt;strong&gt;目标节点&lt;/strong&gt; 。一个节点一定是它自己的 &lt;strong&gt;目标节点&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;请你返回一个长度为 &lt;code&gt;n&lt;/code&gt; 的整数数组 &lt;code&gt;answer&lt;/code&gt; ，&lt;code&gt;answer[i]&lt;/code&gt; 表示将第一棵树中的一个节点与第二棵树中的一个节点连接一条边后，第一棵树中节点 &lt;code&gt;i&lt;/code&gt; 的目标节点数目的最大值 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;每个查询相互独立。意味着进行下一次查询之前，你需要先把刚添加的边给删掉。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt;&lt;code&gt;edges1 = [[0, 1], [0, 2], [2, 3], [2, 4]], edges2 = [[0, 1], [0, 2], [0, 3], [2, 7], [1, 4], [4, 5], [4, 6]]&lt;/code&gt;, &lt;code&gt;k = 2&lt;/code&gt;&lt;br&gt;&lt;strong&gt;输出：&lt;/strong&gt;&lt;code&gt;[9, 7, 9, 8, 8]&lt;/code&gt;&lt;br&gt;&lt;strong&gt;解释：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于 &lt;code&gt;i = 0&lt;/code&gt; ，连接第一棵树中的节点 0 和第二棵树中的节点 0 。&lt;/li&gt;
&lt;li&gt;对于 &lt;code&gt;i = 1&lt;/code&gt; ，连接第一棵树中的节点 1 和第二棵树中的节点 0 。&lt;/li&gt;
&lt;li&gt;对于 &lt;code&gt;i = 2&lt;/code&gt; ，连接第一棵树中的节点 2 和第二棵树中的节点 4 。&lt;/li&gt;
&lt;li&gt;对于 &lt;code&gt;i = 3&lt;/code&gt; ，连接第一棵树中的节点 3 和第二棵树中的节点 4 。&lt;/li&gt;
&lt;li&gt;对于 &lt;code&gt;i = 4&lt;/code&gt; ，连接第一棵树中的节点 4 和第二棵树中的节点 4 。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;img src=&quot;/blog/2025/02/28/maximize-the-number-of-target-nodes-after-connecting-trees-i/3372-1.png&quot; class=&quot;&quot;&gt;

&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt;&lt;code&gt;edges1 = [[0, 1], [0, 2], [0, 3], [0, 4]], edges2 = [[0, 1], [1, 2], [2, 3]]&lt;/code&gt;, &lt;code&gt;k = 1&lt;/code&gt;&lt;br&gt;&lt;strong&gt;输出：&lt;/strong&gt;&lt;code&gt;[6, 3, 3, 3, 3]&lt;/code&gt;&lt;br&gt;&lt;strong&gt;解释：&lt;/strong&gt;对于每个 &lt;code&gt;i&lt;/code&gt; ，连接第一棵树中的节点 &lt;code&gt;i&lt;/code&gt; 和第二棵树中的任意一个节点。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;img src=&quot;/blog/2025/02/28/maximize-the-number-of-target-nodes-after-connecting-trees-i/3372-2.png&quot; class=&quot;&quot;&gt;

&lt;p&gt;&lt;strong&gt;提示:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;2 &amp;lt;= n, m &amp;lt;= 1000&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;edges1.length == n - 1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;edges2.length == m - 1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;edges1[i].length == edges2[i].length == 2&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;edges1[i] = [ai, bi]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0 &amp;lt;= ai, bi &amp;lt; n&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;edges2[i] = [ui, vi]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0 &amp;lt;= ui, vi &amp;lt; m&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;输入保证 &lt;code&gt;edges1&lt;/code&gt; 和 &lt;code&gt;edges2&lt;/code&gt; 都表示合法的树。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0 &amp;lt;= k &amp;lt;= 1000&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://www.cylong.com/categories/LeetCode/"/>
    
    
    <category term="Java" scheme="https://www.cylong.com/tags/Java/"/>
    
    <category term="LeetCode" scheme="https://www.cylong.com/tags/LeetCode/"/>
    
    <category term="学习笔记" scheme="https://www.cylong.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="树" scheme="https://www.cylong.com/tags/%E6%A0%91/"/>
    
    <category term="深度优先搜索" scheme="https://www.cylong.com/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
    <category term="LeetCode中等" scheme="https://www.cylong.com/tags/LeetCode%E4%B8%AD%E7%AD%89/"/>
    
    <category term="无向树" scheme="https://www.cylong.com/tags/%E6%97%A0%E5%90%91%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>不同的二叉搜索树</title>
    <link href="https://www.cylong.com/blog/2025/02/17/unique-binary-search-trees/"/>
    <id>https://www.cylong.com/blog/2025/02/17/unique-binary-search-trees/</id>
    <published>2025-02-17T14:22:45.000Z</published>
    <updated>2025-02-17T14:22:45.000Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给你一个整数 <code>n</code> ，求恰由 <code>n</code> 个节点组成且节点值从 <code>1</code> 到 <code>n</code> 互不相同的 <strong>二叉搜索树</strong> 有多少种？返回满足题意的二叉搜索树的种数。</p><p><strong>示例 1:</strong></p><img src="/blog/2025/02/17/unique-binary-search-trees/uniquebstn3.jpg" class="" title="二叉搜索树"><blockquote><p><strong>输入：</strong>n = 3<br><strong>输出：</strong>5</p></blockquote><p><strong>示例 2:</strong></p><blockquote><p><strong>输入：</strong>n = 1<br><strong>输出：</strong>1</p></blockquote><p><strong>提示:</strong></p><ul><li><code>1 &lt;= n &lt;= 19</code></li></ul><span id="more"></span><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p>二叉搜索树的特点是，对于每个节点来说，左子树的所有节点的值都小于它，右子树的所有节点的值都大于它。为了求解由 <code>n</code> 个节点组成的二叉搜索树的数量，可以使用动态规划的方法。二叉搜索树的中序遍历是有序的，因此结构数目仅与节点数量有关。</p><p>假设以 <code>i</code> 为根节点，那么左子树由 <code>1</code> 到 <code>i-1</code> 组成，共有 <code>i-1</code> 个节点，右子树由 <code>i+1</code> 到 <code>n</code> 组成，共有 <code>n-i</code> 个节点。所以，以 <code>i</code> 为根的 BST 数目等于左子树的数目乘以右子树的数目。设 <code>G(n)</code> 为 <code>n</code> 个节点组成的 BST 数目，以不同根节点划分左右子树，总数目为左右子树数目的乘积之和。递推公式：<code>G(n) = G(0)G(n-1) + G(1)G(n-2) + ... + G(n-1)G(0)</code>，其中 <code>G(0)=1</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numTrees</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 遍历计算 dp[1] 到 dp[n]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="comment">// 枚举左子树的节点数 j</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="comment">// 左子树 j 节点，右子树 (i-j-1) 节点</span></span><br><span class="line">            dp[i] += dp[j] * dp[i - j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注：</strong>当 <code>n ≥ 19</code> 时，结果会超出 <code>int</code> 范围，需改用 <code>long</code> 或 <code>BigInteger</code>。</p><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li><strong>时间复杂度：</strong><code>O(n²)</code>。需要双层循环，外层循环 <code>n</code> 次，内层循环 <code>i</code> 次，总操作次数为 <code>n(n+1)/2</code>，因此总时间复杂度为 <code>O(n²)</code>。</li><li><strong>空间复杂度：</strong><code>O(n)</code>。使用长度为 <code>n+1</code> 的数组存储中间结果。</li></ul><h1 id="卡特兰数"><a href="#卡特兰数" class="headerlink" title="卡特兰数"></a>卡特兰数</h1><p>二叉搜索树的数目实际上是一个 <strong>卡特兰数</strong> 问题，卡特兰数是一个数列，满足递推关系 <code>C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)</code>，并且初始条件 <code>C(0)=1</code>。这和本题的二叉搜索树的数量问题是一样的，所以此问题其实已经接触过卡特兰数的一个应用案例。卡塔兰数更便于计算的定义如下:</p><img src="/blog/2025/02/17/unique-binary-search-trees/catalan.png" class="" title="卡特兰数"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numTrees</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="comment">// 我们在这里需要用 long 类型防止计算过程中的溢出</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">C</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        C = C * <span class="number">2</span> * (<span class="number">2</span> * i + <span class="number">1</span>) / (i + <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int</span>) C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li><strong>时间复杂度：</strong><code>O(n)</code>。其中 <code>n</code> 表示二叉搜索树的节点个数。我们只需要循环遍历一次即可。</li><li><strong>空间复杂度：</strong><code>O(1)</code>。我们只需要常数空间存放若干变量。</li></ul><h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><blockquote><p><a href="https://leetcode.cn/problems/unique-binary-search-trees/description/" title="96. 完全二叉树的节点个数 | 力扣（LeetCode）">96. 不同的二叉搜索树 | 力扣（LeetCode）</a></p></blockquote><hr>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;给你一个整数 &lt;code&gt;n&lt;/code&gt; ，求恰由 &lt;code&gt;n&lt;/code&gt; 个节点组成且节点值从 &lt;code&gt;1&lt;/code&gt; 到 &lt;code&gt;n&lt;/code&gt; 互不相同的 &lt;strong&gt;二叉搜索树&lt;/strong&gt; 有多少种？返回满足题意的二叉搜索树的种数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;img src=&quot;/blog/2025/02/17/unique-binary-search-trees/uniquebstn3.jpg&quot; class=&quot;&quot; title=&quot;二叉搜索树&quot;&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt;n = 3&lt;br&gt;&lt;strong&gt;输出：&lt;/strong&gt;5&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt;n = 1&lt;br&gt;&lt;strong&gt;输出：&lt;/strong&gt;1&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;提示:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= n &amp;lt;= 19&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://www.cylong.com/categories/LeetCode/"/>
    
    
    <category term="Java" scheme="https://www.cylong.com/tags/Java/"/>
    
    <category term="LeetCode" scheme="https://www.cylong.com/tags/LeetCode/"/>
    
    <category term="学习笔记" scheme="https://www.cylong.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="动态规划" scheme="https://www.cylong.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="树" scheme="https://www.cylong.com/tags/%E6%A0%91/"/>
    
    <category term="二叉树" scheme="https://www.cylong.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    <category term="二叉搜索树" scheme="https://www.cylong.com/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    
    <category term="LeetCode中等" scheme="https://www.cylong.com/tags/LeetCode%E4%B8%AD%E7%AD%89/"/>
    
    <category term="数学公式" scheme="https://www.cylong.com/tags/%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>完全二叉树的节点个数</title>
    <link href="https://www.cylong.com/blog/2025/02/06/count-complete-tree-nodes/"/>
    <id>https://www.cylong.com/blog/2025/02/06/count-complete-tree-nodes/</id>
    <published>2025-02-06T14:10:56.000Z</published>
    <updated>2025-02-06T14:10:56.000Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给你一棵 <strong>完全二叉树</strong> 的根节点 <code>root</code> ，求出该树的节点个数。</p><p><strong>说明:</strong><br>完全二叉树：除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 <code>h</code> 层（从第 <code>0</code> 层开始），则该层包含 <code>1 ~ 2h</code> 个节点。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     1</span><br><span class="line">   /   \</span><br><span class="line">  2     3</span><br><span class="line"> / \   /</span><br><span class="line">4   5 6</span><br></pre></td></tr></table></figure><p><strong>示例 1:</strong></p><blockquote><p><strong>输入：</strong><code>root = [1,2,3,4,5,6]</code><br><strong>输出：</strong>6</p></blockquote><p><strong>示例 2:</strong></p><blockquote><p><strong>输入：</strong><code>root = []</code><br><strong>输出：</strong>0</p></blockquote><p><strong>示例 3:</strong></p><blockquote><p><strong>输入：</strong><code>root = [1]</code><br><strong>输出：</strong>1</p></blockquote><p><strong>提示:</strong></p><ul><li>树中节点的数目范围是 <code>[0, 5 * 10^4]</code></li><li><code>0 &lt;= Node.val &lt;= 5 * 10^4</code></li><li>题目数据保证输入的树是 <strong>完全二叉树</strong></li></ul><span id="more"></span><h1 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h1><p>如果是普通二叉树的话，最直接的方法就是递归或者迭代遍历每个节点，然后统计个数，这样时间复杂度是 <code>O(n)</code>，其中 <code>n</code> 是树的节点总数。空间复杂度是 <code>O(h)</code>，其中 <code>h</code> 是树的高度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countNodes</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + countNodes(root.left) + countNodes(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但这是一个普适的解法，对于此题给的完全二叉树的特点没有利用起来，我们先了解一下 <code>满二叉树</code> 的概念：一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是满二叉树，满二叉树的节点总数是 <code>(2^h) - 1 </code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     1</span><br><span class="line">   /   \</span><br><span class="line">  2     3</span><br><span class="line"> / \   / \</span><br><span class="line">4   5 6   7</span><br></pre></td></tr></table></figure><p>而完全二叉树的特点是除了最后一层外，其余层都是满的，并且最后一层的节点尽可能靠左。因此，可以利用这个特性来高效计算节点数，而不是普通的遍历方法。首先计算左子树高度 <code>left</code> 和右子树高度 <code>right</code>，接下来比较 <code>left</code> 和 <code>right</code>。</p><ul><li>如果两者相等，说明左子树是满的，此时左子树的节点数为 <code>2^left - 1</code>，加上根节点，总共是 <code>2^left</code>。然后递归计算右子树的节点数。</li><li>如果 <code>left</code> 不等于 <code>right</code>，则说明右子树是满的，但层数比左子树少一层，所以右子树的节点数是 <code>2^right - 1</code>，加上根节点，再递归计算左子树的节点数。</li></ul><p>这里的关键在于，当左右子树高度相等时，左子树一定是满的，可以快速计算其节点数，而无需递归下去；反之，右子树是满的，可以同样处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countNodes</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算左子树高度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> countLevel(root.left);</span><br><span class="line">    <span class="comment">// 计算右子树高度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> countLevel(root.right);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">        <span class="comment">// 左子树是满的，直接计算左子树节点数 (2^left)，递归计算右子树</span></span><br><span class="line">        <span class="keyword">return</span> countNodes(root.right) + (<span class="number">1</span> &lt;&lt; left);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 右子树是满的，直接计算右子树节点数 (2^right)，递归计算左子树</span></span><br><span class="line">        <span class="keyword">return</span> countNodes(root.left) + (<span class="number">1</span> &lt;&lt; right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">countLevel</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">level</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 完全二叉树的高度由最左路径决定</span></span><br><span class="line">        level++;</span><br><span class="line">        root = root.left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> level;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li><strong>时间复杂度：</strong><code>O((logN)^2)</code>，每次递归调用 countLevel 的时间为 <code>O(h)</code>（<code>h</code> 是当前子树高度），递归深度为树的高度 <code>O(logN)</code>（完全二叉树高度为 <code>logN</code>）。</li><li><strong>空间复杂度：</strong>递归深度为树的高度 <code>O(logN)</code>。</li></ul><h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><blockquote><p><a href="https://leetcode.cn/problems/count-complete-tree-nodes/description/" title="222. 完全二叉树的节点个数 | 力扣（LeetCode）">222. 完全二叉树的节点个数 | 力扣（LeetCode）</a></p></blockquote><hr>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;给你一棵 &lt;strong&gt;完全二叉树&lt;/strong&gt; 的根节点 &lt;code&gt;root&lt;/code&gt; ，求出该树的节点个数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说明:&lt;/strong&gt;&lt;br&gt;完全二叉树：除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 &lt;code&gt;h&lt;/code&gt; 层（从第 &lt;code&gt;0&lt;/code&gt; 层开始），则该层包含 &lt;code&gt;1 ~ 2h&lt;/code&gt; 个节点。&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;     1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   /   &#92;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  2     3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; / &#92;   /&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4   5 6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt;&lt;code&gt;root = [1,2,3,4,5,6]&lt;/code&gt;&lt;br&gt;&lt;strong&gt;输出：&lt;/strong&gt;6&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt;&lt;code&gt;root = []&lt;/code&gt;&lt;br&gt;&lt;strong&gt;输出：&lt;/strong&gt;0&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例 3:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt;&lt;code&gt;root = [1]&lt;/code&gt;&lt;br&gt;&lt;strong&gt;输出：&lt;/strong&gt;1&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;提示:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;树中节点的数目范围是 &lt;code&gt;[0, 5 * 10^4]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0 &amp;lt;= Node.val &amp;lt;= 5 * 10^4&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;题目数据保证输入的树是 &lt;strong&gt;完全二叉树&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://www.cylong.com/categories/LeetCode/"/>
    
    
    <category term="Java" scheme="https://www.cylong.com/tags/Java/"/>
    
    <category term="LeetCode" scheme="https://www.cylong.com/tags/LeetCode/"/>
    
    <category term="学习笔记" scheme="https://www.cylong.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="递归" scheme="https://www.cylong.com/tags/%E9%80%92%E5%BD%92/"/>
    
    <category term="树" scheme="https://www.cylong.com/tags/%E6%A0%91/"/>
    
    <category term="二叉树" scheme="https://www.cylong.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    <category term="LeetCode简单" scheme="https://www.cylong.com/tags/LeetCode%E7%AE%80%E5%8D%95/"/>
    
    <category term="完全二叉树" scheme="https://www.cylong.com/tags/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    <category term="满二叉树" scheme="https://www.cylong.com/tags/%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>国内如何注册国外 Apple ID</title>
    <link href="https://www.cylong.com/blog/2023/10/10/sign-up-apple-id/"/>
    <id>https://www.cylong.com/blog/2023/10/10/sign-up-apple-id/</id>
    <published>2023-10-10T14:54:22.000Z</published>
    <updated>2023-10-10T14:54:22.000Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近喜欢玩 ChatGPT，奈何手机 IOS 版的 ChatGPT 没有上架中国大陆区 App Store，所以折腾下想要注册美国的 Apple ID，同时也方便下载一些其他有用的软件，比如 PayPal 和 Shadowrocket，话不多说，操作起来也是很简单的 👻</p><span id="more"></span><h1 id="如何注册"><a href="#如何注册" class="headerlink" title="如何注册"></a>如何注册</h1><ol><li>首先去 Apple 官网 <a href="https://appleid.apple.com/account" title="创建你的 Apple ID">创建你的 Apple ID</a>，这里 <code>国家或地区</code> 选择 <code>美国</code>，其他的填写你的真实信息，手机号可以填写中国大陆手机号，用于后续接收验证码，验证通过后你就获得了一个国外的 Apple ID ，但是还没结束。<img src="/blog/2023/10/10/sign-up-apple-id/%E5%88%9B%E5%BB%BA%E4%BD%A0%E7%9A%84-Apple-ID.png" class="" title="创建你的 Apple ID"></li><li>用你刚刚注册的 Apple ID 登录你的苹果设备，我用我的 iPad 做了小白鼠，第一次登录，有各种验证和同意条款等操作，确认即可。</li><li><code>设置</code> 里点击你的头像，找到 <code>付款与配送</code>，编辑配送地址（如果默认跳转到添加付款方式页面，回到上一页即可），这里要选择一个美国的地址，可以通过 <a href="https://www.meiguodizhi.com/" title="美国地址生成器">美国地址生成器</a>（链接打不开的话直接去谷歌或者百度搜索关键字）随机生成填入后保存。<img src="/blog/2023/10/10/sign-up-apple-id/%E7%BC%96%E8%BE%91%E9%80%81%E8%B4%A7%E5%9C%B0%E5%9D%80.jpg" class="" title="编辑送货地址"></li><li>接下来就可以尽情的在 App Store 里下载各种神秘的软件啦（第3步没设置的话，这里下载软件的时候也是会提示设置送货地址的）<img src="/blog/2023/10/10/sign-up-apple-id/%E4%B8%8B%E8%BD%BDChatGPT.jpg" class="" title="下载ChatGPT"></li></ol><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote><p><a href="/blog/2023/10/08/sign-up-chatgpt/" title="国内如何注册 ChatGPT 账号 | 笑话人生">国内如何注册 ChatGPT 账号 | 笑话人生</a><br><a href="https://zhuanlan.zhihu.com/p/373675995" title="手把手教你注册国外apple ID（超简单） | 知乎">手把手教你注册国外apple ID（超简单） | 知乎</a><br><a href="https://imtoken.fans/t/topic/243" title="如何创建海外 Apple ID | imToken Fans">如何创建海外 Apple ID | imToken Fans</a></p></blockquote><hr>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近喜欢玩 ChatGPT，奈何手机 IOS 版的 ChatGPT 没有上架中国大陆区 App Store，所以折腾下想要注册美国的 Apple ID，同时也方便下载一些其他有用的软件，比如 PayPal 和 Shadowrocket，话不多说，操作起来也是很简单的 👻&lt;/p&gt;</summary>
    
    
    
    <category term="Apple" scheme="https://www.cylong.com/categories/Apple/"/>
    
    
    <category term="IOS" scheme="https://www.cylong.com/tags/IOS/"/>
    
    <category term="ChatGPT" scheme="https://www.cylong.com/tags/ChatGPT/"/>
    
    <category term="Apple" scheme="https://www.cylong.com/tags/Apple/"/>
    
  </entry>
  
</feed>
