<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>笑话人生</title>
  
  <subtitle>年华易逝 懂得珍惜</subtitle>
  <link href="https://www.cylong.com/atom.xml" rel="self"/>
  
  <link href="https://www.cylong.com/"/>
  <updated>2025-06-12T16:18:52.000Z</updated>
  <id>https://www.cylong.com/</id>
  
  <author>
    <name>cylong</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>矩阵置零</title>
    <link href="https://www.cylong.com/blog/2025/06/13/set-matrix-zeroes/"/>
    <id>https://www.cylong.com/blog/2025/06/13/set-matrix-zeroes/</id>
    <published>2025-06-12T16:18:52.000Z</published>
    <updated>2025-06-12T16:18:52.000Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个 <code>m x n</code> 的矩阵，如果一个元素为 <code>0</code> ，则将其所在行和列的所有元素都设为 <code>0</code> 。请使用 <strong>原地算法</strong>。</p><p><strong>原地算法：</strong>在计算机科学中，一个原地算法（in-place algorithm）是一种使用小的，固定数量的额外之空间来转换资料的算法。当算法执行时，输入的资料通常会被要输出的部分覆盖掉。不是原地算法有时候称为非原地（not-in-place）或不得其所（out-of-place）。</p><p><strong>示例 1:</strong></p><img src="/blog/2025/06/13/set-matrix-zeroes/mat1.jpg" class=""><blockquote><p><strong>输入：</strong><code>matrix = [[1, 1, 1], [1, 0, 1], [1, 1, 1]]</code><br><strong>输出：</strong><code>[[1, 0, 1], [0, 0, 0], [1, 0, 1]]</code></p></blockquote><p><strong>示例 2:</strong></p><img src="/blog/2025/06/13/set-matrix-zeroes/mat2.jpg" class=""><blockquote><p><strong>输入：</strong><code>matrix = [[0, 1, 2, 0], [3, 4, 5, 2], [1, 3, 1, 5]]</code><br><strong>输出：</strong><code>[[0, 0, 0, 0], [0, 4, 5, 0], [0, 3, 1, 0]]</code></p></blockquote><p><strong>提示:</strong></p><ul><li><code>m == matrix.length</code></li><li><code>n == matrix[0].length</code></li><li><code>1 &lt;= m, n &lt;= 200</code></li><li><code>-2^31 &lt;= matrix[i][j] &lt;= 2^31 - 1</code></li></ul><span id="more"></span><h1 id="辅助数组法"><a href="#辅助数组法" class="headerlink" title="辅助数组法"></a>辅助数组法</h1><p>使用两个辅助数组分别记录需要置零的行和列。首先遍历矩阵，当遇到元素为 <code>0</code> 时，将对应的行标记和列标记设置为 <code>true</code>。然后再次遍历矩阵，根据行标记和列标记将相应元素置为 <code>0</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setZeroes</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取矩阵的行数和列数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">rowLen</span> <span class="operator">=</span> matrix.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">colLen</span> <span class="operator">=</span> matrix[<span class="number">0</span>].length;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建两个布尔数组，分别用于标记需要置零的行和列</span></span><br><span class="line">    <span class="type">boolean</span>[] row = <span class="keyword">new</span> <span class="title class_">boolean</span>[rowLen];</span><br><span class="line">    <span class="type">boolean</span>[] col = <span class="keyword">new</span> <span class="title class_">boolean</span>[colLen];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 第一次遍历：标记包含 0 的行和列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; rowLen; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; colLen; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                row[i] = <span class="literal">true</span>; <span class="comment">// 标记第 i 行需要置零</span></span><br><span class="line">                col[j] = <span class="literal">true</span>; <span class="comment">// 标记第 j 列需要置零</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 第二次遍历：根据标记数组将相应行和列的元素置零</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; rowLen; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; colLen; j++) &#123;</span><br><span class="line">            <span class="comment">// 如果当前行或列被标记，则将元素置为 0</span></span><br><span class="line">            <span class="keyword">if</span> (row[i] || col[j]) &#123;</span><br><span class="line">                matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li><strong>时间复杂度：</strong><code>O(m × n)</code>，其中 <code>m</code> 和 <code>n</code> 分别是矩阵的行数和列数。我们遍历了两次矩阵。</li><li><strong>空间复杂度：</strong><code>O(m + n)</code>，使用了两个辅助数组分别存储行和列的标记。</li></ul><h1 id="原地标记法（优化空间）"><a href="#原地标记法（优化空间）" class="headerlink" title="原地标记法（优化空间）"></a>原地标记法（优化空间）</h1><p>使用矩阵的第一行和第一列作为标记数组，代替上面解法中的额外数组。首先检查第一行和第一列是否需要置零，然后用第一行记录各列是否需要置零，第一列记录各行是否需要置零。最后根据标记处理除第一行第一列外的元素，再单独处理第一行和第一列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setZeroes</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">rowLen</span> <span class="operator">=</span> matrix.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">colLen</span> <span class="operator">=</span> matrix[<span class="number">0</span>].length;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查第一列是否有 0</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">colHasZero</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; rowLen; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix[i][<span class="number">0</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">            colHasZero = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查第一行是否有 0</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">rowHasZero</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; colLen; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix[<span class="number">0</span>][j] == <span class="number">0</span>) &#123;</span><br><span class="line">            rowHasZero = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用第一行和第一列标记其他行列的 0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; rowLen; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; colLen; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 这里其实也是先把有零的第一行和第一列位置置零了</span></span><br><span class="line">                matrix[i][<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// 标记第 i 行需要置零</span></span><br><span class="line">                matrix[<span class="number">0</span>][j] = <span class="number">0</span>; <span class="comment">// 标记第 j 列需要置零</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据标记设置除第一行和第一列外的元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; rowLen; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; colLen; j++) &#123;</span><br><span class="line">            <span class="comment">// 如果当前行或列被标记，则将元素置为 0</span></span><br><span class="line">            <span class="keyword">if</span> (matrix[i][<span class="number">0</span>] == <span class="number">0</span> || matrix[<span class="number">0</span>][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 处理第一列置零</span></span><br><span class="line">    <span class="keyword">if</span> (colHasZero) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; rowLen; i++) &#123;</span><br><span class="line">            matrix[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 处理第一行置零</span></span><br><span class="line">    <span class="keyword">if</span> (rowHasZero) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; colLen; j++) &#123;</span><br><span class="line">            matrix[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li><strong>时间复杂度：</strong><code>O(m × n)</code>，其中 <code>m</code> 和 <code>n</code> 分别是矩阵的行数和列数。我们遍历了多次矩阵，但时间复杂度仍是线性级别。</li><li><strong>空间复杂度：</strong><code>O(1)</code>，仅使用常数级别的额外空间。</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><table><thead><tr><th>解法</th><th>时间复杂度</th><th>空间复杂度</th><th>优势</th><th>劣势</th></tr></thead><tbody><tr><td>辅助数组法</td><td>O(m × n)</td><td>O(m + n)</td><td>思路清晰，实现简单，两次遍历矩阵即可完成</td><td>使用了额外的 O(m + n) 空间，不是原地算法</td></tr><tr><td>原地标记法</td><td>O(m × n)</td><td>O(1)</td><td>空间复杂度最优，仅使用常数空间，符合原地算法</td><td>实现逻辑相对复杂，需要多次遍历矩阵</td></tr></tbody></table><p>两种方法各有优劣，在实际应用中可根据具体场景选择最合适的解法。对于面试场景，掌握两种方法并能解释其优劣会更有优势。</p><h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><blockquote><p><a href="https://leetcode.cn/problems/set-matrix-zeroes/description/" title="73. 矩阵置零 | 力扣（LeetCode）">73. 矩阵置零 | 力扣（LeetCode）</a></p></blockquote><hr>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;给定一个 &lt;code&gt;m x n&lt;/code&gt; 的矩阵，如果一个元素为 &lt;code&gt;0&lt;/code&gt; ，则将其所在行和列的所有元素都设为 &lt;code&gt;0&lt;/code&gt; 。请使用 &lt;strong&gt;原地算法&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;原地算法：&lt;/strong&gt;在计算机科学中，一个原地算法（in-place algorithm）是一种使用小的，固定数量的额外之空间来转换资料的算法。当算法执行时，输入的资料通常会被要输出的部分覆盖掉。不是原地算法有时候称为非原地（not-in-place）或不得其所（out-of-place）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;img src=&quot;/blog/2025/06/13/set-matrix-zeroes/mat1.jpg&quot; class=&quot;&quot;&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt;&lt;code&gt;matrix = [[1, 1, 1], [1, 0, 1], [1, 1, 1]]&lt;/code&gt;&lt;br&gt;&lt;strong&gt;输出：&lt;/strong&gt;&lt;code&gt;[[1, 0, 1], [0, 0, 0], [1, 0, 1]]&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;/p&gt;
&lt;img src=&quot;/blog/2025/06/13/set-matrix-zeroes/mat2.jpg&quot; class=&quot;&quot;&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt;&lt;code&gt;matrix = [[0, 1, 2, 0], [3, 4, 5, 2], [1, 3, 1, 5]]&lt;/code&gt;&lt;br&gt;&lt;strong&gt;输出：&lt;/strong&gt;&lt;code&gt;[[0, 0, 0, 0], [0, 4, 5, 0], [0, 3, 1, 0]]&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;提示:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;m == matrix.length&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;n == matrix[0].length&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= m, n &amp;lt;= 200&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-2^31 &amp;lt;= matrix[i][j] &amp;lt;= 2^31 - 1&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://www.cylong.com/categories/LeetCode/"/>
    
    
    <category term="Java" scheme="https://www.cylong.com/tags/Java/"/>
    
    <category term="LeetCode" scheme="https://www.cylong.com/tags/LeetCode/"/>
    
    <category term="学习笔记" scheme="https://www.cylong.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="数组" scheme="https://www.cylong.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="矩阵" scheme="https://www.cylong.com/tags/%E7%9F%A9%E9%98%B5/"/>
    
    <category term="LeetCode中等" scheme="https://www.cylong.com/tags/LeetCode%E4%B8%AD%E7%AD%89/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot 入门指南：从零开始创建 Web 应用</title>
    <link href="https://www.cylong.com/blog/2025/06/12/spring-boot-demo/"/>
    <id>https://www.cylong.com/blog/2025/06/12/spring-boot-demo/</id>
    <published>2025-06-12T07:10:26.000Z</published>
    <updated>2025-06-12T07:10:26.000Z</updated>
    
    <content type="html"><![CDATA[<hr><blockquote><p>本文面向 Java 初学者，详细介绍 Spring Boot 框架原理、应用场景及从零搭建 Web 应用的完整流程。</p></blockquote><h1 id="Spring-Boot-框架简介"><a href="#Spring-Boot-框架简介" class="headerlink" title="Spring Boot 框架简介"></a>Spring Boot 框架简介</h1><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>Spring Boot 是 Spring 框架的扩展，通过 <strong>约定优于配置</strong> 的理念解决传统 Spring 应用配置复杂的问题，简化 Spring 应用的初始搭建和开发过程。通过自动配置和起步依赖（Starter Dependencies）来减少开发者的配置工作，Spring Boot 内嵌了 Tomcat、Jetty 或 Undertow 等服务器，因此无需部署 WAR 文件即可运行。核心思想是 <strong>让开发更简单</strong> 。</p><h2 id="核心特性"><a href="#核心特性" class="headerlink" title="核心特性"></a>核心特性</h2><ol><li><strong>自动配置</strong>：通过 <code>@EnableAutoConfiguration</code> 自动配置 Bean（基于项目中的 jar 依赖自动配置 Spring 应用）</li><li><strong>起步依赖</strong>：通过提供预定义的依赖描述符（如 <code>spring-boot-starter-web</code> 包含了开发 Web 应用所需的依赖）简化构建配置，解决版本冲突。</li><li><strong>内嵌服务</strong>：内置 Tomcat/Jetty/Undertow 等服务器，无需部署 WAR，直接运行一个独立的应用即可。</li><li><strong>Actuator</strong>：提供生产级监控和管理功能，如监控应用的健康状况、信息查看等。</li></ol><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[启动类] → [@SpringBootApplication] </span><br><span class="line">    → 扫描 @Component → 加载 @Configuration </span><br><span class="line">    → 读取 spring.factories → 应用自动配置</span><br><span class="line">    → 启动内嵌容器</span><br></pre></td></tr></table></figure><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>Spring Boot 适用于构建微服务架构、RESTful API、企业级应用等。</p><span id="more"></span><h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><h2 id="软件版本"><a href="#软件版本" class="headerlink" title="软件版本"></a>软件版本</h2><ol><li><strong>开发工具</strong>：IntelliJ IDEA 2021+</li><li><strong>Java环境</strong>：JDK 1.8 或以上版本（建议使用 JDK 11 或 17）</li><li><strong>构建工具</strong>：Maven 3.6+（IDEA 一般自带，但需确保配置正确）</li></ol><h2 id="配置-Maven-的-settings-xml"><a href="#配置-Maven-的-settings-xml" class="headerlink" title="配置 Maven 的 settings.xml"></a>配置 Maven 的 settings.xml</h2><p>Maven的 <code>settings.xml</code>文件用于配置全局的 Maven 设置，如仓库镜像、代理等。通常位于Maven 安装目录的 <code>conf</code> 文件夹下，或者用户目录下的 <code>.m2</code> 文件夹（如 <code>~/.m2/settings.xml</code>），在 <code>IDEA → Settings</code> 中可以直接查看文件路径：</p><img src="/blog/2025/06/12/spring-boot-demo/m2-settings-path.png" class=""><p>配置样例如下：</p><figure class="highlight xml"><figcaption><span>settings.xml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/SETTINGS/1.0.0&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/SETTINGS/1.0.0 </span></span></span><br><span class="line"><span class="string"><span class="tag">          http://maven.apache.org/xsd/settings-1.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 添加阿里云镜像加速 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirrors</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>aliyun<span class="tag">&lt;/<span class="name">id</span>&gt;</span> <span class="comment">&lt;!-- 镜像的唯一标识 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>Aliyun Public Repository<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://maven.aliyun.com/repository/public<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>*<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span> <span class="comment">&lt;!-- 匹配哪些仓库，`*` 表示所有仓库都使用该镜像 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirrors</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="IDEA-配置"><a href="#IDEA-配置" class="headerlink" title="IDEA 配置"></a>IDEA 配置</h2><ol><li>配置 Maven 路径：<code>File → Settings → Build, Execution, Deployment → Build Tools → Maven</code></li><li>设置 JDK 版本：<code>File → Project Structure → SDKs</code></li></ol><h1 id="创建-Spring-Boot-项目"><a href="#创建-Spring-Boot-项目" class="headerlink" title="创建 Spring Boot 项目"></a>创建 Spring Boot 项目</h1><h2 id="项目初始化"><a href="#项目初始化" class="headerlink" title="项目初始化"></a>项目初始化</h2><p>在 IDEA 中创建 Spring Boot 项目有两种常用方式：</p><ol><li>通过 Spring Initializr 网站（<a href="https://start.spring.io/">https://start.spring.io/</a>）生成项目，然后导入 IDEA。<img src="/blog/2025/06/12/spring-boot-demo/spring-initializr-web.png" class=""></li><li>打开 <code>IDEA → New → Project → Spring Boot</code>，配置项目信息<img src="/blog/2025/06/12/spring-boot-demo/new-project.png" class=""></li><li>添加依赖<ul><li><strong>Spring Web</strong>：用于构建Web应用</li><li><strong>Lombok</strong>：非必须，主要用于简化代码<img src="/blog/2025/06/12/spring-boot-demo/dependencies.png" class=""></li></ul></li></ol><h2 id="项目结构解析"><a href="#项目结构解析" class="headerlink" title="项目结构解析"></a>项目结构解析</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SpringBootDemo</span><br><span class="line">├── src/main/java</span><br><span class="line">│   └── com/cylong/springbootdemo</span><br><span class="line">│       ├── SpringBootDemoApplication.java  # 主启动类</span><br><span class="line">│       └── controller</span><br><span class="line">│           ├── HelloController.java # 控制器</span><br><span class="line">│           └── Student.java         # 这里主要用于展示 Lombok 简化代码作用</span><br><span class="line">├── src/main/resources</span><br><span class="line">│   ├── application.properties # 配置文件</span><br><span class="line">│   ├── static                 # 静态资源（HTML, CSS, JS）</span><br><span class="line">│   └── templates              # 模板文件（Thymeleaf）</span><br><span class="line">├── src/test                   # 测试代码</span><br><span class="line">└── pom.xml                    # Maven 配置</span><br></pre></td></tr></table></figure><h1 id="核心配置文件详解"><a href="#核心配置文件详解" class="headerlink" title="核心配置文件详解"></a>核心配置文件详解</h1><h2 id="pom-xml-解析"><a href="#pom-xml-解析" class="headerlink" title="pom.xml 解析"></a>pom.xml 解析</h2><figure class="highlight xml"><figcaption><span>pom.xml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 继承 Spring Boot 默认配置，它提供了依赖管理，这样我们在添加其他 Spring Boot 依赖时就不需要指定版本号了 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 通常填写公司或者个人域名的倒序，例如：com.example --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.cylong<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 项目名称 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>SpringBootDemo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>SpringBootDemo<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>SpringBootDemo<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>24<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- Web 开发核心依赖，（如 Spring MVC，内嵌 Tomcat 等） --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 测试依赖 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- Lombok 依赖--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 打包插件（生成可执行 Jar） --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">annotationProcessorPaths</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">path</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">annotationProcessorPaths</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">exclude</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="application-properties-解析"><a href="#application-properties-解析" class="headerlink" title="application.properties 解析"></a>application.properties 解析</h2><figure class="highlight yml"><figcaption><span>application.properties</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 应用名称</span></span><br><span class="line"><span class="string">spring.application.name=SpringBootDemo</span></span><br><span class="line"><span class="comment"># 修改端口 默认8080</span></span><br><span class="line"><span class="string">server.port=9090</span></span><br><span class="line"><span class="comment"># 配置上下文，URL变为：http://localhost:9090/demo/hello</span></span><br><span class="line"><span class="comment"># 如果不配置，默认是：http://localhost:9090/hello</span></span><br><span class="line"><span class="string">server.servlet.context-path=/demo</span></span><br><span class="line"><span class="comment"># 自定义属性</span></span><br><span class="line"><span class="string">welcome.message=Hello</span> <span class="string">Spring</span> <span class="string">Boot</span></span><br></pre></td></tr></table></figure><h1 id="编写第一个-Web-接口"><a href="#编写第一个-Web-接口" class="headerlink" title="编写第一个 Web 接口"></a>编写第一个 Web 接口</h1><h2 id="创建控制器"><a href="#创建控制器" class="headerlink" title="创建控制器"></a>创建控制器</h2><figure class="highlight java"><figcaption><span>HelloController.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cylong.springbootdemo.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表明这是一个控制器，并且返回的数据直接写入响应体（如 JSON 或字符串）</span></span><br><span class="line"><span class="meta">@RestController</span> <span class="comment">// = @Controller + @ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// application.properties 中自定义属性</span></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;welcome.message&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String welcomeMsg;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 映射 GET 请求到 /hello 路径</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        student.setNo(<span class="string">&quot;1000&quot;</span>);</span><br><span class="line">        student.setName(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> welcomeMsg + <span class="string">&quot; &quot;</span> + student.getName() + <span class="string">&quot; 访问成功！&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>Student.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cylong.springbootdemo.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 学号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String no;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 姓名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里 <code>@Data</code> 是 Lombok 提供的一个组合注解，它主要用于简化 Java Bean 的编写。当你在类上使用 <code>@Data</code> 注解时，Lombok 会在编译时自动为类生成以下方法：</p><ol><li>所有字段的 <code>getter</code> 方法（对于非 <code>static</code> 字段）</li><li>所有非 <code>final</code> 字段的 <code>setter</code> 方法</li><li><code>equals()</code> 方法</li><li><code>hashCode()</code> 方法</li><li><code>toString()</code> 方法</li></ol><h2 id="创建启动类"><a href="#创建启动类" class="headerlink" title="创建启动类"></a>创建启动类</h2><figure class="highlight java"><figcaption><span>SpringBootDemoApplication.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cylong.springbootdemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 核心注解：启用自动配置和组件扫描</span></span><br><span class="line"><span class="comment">// 组合了 @Configuration + @EnableAutoConfiguration + @ComponentScan</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringBootDemoApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 启动 Spring 应用</span></span><br><span class="line">        SpringApplication.run(SpringBootDemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="运行与测试"><a href="#运行与测试" class="headerlink" title="运行与测试"></a>运行与测试</h1><h2 id="启动应用"><a href="#启动应用" class="headerlink" title="启动应用"></a>启动应用</h2><ol><li>右键 <code>SpringBootDemoApplication → Run &#39;SpringBootDemoApplication&#39;</code> 或者使用 IDEA 工具栏的运行按钮。</li><li>查看控制台输出：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  .   ____          _            __ _ _</span><br><span class="line"> /\\ / ___&#x27;_ __ _ _(_)_ __  __ _ \ \ \ \</span><br><span class="line">( ( )\___ | &#x27;_ | &#x27;_| | &#x27;_ \/ _` | \ \ \ \</span><br><span class="line"> \\/  ___)| |_)| | | | | || (_| |  ) ) ) )</span><br><span class="line">  &#x27;  |____| .__|_| |_|_| |_\__, | / / / /</span><br><span class="line"> =========|_|==============|___/=/_/_/_/</span><br><span class="line"></span><br><span class="line"> :: Spring Boot ::                (v3.5.0)</span><br><span class="line"></span><br><span class="line">2025-06-15T06:53:46.411+08:00  INFO 22460 --- [SpringBootDemo] [           main] c.c.s.SpringBootDemoApplication          : Starting SpringBootDemoApplication using Java 24.0.1 with PID 22460 (D:\Github\IdeaProjects\SpringBootDemo\target\classes started by win in D:\Github\IdeaProjects\SpringBootDemo)</span><br><span class="line">2025-06-15T06:53:46.413+08:00  INFO 22460 --- [SpringBootDemo] [           main] c.c.s.SpringBootDemoApplication          : No active profile set, falling back to 1 default profile: &quot;default&quot;</span><br><span class="line">2025-06-15T06:53:46.865+08:00  INFO 22460 --- [SpringBootDemo] [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat initialized with port 9090 (http)</span><br><span class="line">2025-06-15T06:53:46.875+08:00  INFO 22460 --- [SpringBootDemo] [           main] o.apache.catalina.core.StandardService   : Starting service [Tomcat]</span><br><span class="line">2025-06-15T06:53:46.875+08:00  INFO 22460 --- [SpringBootDemo] [           main] o.apache.catalina.core.StandardEngine    : Starting Servlet engine: [Apache Tomcat/10.1.41]</span><br><span class="line">2025-06-15T06:53:46.904+08:00  INFO 22460 --- [SpringBootDemo] [           main] o.a.c.c.C.[Tomcat].[localhost].[/demo]   : Initializing Spring embedded WebApplicationContext</span><br><span class="line">2025-06-15T06:53:46.904+08:00  INFO 22460 --- [SpringBootDemo] [           main] w.s.c.ServletWebServerApplicationContext : Root WebApplicationContext: initialization completed in 462 ms</span><br><span class="line">2025-06-15T06:53:47.124+08:00  INFO 22460 --- [SpringBootDemo] [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port 9090 (http) with context path &#x27;/demo&#x27;</span><br><span class="line">2025-06-15T06:53:47.129+08:00  INFO 22460 --- [SpringBootDemo] [           main] c.c.s.SpringBootDemoApplication          : Started SpringBootDemoApplication in 1.0 seconds (process running for 1.349)</span><br></pre></td></tr></table></figure></li></ol><h2 id="浏览器访问"><a href="#浏览器访问" class="headerlink" title="浏览器访问"></a>浏览器访问</h2><p>应用启动后，默认端口是 8080。我上文配置文件修改了端口号为 9090，并且设置了 <code>context-path=/demo</code>，所以打开浏览器访问：<a href="http://localhost:9090/demo/hello">http://localhost:9090/demo/hello</a> （默认是：<a href="http://localhost:8080/hello">http://localhost:8080/hello</a>）</p><p>页面输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello Spring Boot 张三 访问成功！</span><br></pre></td></tr></table></figure><h2 id="项目打包部署"><a href="#项目打包部署" class="headerlink" title="项目打包部署"></a>项目打包部署</h2><ol><li><p>bash 执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成可执行 JAR</span></span><br><span class="line">mvn clean package <span class="comment"># 生成 target/SpringBootDemo-0.0.1-SNAPSHOT.jar</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行应用</span></span><br><span class="line">java -jar target/SpringBootDemo-0.0.1-SNAPSHOT.jar</span><br></pre></td></tr></table></figure></li><li><p>或者直接图形化界面打包：</p></li></ol><img src="/blog/2025/06/12/spring-boot-demo/maven-package.png" class=""><h1 id="常见问题排查"><a href="#常见问题排查" class="headerlink" title="常见问题排查"></a>常见问题排查</h1><ol><li>端口冲突：修改 <code>server.port=9090</code>，默认是 <code>8080</code></li><li>404 错误：<ul><li>检查 <code>@RestController</code> 注解</li><li>确认 URL 包含 <code>context-path</code></li></ul></li><li>依赖下载失败：<ul><li>检查 Maven 镜像配置</li><li>执行 <code>mvn clean install -U</code></li></ul></li></ol><hr>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;本文面向 Java 初学者，详细介绍 Spring Boot 框架原理、应用场景及从零搭建 Web 应用的完整流程。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;Spring-Boot-框架简介&quot;&gt;&lt;a href=&quot;#Spring-Boot-框架简介&quot; class=&quot;headerlink&quot; title=&quot;Spring Boot 框架简介&quot;&gt;&lt;/a&gt;Spring Boot 框架简介&lt;/h1&gt;&lt;h2 id=&quot;基本原理&quot;&gt;&lt;a href=&quot;#基本原理&quot; class=&quot;headerlink&quot; title=&quot;基本原理&quot;&gt;&lt;/a&gt;基本原理&lt;/h2&gt;&lt;p&gt;Spring Boot 是 Spring 框架的扩展，通过 &lt;strong&gt;约定优于配置&lt;/strong&gt; 的理念解决传统 Spring 应用配置复杂的问题，简化 Spring 应用的初始搭建和开发过程。通过自动配置和起步依赖（Starter Dependencies）来减少开发者的配置工作，Spring Boot 内嵌了 Tomcat、Jetty 或 Undertow 等服务器，因此无需部署 WAR 文件即可运行。核心思想是 &lt;strong&gt;让开发更简单&lt;/strong&gt; 。&lt;/p&gt;
&lt;h2 id=&quot;核心特性&quot;&gt;&lt;a href=&quot;#核心特性&quot; class=&quot;headerlink&quot; title=&quot;核心特性&quot;&gt;&lt;/a&gt;核心特性&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;自动配置&lt;/strong&gt;：通过 &lt;code&gt;@EnableAutoConfiguration&lt;/code&gt; 自动配置 Bean（基于项目中的 jar 依赖自动配置 Spring 应用）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;起步依赖&lt;/strong&gt;：通过提供预定义的依赖描述符（如 &lt;code&gt;spring-boot-starter-web&lt;/code&gt; 包含了开发 Web 应用所需的依赖）简化构建配置，解决版本冲突。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;内嵌服务&lt;/strong&gt;：内置 Tomcat/Jetty/Undertow 等服务器，无需部署 WAR，直接运行一个独立的应用即可。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Actuator&lt;/strong&gt;：提供生产级监控和管理功能，如监控应用的健康状况、信息查看等。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;工作原理&quot;&gt;&lt;a href=&quot;#工作原理&quot; class=&quot;headerlink&quot; title=&quot;工作原理&quot;&gt;&lt;/a&gt;工作原理&lt;/h2&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[启动类] → [@SpringBootApplication] &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    → 扫描 @Component → 加载 @Configuration &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    → 读取 spring.factories → 应用自动配置&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    → 启动内嵌容器&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h2 id=&quot;应用场景&quot;&gt;&lt;a href=&quot;#应用场景&quot; class=&quot;headerlink&quot; title=&quot;应用场景&quot;&gt;&lt;/a&gt;应用场景&lt;/h2&gt;&lt;p&gt;Spring Boot 适用于构建微服务架构、RESTful API、企业级应用等。&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="https://www.cylong.com/categories/Java/"/>
    
    
    <category term="Java" scheme="https://www.cylong.com/tags/Java/"/>
    
    <category term="Spring" scheme="https://www.cylong.com/tags/Spring/"/>
    
    <category term="SpringBoot" scheme="https://www.cylong.com/tags/SpringBoot/"/>
    
    <category term="JavaWeb" scheme="https://www.cylong.com/tags/JavaWeb/"/>
    
    <category term="后端框架" scheme="https://www.cylong.com/tags/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6/"/>
    
    <category term="RESTfulAPI" scheme="https://www.cylong.com/tags/RESTfulAPI/"/>
    
  </entry>
  
  <entry>
    <title>最大子数组和</title>
    <link href="https://www.cylong.com/blog/2025/06/09/maximum-subarray/"/>
    <id>https://www.cylong.com/blog/2025/06/09/maximum-subarray/</id>
    <published>2025-06-09T14:40:57.000Z</published>
    <updated>2025-06-09T14:40:57.000Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p><strong>子数组</strong> 是数组中的一个连续部分。</p><p><strong>示例 1:</strong></p><blockquote><p><strong>输入：</strong><code>nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]</code><br><strong>输出：</strong>6<br><strong>解释：</strong>连续子数组 <code>[4, -1, 2, 1]</code> 的和最大，为 <code>6</code> 。</p></blockquote><p><strong>示例 2:</strong></p><blockquote><p><strong>输入：</strong><code>nums = [1]</code><br><strong>输出：</strong>1</p></blockquote><p><strong>示例 3:</strong></p><blockquote><p><strong>输入：</strong><code>nums = [5, 4, -1, 7, 8]</code><br><strong>输出：</strong>23</p></blockquote><p><strong>提示:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 10^5</code></li><li><code>-10^4 &lt;= nums[i] &lt;= 10^4</code></li></ul><span id="more"></span><h1 id="暴力枚举"><a href="#暴力枚举" class="headerlink" title="暴力枚举"></a>暴力枚举</h1><p>最简单的思路，通过两层循环遍历所有可能的连续子数组，计算每个子数组的和并记录最大值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; nums.length; j++) &#123;</span><br><span class="line">            sum += nums[j];</span><br><span class="line">            max = Math.max(max, sum);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li><strong>时间复杂度：</strong><code>O(n²)</code>，其中 <code>n</code> 是数组长度。需要两层循环遍历所有子数组。</li><li><strong>空间复杂度：</strong><code>O(1)</code>，仅使用常数级别的额外空间。</li></ul><h1 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h1><p>参考前缀和的定义：<a href="/blog/2025/06/03/range-sum-query-immutable/" title="303. 区域和检索 - 数组不可变 | 笑话人生">303. 区域和检索 - 数组不可变 | 笑话人生</a></p><p>利用前缀和的思想，由于子数组的元素和等于两个前缀和的差，遍历数组计算前缀和，同时维护当前最小前缀和。最大子数组和即为当前前缀和与最小前缀和的差值的最大值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">prefixSum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">minPrefixSum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        prefixSum += nums[i];</span><br><span class="line">        max = Math.max(max, prefixSum - minPrefixSum);</span><br><span class="line">        minPrefixSum = Math.min(minPrefixSum, prefixSum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li><strong>时间复杂度：</strong><code>O(n)</code>，只需一次遍历数组。</li><li><strong>空间复杂度：</strong><code>O(1)</code>，仅使用常数级别的额外空间。</li></ul><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p>定义 <code>dp[i]</code> 表示以 <code>nums[i]</code> 结尾的最大子数组和。状态转移方程为：<code>dp[i] = Math.max(dp[i - 1], 0) + nums[i]</code>。最终结果为 <code>dp</code> 数组中的最大值。可以简单的理解为，如果 <code>nums[i]</code> 左边的子数组和 <code>dp[i - 1] &lt; 0</code>，那么加上 <code>nums[i]</code> 的值会导致子数组和更小，所以这个时候取 <code>nums[i]</code> 的值即可，否则就将 <code>nums[i]</code> 的值加入 <code>dp[i - 1]</code> 的子数组和。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">    dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> dp[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        dp[i] = Math.max(dp[i - <span class="number">1</span>], <span class="number">0</span>) + nums[i];</span><br><span class="line">        max = Math.max(max, dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li><strong>时间复杂度：</strong><code>O(n)</code>，只需一次遍历数组。</li><li><strong>空间复杂度：</strong><code>O(n)</code>，需要额外的 <code>dp</code> 数组存储中间结果。</li></ul><h1 id="动态规划（空间优化）"><a href="#动态规划（空间优化）" class="headerlink" title="动态规划（空间优化）"></a>动态规划（空间优化）</h1><p>在以上动态规划的基础上进行空间优化。由于 <code>dp[i]</code> 只依赖于 <code>dp[i - 1]</code>，因此可以用一个变量代替 <code>dp</code> 数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">dp</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        dp = Math.max(dp, <span class="number">0</span>) + nums[i];</span><br><span class="line">        max = Math.max(max, dp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析-3"><a href="#复杂度分析-3" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li><strong>时间复杂度：</strong><code>O(n)</code>，只需一次遍历数组。</li><li><strong>空间复杂度：</strong><code>O(1)</code>，仅使用常数级别的额外空间。</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><table><thead><tr><th>解法</th><th>时间复杂度</th><th>空间复杂度</th><th>特点</th></tr></thead><tbody><tr><td>暴力枚举</td><td>O(n²)</td><td>O(1)</td><td>思路简单，效率低</td></tr><tr><td>前缀和</td><td>O(n)</td><td>O(1)</td><td>利用前缀和思想</td></tr><tr><td>动态规划</td><td>O(n)</td><td>O(n)</td><td>标准动态规划解法</td></tr><tr><td>动态规划优化</td><td>O(n)</td><td>O(1)</td><td>最优解法，推荐使用</td></tr></tbody></table><h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><blockquote><p><a href="https://leetcode.cn/problems/maximum-subarray/description/" title="53. 最大子数组和 | 力扣（LeetCode）">53. 最大子数组和 | 力扣（LeetCode）</a><br><a href="https://leetcode.cn/problems/maximum-subarray/solutions/2533977/qian-zhui-he-zuo-fa-ben-zhi-shi-mai-mai-abu71/?envType=study-plan-v2&envId=top-100-liked" title="53. 最大子数组和 | 题解 | 灵茶山艾府">53. 最大子数组和 | 题解 | 灵茶山艾府</a></p></blockquote><hr>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;给你一个整数数组 &lt;code&gt;nums&lt;/code&gt; ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;子数组&lt;/strong&gt; 是数组中的一个连续部分。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt;&lt;code&gt;nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]&lt;/code&gt;&lt;br&gt;&lt;strong&gt;输出：&lt;/strong&gt;6&lt;br&gt;&lt;strong&gt;解释：&lt;/strong&gt;连续子数组 &lt;code&gt;[4, -1, 2, 1]&lt;/code&gt; 的和最大，为 &lt;code&gt;6&lt;/code&gt; 。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt;&lt;code&gt;nums = [1]&lt;/code&gt;&lt;br&gt;&lt;strong&gt;输出：&lt;/strong&gt;1&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例 3:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt;&lt;code&gt;nums = [5, 4, -1, 7, 8]&lt;/code&gt;&lt;br&gt;&lt;strong&gt;输出：&lt;/strong&gt;23&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;提示:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= nums.length &amp;lt;= 10^5&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-10^4 &amp;lt;= nums[i] &amp;lt;= 10^4&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://www.cylong.com/categories/LeetCode/"/>
    
    
    <category term="Java" scheme="https://www.cylong.com/tags/Java/"/>
    
    <category term="LeetCode" scheme="https://www.cylong.com/tags/LeetCode/"/>
    
    <category term="学习笔记" scheme="https://www.cylong.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="数组" scheme="https://www.cylong.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="动态规划" scheme="https://www.cylong.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="LeetCode中等" scheme="https://www.cylong.com/tags/LeetCode%E4%B8%AD%E7%AD%89/"/>
    
    <category term="前缀和" scheme="https://www.cylong.com/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    
    <category term="子数组" scheme="https://www.cylong.com/tags/%E5%AD%90%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>和为 K 的子数组</title>
    <link href="https://www.cylong.com/blog/2025/06/05/subarray-sum-equals-k/"/>
    <id>https://www.cylong.com/blog/2025/06/05/subarray-sum-equals-k/</id>
    <published>2025-06-05T15:43:23.000Z</published>
    <updated>2025-06-05T15:43:23.000Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你统计并返回 该数组中和为 <code>k</code> 的子数组的个数 。</p><p><strong>子数组</strong> 是数组中元素的连续非空序列。</p><p><strong>示例 1:</strong></p><blockquote><p><strong>输入：</strong><code>nums = [1, 1, 1]</code>, <code>k = 2</code><br><strong>输出：</strong><code>2</code></p></blockquote><p><strong>示例 2:</strong></p><blockquote><p><strong>输入：</strong><code>nums = [1, 2, 3]</code>, <code>k = 3</code><br><strong>输出：</strong><code>2</code></p></blockquote><p><strong>提示:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 2 * 10^4</code></li><li><code>-1000 &lt;= nums[i] &lt;= 1000</code></li><li><code>-10^7 &lt;= k &lt;= 10^7</code></li></ul><span id="more"></span><h1 id="暴力枚举（双重循环）"><a href="#暴力枚举（双重循环）" class="headerlink" title="暴力枚举（双重循环）"></a>暴力枚举（双重循环）</h1><p>最直观的方法是枚举所有可能的连续子数组，计算它们的和并统计等于 <code>k</code> 的个数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">subarraySum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; nums.length; j++) &#123;</span><br><span class="line">            sum += nums[j];</span><br><span class="line">            <span class="keyword">if</span> (sum == k) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li><strong>时间复杂度：</strong><code>O(n²)</code>，其中 <code>n</code> 是数组长度。外层循环遍历每个元素作为起始点，内层循环遍历从起始点开始的所有子数组。</li><li><strong>空间复杂度：</strong><code>O(1)</code>，只使用了常数级别的额外空间。</li></ul><h1 id="前缀和-哈希表"><a href="#前缀和-哈希表" class="headerlink" title="前缀和 + 哈希表"></a>前缀和 + 哈希表</h1><p>在做这道题之前，我们先看之前做过的两道题：</p><ol><li><a href="/blog/2025/06/03/range-sum-query-immutable/" title="303. 区域和检索 - 数组不可变 | 笑话人生">303. 区域和检索 - 数组不可变 | 笑话人生</a></li><li><a href="/blog/2019/11/06/two-sum/" title="1. 两数之和 | 笑话人生">1. 两数之和 | 笑话人生</a></li></ol><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>利用 <strong>前缀和</strong> 技术优化计算过程：</p><ol><li>计算数组的前缀和数组 <code>prefix</code>，其中：<ul><li><code>prefix[0] = 0</code>，表示空数组的和，用于处理从第一个元素开始的子数组</li><li><code>prefix[i + 1] = nums[0] + nums[1] + ... + nums[i]（i ≥ 0）</code></li></ul></li><li>对于任意子数组 <code>nums[i..j]</code>（包含下标 <code>i</code> 到 <code>j</code>），其和可表示为 <code>prefix[j + 1] - prefix[i]</code></li><li>问题转化为：寻找满足 <code>prefix[j + 1] - prefix[i] = k</code> 且 <code>0 ≤ i &lt; j + 1 ≤ n</code> 的索引对 <code>(i, j)</code> 的数量</li><li>使用哈希表存储每个前缀和出现的次数，遍历时查询 <code>prefix[j] - k</code> 的出现次数并累加（这其实就是上面的两数之和）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">subarraySum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="type">int</span>[] prefix = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 计算前缀和</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        prefix[i + <span class="number">1</span>] = prefix[i] + nums[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 设置容量可以快 2ms</span></span><br><span class="line">    Map&lt;Integer, Integer&gt; countMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> p : prefix) &#123;</span><br><span class="line">        <span class="comment">// 查找前缀和为 p - k 的出现次数</span></span><br><span class="line">        count += countMap.getOrDefault(p - k, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 更新当前前缀和的出现次数</span></span><br><span class="line">        countMap.put(p, countMap.getOrDefault(p, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="示例解析"><a href="#示例解析" class="headerlink" title="示例解析"></a>示例解析</h2><p>以 <code>nums = [1, 1, 1]</code>, <code>k=2</code> 为例：</p><ol><li>前缀和数组：<code>prefix = [0, 1, 2, 3]</code></li><li>遍历过程：<ul><li><code>p=0</code>：查找 <code>-2</code> → 不存在，<code>count=0</code>；更新 <code>map&#123;0:1&#125;</code></li><li><code>p=1</code>：查找 <code>-1</code> → 不存在，<code>count=0</code>；更新 <code>map&#123;0:1, 1:1&#125;</code></li><li><code>p=2</code>：查找 <code>0</code> → 存在1次，<code>count=1</code>；更新 <code>map&#123;0:1, 1:1, 2:1&#125;</code></li><li><code>p=3</code>：查找 <code>1</code> → 存在1次，<code>count=2</code>；更新 <code>map&#123;0:1, 1:1, 2:1, 3:1&#125;</code></li></ul></li><li>返回结果：<code>2</code></li></ol><h2 id="常见问题解答"><a href="#常见问题解答" class="headerlink" title="常见问题解答"></a>常见问题解答</h2><ol><li>为什么需要 <code>prefix[0] = 0</code>？<br>考虑子数组从第一个元素开始的情况：子数组<code> nums[0..j]</code> 的和应为 <code>prefix[j + 1] - prefix[0]</code> 没有 <code>prefix[0]</code> 就无法表示从数组开头开始的子数组</li><li>哈希表如何处理重复前缀和？当不同位置产生相同的前缀和时，哈希表记录出现次数。例如：<ul><li><code>nums = [0, 0, 0]</code>, <code>k=0</code></li><li>前缀和：<code>[0, 0, 0, 0]</code></li><li>遍历时：<ul><li><code>p=0</code>：查找 <code>0</code> → 初始不存在，<code>count=0</code>；记录 <code>0:1</code></li><li><code>p=0</code>：查找 <code>0</code> → 存在1次，<code>count=1</code>；记录 <code>0:2</code></li><li><code>p=0</code>：查找 <code>0</code> → 存在2次，<code>count=3</code>；记录 <code>0:3</code></li><li><code>p=0</code>：查找 <code>0</code> → 存在3次，<code>count=6</code>；记录 <code>0:4</code></li></ul></li><li>返回结果：6（正确对应6个子数组）</li></ul></li></ol><h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li><strong>时间复杂度：</strong><code>O(n)</code>，其中 <code>n</code> 是数组长度。遍历数组两次（计算前缀和和统计子数组数量）。</li><li><strong>空间复杂度：</strong><code>O(n)</code>，哈希表最多存储 <code>n + 1</code> 个键值对。</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li>暴力枚举简单直接，适合小规模数据（<code>n ≤ 1000</code>）</li><li>前缀和 + 哈希表是更高效的通用解法，时间复杂度 <code>O(n)</code>，能处理较大规模数据（<code>n ≤ 2×10⁴</code>）</li><li>实际应用中优先选择方法二，其线性时间复杂度能有效应对常见场景</li><li>关键点在于理解前缀和定义和索引映射关系：子数组和 = <code>prefix[j + 1] - prefix[i]</code></li></ol><h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><blockquote><p><a href="https://leetcode.cn/problems/subarray-sum-equals-k/description/" title="560. 和为 K 的子数组 | 力扣（LeetCode）">560. 和为 K 的子数组 | 力扣（LeetCode）</a><br><a href="https://leetcode.cn/problems/subarray-sum-equals-k/solutions/1/qian-zhui-he-ha-xi-biao-cong-liang-ci-bi-4mwr/?envType=study-plan-v2&envId=top-100-liked" title="560. 和为 K 的子数组 | 题解 | 灵茶山艾府">560. 和为 K 的子数组 | 题解 | 灵茶山艾府</a></p></blockquote><hr>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;给你一个整数数组 &lt;code&gt;nums&lt;/code&gt; 和一个整数 &lt;code&gt;k&lt;/code&gt; ，请你统计并返回 该数组中和为 &lt;code&gt;k&lt;/code&gt; 的子数组的个数 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;子数组&lt;/strong&gt; 是数组中元素的连续非空序列。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt;&lt;code&gt;nums = [1, 1, 1]&lt;/code&gt;, &lt;code&gt;k = 2&lt;/code&gt;&lt;br&gt;&lt;strong&gt;输出：&lt;/strong&gt;&lt;code&gt;2&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt;&lt;code&gt;nums = [1, 2, 3]&lt;/code&gt;, &lt;code&gt;k = 3&lt;/code&gt;&lt;br&gt;&lt;strong&gt;输出：&lt;/strong&gt;&lt;code&gt;2&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;提示:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= nums.length &amp;lt;= 2 * 10^4&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-1000 &amp;lt;= nums[i] &amp;lt;= 1000&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-10^7 &amp;lt;= k &amp;lt;= 10^7&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://www.cylong.com/categories/LeetCode/"/>
    
    
    <category term="Java" scheme="https://www.cylong.com/tags/Java/"/>
    
    <category term="LeetCode" scheme="https://www.cylong.com/tags/LeetCode/"/>
    
    <category term="学习笔记" scheme="https://www.cylong.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="数组" scheme="https://www.cylong.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="哈希表" scheme="https://www.cylong.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
    <category term="LeetCode简单" scheme="https://www.cylong.com/tags/LeetCode%E7%AE%80%E5%8D%95/"/>
    
    <category term="前缀和" scheme="https://www.cylong.com/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    
  </entry>
  
  <entry>
    <title>区域和检索 - 数组不可变</title>
    <link href="https://www.cylong.com/blog/2025/06/03/range-sum-query-immutable/"/>
    <id>https://www.cylong.com/blog/2025/06/03/range-sum-query-immutable/</id>
    <published>2025-06-03T15:20:55.000Z</published>
    <updated>2025-06-03T15:20:55.000Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个整数数组  <code>nums</code>，处理以下类型的多个查询:</p><p>计算索引 <code>left</code> 和 <code>right</code> （包含 <code>left</code> 和 <code>right</code>）之间的 <code>nums</code> 元素的和 ，其中 <code>left &lt;= right</code>。</p><p>实现 <code>NumArray</code> 类：</p><ul><li><code>NumArray(int[] nums)</code> 使用数组 <code>nums</code> 初始化对象</li><li><code>int sumRange(int i, int j)</code> 返回数组 <code>nums</code> 中索引 <code>left</code> 和 <code>right</code> 之间的元素的总和 ，包含 <code>left</code> 和 <code>right</code> 两点（也就是 <code>nums[left] + nums[left + 1] + ... + nums[right]</code> )</li></ul><p><strong>示例 1:</strong></p><blockquote><p><strong>输入：</strong><br><code>[&quot;NumArray&quot;, &quot;sumRange&quot;, &quot;sumRange&quot;, &quot;sumRange&quot;]</code><br><code>[[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]]</code><br><strong>输出：</strong><br><code>[null, 1, -1, -3]</code><br><strong>解释：</strong><br><code>NumArray numArray = new NumArray([-2, 0, 3, -5, 2, -1]);</code><br><code>numArray.sumRange(0, 2); // return 1 ((-2) + 0 + 3)</code><br><code>numArray.sumRange(2, 5); // return -1 (3 + (-5) + 2 + (-1)) </code><br><code>numArray.sumRange(0, 5); // return -3 ((-2) + 0 + 3 + (-5) + 2 + (-1))</code></p></blockquote><p><strong>提示:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 10^4</code></li><li><code>-10^5 &lt;= nums[i] &lt;= 10^5</code></li><li><code>0 &lt;= i &lt;= j &lt; nums.length</code></li><li>最多调用 <code>10*4</code> 次 <code>sumRange</code> 方法</li></ul><span id="more"></span><h1 id="直接计算"><a href="#直接计算" class="headerlink" title="直接计算"></a>直接计算</h1><p>最简单的思路，每次调用 <code>sumRange()</code> 时，直接遍历 <code>left</code> 到 <code>right</code> 的元素并求和。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumArray</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] nums;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NumArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.nums = nums;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumRange</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left; i &lt;= right; i++) &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li><strong>时间复杂度：</strong><code>O(mn)</code>，其中 <code>m</code> 为查询次数，<code>n</code> 为数组长度。</li><li><strong>空间复杂度：</strong><code>O(1)</code>，不考虑存储输入的数组。</li></ul><h1 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h1><p>前缀和是一种高效处理区间求和问题的预处理技术，其核心思想是通过数学变换将区间求和转化为两个端点的差值计算。下面我们通过数学推导详细解释前缀和的工作原理。</p><h2 id="步骤1：定义前缀和数组"><a href="#步骤1：定义前缀和数组" class="headerlink" title="步骤1：定义前缀和数组"></a>步骤1：定义前缀和数组</h2><p>给定数组 <code>nums[0...n-1]</code>，我们定义前缀和数组 <code>prefix</code>：</p><blockquote><p><code>prefix[0] = 0</code><br><code>prefix[1] = nums[0]</code><br><code>prefix[2] = nums[0] + nums[1]</code><br>…<br><code>prefix[i] = nums[0] + nums[1] + ... + nums[i-1]</code><br>…<br><code>prefix[n] = nums[0] + ... + nums[n-1]</code></p></blockquote><h2 id="步骤2：区间和与前缀和的数学关系"><a href="#步骤2：区间和与前缀和的数学关系" class="headerlink" title="步骤2：区间和与前缀和的数学关系"></a>步骤2：区间和与前缀和的数学关系</h2><p>考虑区间 <code>[left, right]</code> 的和：</p><blockquote><p><code>sum(left, right)</code><br><code>= nums[left] + nums[left+1] + ... + nums[right]</code><br><code>= (nums[0] + ... + nums[left-1] + nums[left] + ... + nums[right]) - (nums[0] + ... + nums[left-1])</code><br><code>= prefix[right+1] - prefix[left]</code></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumArray</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] prefix;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NumArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// 多一位存储0位置</span></span><br><span class="line">        prefix = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 递推关系：当前前缀和 = 前一个前缀和 + 当前元素</span></span><br><span class="line">            prefix[i + <span class="number">1</span>] = prefix[i] + nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumRange</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> prefix[right + <span class="number">1</span>] - prefix[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="前缀和的核心优势"><a href="#前缀和的核心优势" class="headerlink" title="前缀和的核心优势"></a>前缀和的核心优势</h2><ol><li><strong>查询高效化：</strong>将 <code>O(n)</code> 的求和操作转化为 <code>O(1)</code> 的差值计算。</li><li><strong>预处理思想：</strong>一次构建多次使用，特别适合查询密集型场景。</li><li><strong>数学简洁性：</strong>通过简单的数组差值实现复杂区间计算。</li></ol><h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li><strong>时间复杂度：</strong><code>O(n)</code>，初始化前缀和数组，其中 <code>n</code> 是数组长度。<code>sumRange</code> 是 <code>O(1)</code>。</li><li><strong>空间复杂度：</strong><code>O(n)</code>，存储前缀和数组。</li></ul><h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><blockquote><p><a href="https://leetcode.cn/problems/range-sum-query-immutable/description/" title="303. 区域和检索 - 数组不可变 | 力扣（LeetCode）">303. 区域和检索 - 数组不可变 | 力扣（LeetCode）</a></p></blockquote><hr>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;给定一个整数数组  &lt;code&gt;nums&lt;/code&gt;，处理以下类型的多个查询:&lt;/p&gt;
&lt;p&gt;计算索引 &lt;code&gt;left&lt;/code&gt; 和 &lt;code&gt;right&lt;/code&gt; （包含 &lt;code&gt;left&lt;/code&gt; 和 &lt;code&gt;right&lt;/code&gt;）之间的 &lt;code&gt;nums&lt;/code&gt; 元素的和 ，其中 &lt;code&gt;left &amp;lt;= right&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;实现 &lt;code&gt;NumArray&lt;/code&gt; 类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;NumArray(int[] nums)&lt;/code&gt; 使用数组 &lt;code&gt;nums&lt;/code&gt; 初始化对象&lt;/li&gt;
&lt;li&gt;&lt;code&gt;int sumRange(int i, int j)&lt;/code&gt; 返回数组 &lt;code&gt;nums&lt;/code&gt; 中索引 &lt;code&gt;left&lt;/code&gt; 和 &lt;code&gt;right&lt;/code&gt; 之间的元素的总和 ，包含 &lt;code&gt;left&lt;/code&gt; 和 &lt;code&gt;right&lt;/code&gt; 两点（也就是 &lt;code&gt;nums[left] + nums[left + 1] + ... + nums[right]&lt;/code&gt; )&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt;&lt;br&gt;&lt;code&gt;[&amp;quot;NumArray&amp;quot;, &amp;quot;sumRange&amp;quot;, &amp;quot;sumRange&amp;quot;, &amp;quot;sumRange&amp;quot;]&lt;/code&gt;&lt;br&gt;&lt;code&gt;[[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]]&lt;/code&gt;&lt;br&gt;&lt;strong&gt;输出：&lt;/strong&gt;&lt;br&gt;&lt;code&gt;[null, 1, -1, -3]&lt;/code&gt;&lt;br&gt;&lt;strong&gt;解释：&lt;/strong&gt;&lt;br&gt;&lt;code&gt;NumArray numArray = new NumArray([-2, 0, 3, -5, 2, -1]);&lt;/code&gt;&lt;br&gt;&lt;code&gt;numArray.sumRange(0, 2); // return 1 ((-2) + 0 + 3)&lt;/code&gt;&lt;br&gt;&lt;code&gt;numArray.sumRange(2, 5); // return -1 (3 + (-5) + 2 + (-1)) &lt;/code&gt;&lt;br&gt;&lt;code&gt;numArray.sumRange(0, 5); // return -3 ((-2) + 0 + 3 + (-5) + 2 + (-1))&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;提示:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= nums.length &amp;lt;= 10^4&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-10^5 &amp;lt;= nums[i] &amp;lt;= 10^5&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0 &amp;lt;= i &amp;lt;= j &amp;lt; nums.length&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;最多调用 &lt;code&gt;10*4&lt;/code&gt; 次 &lt;code&gt;sumRange&lt;/code&gt; 方法&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://www.cylong.com/categories/LeetCode/"/>
    
    
    <category term="Java" scheme="https://www.cylong.com/tags/Java/"/>
    
    <category term="LeetCode" scheme="https://www.cylong.com/tags/LeetCode/"/>
    
    <category term="学习笔记" scheme="https://www.cylong.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="数组" scheme="https://www.cylong.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="LeetCode简单" scheme="https://www.cylong.com/tags/LeetCode%E7%AE%80%E5%8D%95/"/>
    
    <category term="前缀和" scheme="https://www.cylong.com/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    
  </entry>
  
  <entry>
    <title>字母异位词分组</title>
    <link href="https://www.cylong.com/blog/2025/05/30/group-anagrams/"/>
    <id>https://www.cylong.com/blog/2025/05/30/group-anagrams/</id>
    <published>2025-05-29T16:28:11.000Z</published>
    <updated>2025-05-29T16:28:11.000Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给你一个字符串数组，请你将 <strong>字母异位词</strong> 组合在一起。可以按任意顺序返回结果列表。</p><p><strong>字母异位词</strong> 是由重新排列源单词的所有字母得到的一个新单词。</p><p><strong>示例 1:</strong></p><blockquote><p><strong>输入：</strong><code>strs = [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;]</code><br><strong>输出：</strong><code>[[&quot;bat&quot;], [&quot;nat&quot;, &quot;tan&quot;], [&quot;ate&quot;, &quot;eat&quot;, &quot;tea&quot;]]</code></p></blockquote><p><strong>示例 2:</strong></p><blockquote><p><strong>输入：</strong><code>strs = [&quot;&quot;]</code><br><strong>输出：</strong><code>[[&quot;&quot;]]</code></p></blockquote><p><strong>示例 3:</strong></p><blockquote><p><strong>输入：</strong><code>strs = [&quot;a&quot;]</code><br><strong>输出：</strong><code>[[&quot;a&quot;]]</code></p></blockquote><p><strong>提示:</strong></p><ul><li><code>1 &lt;= strs.length &lt;= 104</code></li><li><code>0 &lt;= strs[i].length &lt;= 100</code></li><li><code>strs[i]</code> 仅包含小写字母</li></ul><span id="more"></span><h1 id="排序-哈希表"><a href="#排序-哈希表" class="headerlink" title="排序 + 哈希表"></a>排序 + 哈希表</h1><p>字母异位词指字母相同，但排列不同的字符串。所以对每个字符串排序，将排序后的字符串作为 <code>key</code>，原字符串添加到该 <code>key</code> 对应的列表中。（如 <code>&quot;eat&quot;</code> 和 <code>&quot;tea&quot;</code> 的 <code>key</code> 都为 <code>&quot;aet&quot;</code>）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">groupAnagrams</span><span class="params">(String[] strs)</span> &#123;</span><br><span class="line">    Map&lt;String, List&lt;String&gt;&gt; resultMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String str : strs) &#123;</span><br><span class="line">        <span class="type">char</span>[] chars = str.toCharArray();</span><br><span class="line">        Arrays.sort(chars);</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(chars);</span><br><span class="line">        <span class="keyword">if</span> (!resultMap.containsKey(key)) &#123;</span><br><span class="line">            resultMap.put(key, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        resultMap.get(key).add(str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(resultMap.values());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li><strong>时间复杂度：</strong><code>O(nk logk)</code>，假设有 <code>n</code> 个字符串，每个字符串最大长度为 <code>k</code>。排序每个字符串的时间复杂度为<code>O(k logk)</code>，所以总时间复杂度为<code>O(nk logk)</code>。</li><li><strong>空间复杂度：</strong><code>O(nk)</code>，哈希表存储所有字符串（最坏情况无重复 <code>key</code>）。</li></ul><h1 id="字符计数-哈希表"><a href="#字符计数-哈希表" class="headerlink" title="字符计数 + 哈希表"></a>字符计数 + 哈希表</h1><p>字母异位词指字母相同，但排列不同的字符串，所以，每个字符串里字母的数量是相等的，故可以统计每个字符串中每个字符出现的次数，然后生成一个表示字符频次的字符串作为 <code>key</code>（例如：<code>&quot;a1b2&quot;</code>），然后将原字符串添加到该 <code>key</code> 对应的列表中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">groupAnagrams</span><span class="params">(String[] strs)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] count = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">    Map&lt;String, List&lt;String&gt;&gt; resultMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String str : strs) &#123;</span><br><span class="line">        Arrays.fill(count, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : str.toCharArray()) &#123;</span><br><span class="line">            <span class="comment">// 统计每个字符出现的次数</span></span><br><span class="line">            count[c - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 拼接每个字符出现的次数，作为 Map 的 key</span></span><br><span class="line">            <span class="keyword">if</span> (count[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                sb.append((<span class="type">char</span>) (<span class="string">&#x27;a&#x27;</span> + i));</span><br><span class="line">                sb.append(count[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> sb.toString();</span><br><span class="line">        <span class="keyword">if</span> (!resultMap.containsKey(key)) &#123;</span><br><span class="line">            resultMap.put(key, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        resultMap.get(key).add(str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 入参：[&quot;eatt&quot;, &quot;teat&quot;, &quot;tan&quot;, &quot;atet&quot;, &quot;nat&quot;, &quot;bat&quot;]</span></span><br><span class="line">    <span class="comment">// resultMap 结果为：&#123;a1b1t1=[bat], a1n1t1=[tan, nat], a1e1t2=[eatt, teat, atet]&#125;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(resultMap.values());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li><strong>时间复杂度：</strong><code>O(nk)</code>，哈希表存储所有字符串（最坏情况无重复 key）。</li><li><strong>空间复杂度：</strong><code>O(1)</code>。</li></ul><h1 id="关键结论"><a href="#关键结论" class="headerlink" title="关键结论"></a>关键结论</h1><ul><li><strong>排序 + 哈希表：</strong>代码简洁，但排序开销随字符串变长而增大。</li><li><strong>计数 + 哈希表：</strong>避免排序，通过字符频次编码更高效处理长字符串。</li><li><strong>实际选择：</strong>若字符串平均长度小，选方法一；若长度大，选方法二。</li></ul><p>通过哈希表将字母异位词映射到相同 <code>key</code>，两种方法均能高效解决分组问题！</p><h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><blockquote><p><a href="https://leetcode.cn/problems/group-anagrams/description/" title="49. 字母异位词分组 | 力扣（LeetCode）">49. 字母异位词分组 | 力扣（LeetCode）</a></p></blockquote><hr>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;给你一个字符串数组，请你将 &lt;strong&gt;字母异位词&lt;/strong&gt; 组合在一起。可以按任意顺序返回结果列表。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;字母异位词&lt;/strong&gt; 是由重新排列源单词的所有字母得到的一个新单词。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt;&lt;code&gt;strs = [&amp;quot;eat&amp;quot;, &amp;quot;tea&amp;quot;, &amp;quot;tan&amp;quot;, &amp;quot;ate&amp;quot;, &amp;quot;nat&amp;quot;, &amp;quot;bat&amp;quot;]&lt;/code&gt;&lt;br&gt;&lt;strong&gt;输出：&lt;/strong&gt;&lt;code&gt;[[&amp;quot;bat&amp;quot;], [&amp;quot;nat&amp;quot;, &amp;quot;tan&amp;quot;], [&amp;quot;ate&amp;quot;, &amp;quot;eat&amp;quot;, &amp;quot;tea&amp;quot;]]&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt;&lt;code&gt;strs = [&amp;quot;&amp;quot;]&lt;/code&gt;&lt;br&gt;&lt;strong&gt;输出：&lt;/strong&gt;&lt;code&gt;[[&amp;quot;&amp;quot;]]&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例 3:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt;&lt;code&gt;strs = [&amp;quot;a&amp;quot;]&lt;/code&gt;&lt;br&gt;&lt;strong&gt;输出：&lt;/strong&gt;&lt;code&gt;[[&amp;quot;a&amp;quot;]]&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;提示:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= strs.length &amp;lt;= 104&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0 &amp;lt;= strs[i].length &amp;lt;= 100&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;strs[i]&lt;/code&gt; 仅包含小写字母&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://www.cylong.com/categories/LeetCode/"/>
    
    
    <category term="Java" scheme="https://www.cylong.com/tags/Java/"/>
    
    <category term="LeetCode" scheme="https://www.cylong.com/tags/LeetCode/"/>
    
    <category term="学习笔记" scheme="https://www.cylong.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="数组" scheme="https://www.cylong.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="哈希表" scheme="https://www.cylong.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
    <category term="字符串" scheme="https://www.cylong.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    <category term="排序" scheme="https://www.cylong.com/tags/%E6%8E%92%E5%BA%8F/"/>
    
    <category term="LeetCode中等" scheme="https://www.cylong.com/tags/LeetCode%E4%B8%AD%E7%AD%89/"/>
    
  </entry>
  
  <entry>
    <title>分类求和并作差</title>
    <link href="https://www.cylong.com/blog/2025/05/28/divisible-and-non-divisible-sums-difference/"/>
    <id>https://www.cylong.com/blog/2025/05/28/divisible-and-non-divisible-sums-difference/</id>
    <published>2025-05-27T16:19:46.000Z</published>
    <updated>2025-05-27T16:19:46.000Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给你两个正整数 <code>n</code> 和 <code>m</code> 。现定义两个整数 <code>num1</code> 和 <code>num2</code> ，如下所示：</p><p><code>num1</code>：范围 <code>[1, n]</code> 内所有 无法被 <code>m</code> 整除 的整数之和。<br><code>num2</code>：范围 <code>[1, n]</code> 内所有 能够被 <code>m</code> 整除 的整数之和。</p><p>返回整数 <code>num1 - num2</code> 。</p><p><strong>示例 1:</strong></p><blockquote><p><strong>输入：</strong>n = 10, m = 3<br><strong>输出：</strong>19<br><strong>解释：</strong>在这个示例中：<br>范围 <code>[1, 10]</code> 内无法被 3 整除的整数为 <code>[1, 2, 4, 5, 7, 8, 10]</code> ，num1 = 这些整数之和 = 37 。<br>范围 <code>[1, 10]</code> 内能够被 3 整除的整数为 <code>[3, 6, 9]</code> ，num2 = 这些整数之和 = 18 。<br>返回 37 - 18 = 19 作为答案。</p></blockquote><p><strong>示例 2:</strong></p><blockquote><p><strong>输入：</strong>n = 5, m = 6<br><strong>输出：</strong>15<br><strong>解释：</strong>在这个示例中：<br>范围 <code>[1, 5]</code> 内无法被 6 整除的整数为 <code>[1, 2, 3, 4, 5]</code> ，num1 = 这些整数之和 =  15 。<br>范围 <code>[1, 5]</code> 内能够被 6 整除的整数为 <code>[]</code> ，num2 = 这些整数之和 = 0 。<br>返回 15 - 0 = 15 作为答案。</p></blockquote><p><strong>示例 3:</strong></p><blockquote><p><strong>输入：</strong>n = 5, m = 1<br><strong>输出：</strong>-15<br><strong>解释：</strong>在这个示例中：<br>范围 <code>[1, 5]</code> 内无法被 1 整除的整数为 <code>[]</code> ，num1 = 这些整数之和 = 0 。<br>范围 <code>[1, 5]</code> 内能够被 1 整除的整数为 <code>[1, 2, 3, 4, 5]</code> ，num2 = 这些整数之和 = 15 。<br>返回 0 - 15 = -15 作为答案。</p></blockquote><p><strong>提示:</strong></p><ul><li><code>1 &lt;= n, m &lt;= 1000</code></li></ul><span id="more"></span><h1 id="普通遍历"><a href="#普通遍历" class="headerlink" title="普通遍历"></a>普通遍历</h1><p>最直观方法遍历 <code>1</code> 到 <code>n</code> 的每个数，分别累加能被 <code>m</code> 整除的数的和 <code>sum_div</code> 和不能整除的数的和 <code>sum_non_div</code> ，最后返回 <code>sum_non_div - sum_div</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">differenceOfSums</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum_div</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum_non_div</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i % m == <span class="number">0</span>) &#123;</span><br><span class="line">            sum_div += i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sum_non_div += i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sum_non_div - sum_div;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li><strong>时间复杂度：</strong><code>O(n)</code>，需遍历 <code>1</code> 到 <code>n</code> 的所有数。</li><li><strong>空间复杂度：</strong><code>O(1)</code>，仅使用常数空间。</li></ul><h1 id="数学公式"><a href="#数学公式" class="headerlink" title="数学公式"></a>数学公式</h1><p>利用数学公式直接计算，避免遍历：</p><ol><li>总和：<code>1</code> 到 <code>n</code> 的和为 <code>total = n * (n + 1) / 2</code>。</li><li>整除和：能被 <code>m</code> 整除的数形如 <code>m, 2m, 3m, ..., km</code>（其中 <code>k = n / m</code>），和为 <code>m * (k * (k + 1) / 2)</code>。</li><li>差值：非整除和 - 整除和 = <code>(total - sum_div) - sum_div = total - 2 * sum_div</code>。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">differenceOfSums</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span> &#123;</span><br><span class="line">    <span class="comment">// 计算 1 到 n 的总和</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">total</span> <span class="operator">=</span> (<span class="type">long</span>) n * (n + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 计算可整除数的个数k</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> n / m;</span><br><span class="line">    <span class="comment">// 可整除数的和</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">divisibleSum</span> <span class="operator">=</span> (<span class="type">long</span>) m * k * (k + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 返回差值</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int</span>) (total - <span class="number">2</span> * divisibleSum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li><strong>时间复杂度：</strong><code>O(1)</code>。</li><li><strong>空间复杂度：</strong><code>O(1)</code>。</li></ul><h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><blockquote><p><a href="https://leetcode.cn/problems/divisible-and-non-divisible-sums-difference/description/" title="2894. 分类求和并作差 | 力扣（LeetCode）">2894. 分类求和并作差 | 力扣（LeetCode）</a></p></blockquote><hr>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;给你两个正整数 &lt;code&gt;n&lt;/code&gt; 和 &lt;code&gt;m&lt;/code&gt; 。现定义两个整数 &lt;code&gt;num1&lt;/code&gt; 和 &lt;code&gt;num2&lt;/code&gt; ，如下所示：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;num1&lt;/code&gt;：范围 &lt;code&gt;[1, n]&lt;/code&gt; 内所有 无法被 &lt;code&gt;m&lt;/code&gt; 整除 的整数之和。&lt;br&gt;&lt;code&gt;num2&lt;/code&gt;：范围 &lt;code&gt;[1, n]&lt;/code&gt; 内所有 能够被 &lt;code&gt;m&lt;/code&gt; 整除 的整数之和。&lt;/p&gt;
&lt;p&gt;返回整数 &lt;code&gt;num1 - num2&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt;n = 10, m = 3&lt;br&gt;&lt;strong&gt;输出：&lt;/strong&gt;19&lt;br&gt;&lt;strong&gt;解释：&lt;/strong&gt;在这个示例中：&lt;br&gt;范围 &lt;code&gt;[1, 10]&lt;/code&gt; 内无法被 3 整除的整数为 &lt;code&gt;[1, 2, 4, 5, 7, 8, 10]&lt;/code&gt; ，num1 = 这些整数之和 = 37 。&lt;br&gt;范围 &lt;code&gt;[1, 10]&lt;/code&gt; 内能够被 3 整除的整数为 &lt;code&gt;[3, 6, 9]&lt;/code&gt; ，num2 = 这些整数之和 = 18 。&lt;br&gt;返回 37 - 18 = 19 作为答案。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt;n = 5, m = 6&lt;br&gt;&lt;strong&gt;输出：&lt;/strong&gt;15&lt;br&gt;&lt;strong&gt;解释：&lt;/strong&gt;在这个示例中：&lt;br&gt;范围 &lt;code&gt;[1, 5]&lt;/code&gt; 内无法被 6 整除的整数为 &lt;code&gt;[1, 2, 3, 4, 5]&lt;/code&gt; ，num1 = 这些整数之和 =  15 。&lt;br&gt;范围 &lt;code&gt;[1, 5]&lt;/code&gt; 内能够被 6 整除的整数为 &lt;code&gt;[]&lt;/code&gt; ，num2 = 这些整数之和 = 0 。&lt;br&gt;返回 15 - 0 = 15 作为答案。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例 3:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt;n = 5, m = 1&lt;br&gt;&lt;strong&gt;输出：&lt;/strong&gt;-15&lt;br&gt;&lt;strong&gt;解释：&lt;/strong&gt;在这个示例中：&lt;br&gt;范围 &lt;code&gt;[1, 5]&lt;/code&gt; 内无法被 1 整除的整数为 &lt;code&gt;[]&lt;/code&gt; ，num1 = 这些整数之和 = 0 。&lt;br&gt;范围 &lt;code&gt;[1, 5]&lt;/code&gt; 内能够被 1 整除的整数为 &lt;code&gt;[1, 2, 3, 4, 5]&lt;/code&gt; ，num2 = 这些整数之和 = 15 。&lt;br&gt;返回 0 - 15 = -15 作为答案。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;提示:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= n, m &amp;lt;= 1000&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://www.cylong.com/categories/LeetCode/"/>
    
    
    <category term="Java" scheme="https://www.cylong.com/tags/Java/"/>
    
    <category term="LeetCode" scheme="https://www.cylong.com/tags/LeetCode/"/>
    
    <category term="学习笔记" scheme="https://www.cylong.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="数学公式" scheme="https://www.cylong.com/tags/%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/"/>
    
    <category term="LeetCode简单" scheme="https://www.cylong.com/tags/LeetCode%E7%AE%80%E5%8D%95/"/>
    
  </entry>
  
  <entry>
    <title>连接两字母单词得到的最长回文串</title>
    <link href="https://www.cylong.com/blog/2025/05/25/longest-palindrome-by-concatenating-two-letter-words/"/>
    <id>https://www.cylong.com/blog/2025/05/25/longest-palindrome-by-concatenating-two-letter-words/</id>
    <published>2025-05-25T13:31:32.000Z</published>
    <updated>2025-05-25T13:31:32.000Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给你一个字符串数组 <code>words</code> 。<code>words</code> 中每个元素都是一个包含两个小写英文字母的单词。请你从 <code>words</code> 中选择一些元素并按任意顺序连接它们，并得到一个尽可能长的回文串 。每个元素至多只能使用一次。请你返回你能得到的最长回文串的长度 。如果没办法得到任何一个回文串，请你返回 <code>0</code> 。</p><p><strong>说明:</strong> 回文串指的是从前往后和从后往前读一样的字符串。</p><p><strong>示例 1:</strong></p><blockquote><p><strong>输入：</strong><code>words = [&quot;lc&quot;, &quot;cl&quot;, &quot;gg&quot;]</code><br><strong>输出：</strong>6<br><strong>解释：</strong>一个最长的回文串为 <code>&quot;lc&quot; + &quot;gg&quot; + &quot;cl&quot; = &quot;lcggcl&quot;</code> ，长度为 6 。<code>&quot;clgglc&quot;</code> 是另一个可以得到的最长回文串。</p></blockquote><p><strong>示例 2:</strong></p><blockquote><p><strong>输入：</strong><code>words = [&quot;ab&quot;, &quot;ty&quot;, &quot;yt&quot;, &quot;lc&quot;, &quot;cl&quot;, &quot;ab&quot;]</code><br><strong>输出：</strong>8<br><strong>解释：</strong>最长回文串是 <code>&quot;ty&quot; + &quot;lc&quot; + &quot;cl&quot; + &quot;yt&quot; = &quot;tylcclyt&quot;</code> ，长度为 8 。<code>&quot;lcyttycl&quot;</code> 是另一个可以得到的最长回文串。</p></blockquote><p><strong>示例 3:</strong></p><blockquote><p><strong>输入：</strong><code>words = [&quot;cc&quot;, &quot;ll&quot;, &quot;xx&quot;]</code><br><strong>输出：</strong>2<br><strong>解释：</strong>最长回文串是 <code>&quot;cc&quot;</code> ，长度为 2 。<code>&quot;ll&quot;</code> 是另一个可以得到的最长回文串。<code>&quot;xx&quot;</code> 也是。</p></blockquote><p><strong>提示:</strong></p><ul><li><code>1 &lt;= words.length &lt;= 10^5</code></li><li><code>words[i].length == 2</code></li><li><code>words[i]</code> 仅包含小写英文字母。</li></ul><span id="more"></span><h1 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h1><ol><li>统计单词出现次数：使用哈希表记录每个单词的出现次数。</li><li>处理互为反转的单词对：对于每个单词，检查其反转是否存在。若存在，取两者出现次数的较小值，每对贡献 <code>4</code> 个字符（每个单词长度为 <code>2</code> ）。</li><li>处理对称单词：对于两个字符相同的单词（如 <code>&quot;aa&quot;</code>），可以成对使用（贡献 <code>4</code> 个字符），若有剩余且未使用中间点，可单独作为中间对称点（贡献 <code>2</code> 个字符）。</li><li>避免重复处理：使用集合记录已处理的单词，确保每对单词只处理一次。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestPalindrome</span><span class="params">(String[] words)</span> &#123;</span><br><span class="line">    <span class="comment">// 记录最长回文长度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">maxLen</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 标记是否已使用中间对称点</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">center</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 记录已处理的单词</span></span><br><span class="line">    List&lt;String&gt; processed = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 使用 HashMap 统计每个单词的出现次数</span></span><br><span class="line">    Map&lt;String, Integer&gt; wordCount = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 记录所有 word 的次数</span></span><br><span class="line">    Arrays.stream(words).forEach(word -&gt; wordCount.put(word, wordCount.getOrDefault(word, <span class="number">0</span>) + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (String word : wordCount.keySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (processed.contains(word)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> wordCount.get(word);</span><br><span class="line">        <span class="type">String</span> <span class="variable">reversed</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(word).reverse().toString();</span><br><span class="line">        <span class="comment">// 若单词字符相同（如&quot;aa&quot;），计算可成对使用的次数，剩余次数作为中间对称点。</span></span><br><span class="line">        <span class="keyword">if</span> (word.equals(reversed)) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">pairs</span> <span class="operator">=</span> count / <span class="number">2</span>;</span><br><span class="line">            maxLen += pairs * <span class="number">4</span>;</span><br><span class="line">            <span class="keyword">if</span> (!center &amp;&amp; count % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">                maxLen += <span class="number">2</span>;</span><br><span class="line">                center = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            processed.add(word);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 找到反转单词，取较小次数计算贡献，避免重复处理。</span></span><br><span class="line">            <span class="keyword">if</span> (wordCount.containsKey(reversed)) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">reversedCount</span> <span class="operator">=</span> wordCount.get(reversed);</span><br><span class="line">                <span class="type">int</span> <span class="variable">pairs</span> <span class="operator">=</span> Math.min(count, reversedCount);</span><br><span class="line">                maxLen += pairs * <span class="number">4</span>;</span><br><span class="line">                processed.add(word);</span><br><span class="line">                processed.add(reversed);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxLen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li><strong>时间复杂度：</strong><code>O(n)</code>，遍历 <code>words</code> 数组并构建哈希表 <code>wordCount</code>，时间复杂度为 <code>O(n)</code>，遍历哈希表的键集合，假设不同的单词数量为 <code>m</code>，每个单词的处理包括生成反转字符串、哈希表查询等操作。由于每个单词长度为 <code>2</code>，生成反转字符串和哈希表操作均为 <code>O(1)</code>，总时间复杂度为 <code>O(m)</code>。最坏情况下，所有单词均不同（即 <code>m = n</code>），时间复杂度为 <code>O(n)</code>。其中 <code>n</code> 是数组长度。</li><li><strong>空间复杂度：</strong><code>O(n)</code>，<code>wordCount</code> 存储所有单词及其频率，占用 <code>O(m)</code> 空间。<code>processed</code> 集合存储已处理的单词，需要 <code>O(m)</code> 空间。总体空间复杂度：<code>O(m)</code>，即 <code>O(n)</code>（<code>m</code> 最大为 <code>n</code>）。</li></ul><h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><blockquote><p><a href="https://leetcode.cn/problems/longest-palindrome-by-concatenating-two-letter-words/description/" title="2131. 连接两字母单词得到的最长回文串 | 力扣（LeetCode）">2131. 连接两字母单词得到的最长回文串 | 力扣（LeetCode）</a></p></blockquote><hr>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;给你一个字符串数组 &lt;code&gt;words&lt;/code&gt; 。&lt;code&gt;words&lt;/code&gt; 中每个元素都是一个包含两个小写英文字母的单词。请你从 &lt;code&gt;words&lt;/code&gt; 中选择一些元素并按任意顺序连接它们，并得到一个尽可能长的回文串 。每个元素至多只能使用一次。请你返回你能得到的最长回文串的长度 。如果没办法得到任何一个回文串，请你返回 &lt;code&gt;0&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说明:&lt;/strong&gt; 回文串指的是从前往后和从后往前读一样的字符串。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt;&lt;code&gt;words = [&amp;quot;lc&amp;quot;, &amp;quot;cl&amp;quot;, &amp;quot;gg&amp;quot;]&lt;/code&gt;&lt;br&gt;&lt;strong&gt;输出：&lt;/strong&gt;6&lt;br&gt;&lt;strong&gt;解释：&lt;/strong&gt;一个最长的回文串为 &lt;code&gt;&amp;quot;lc&amp;quot; + &amp;quot;gg&amp;quot; + &amp;quot;cl&amp;quot; = &amp;quot;lcggcl&amp;quot;&lt;/code&gt; ，长度为 6 。&lt;code&gt;&amp;quot;clgglc&amp;quot;&lt;/code&gt; 是另一个可以得到的最长回文串。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt;&lt;code&gt;words = [&amp;quot;ab&amp;quot;, &amp;quot;ty&amp;quot;, &amp;quot;yt&amp;quot;, &amp;quot;lc&amp;quot;, &amp;quot;cl&amp;quot;, &amp;quot;ab&amp;quot;]&lt;/code&gt;&lt;br&gt;&lt;strong&gt;输出：&lt;/strong&gt;8&lt;br&gt;&lt;strong&gt;解释：&lt;/strong&gt;最长回文串是 &lt;code&gt;&amp;quot;ty&amp;quot; + &amp;quot;lc&amp;quot; + &amp;quot;cl&amp;quot; + &amp;quot;yt&amp;quot; = &amp;quot;tylcclyt&amp;quot;&lt;/code&gt; ，长度为 8 。&lt;code&gt;&amp;quot;lcyttycl&amp;quot;&lt;/code&gt; 是另一个可以得到的最长回文串。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例 3:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt;&lt;code&gt;words = [&amp;quot;cc&amp;quot;, &amp;quot;ll&amp;quot;, &amp;quot;xx&amp;quot;]&lt;/code&gt;&lt;br&gt;&lt;strong&gt;输出：&lt;/strong&gt;2&lt;br&gt;&lt;strong&gt;解释：&lt;/strong&gt;最长回文串是 &lt;code&gt;&amp;quot;cc&amp;quot;&lt;/code&gt; ，长度为 2 。&lt;code&gt;&amp;quot;ll&amp;quot;&lt;/code&gt; 是另一个可以得到的最长回文串。&lt;code&gt;&amp;quot;xx&amp;quot;&lt;/code&gt; 也是。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;提示:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= words.length &amp;lt;= 10^5&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;words[i].length == 2&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;words[i]&lt;/code&gt; 仅包含小写英文字母。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://www.cylong.com/categories/LeetCode/"/>
    
    
    <category term="Java" scheme="https://www.cylong.com/tags/Java/"/>
    
    <category term="LeetCode" scheme="https://www.cylong.com/tags/LeetCode/"/>
    
    <category term="学习笔记" scheme="https://www.cylong.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="贪心算法" scheme="https://www.cylong.com/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
    <category term="LeetCode中等" scheme="https://www.cylong.com/tags/LeetCode%E4%B8%AD%E7%AD%89/"/>
    
  </entry>
  
  <entry>
    <title>最长回文子串</title>
    <link href="https://www.cylong.com/blog/2025/05/24/longest-palindromic-substring/"/>
    <id>https://www.cylong.com/blog/2025/05/24/longest-palindromic-substring/</id>
    <published>2025-05-24T04:02:04.000Z</published>
    <updated>2025-05-24T04:02:04.000Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的 <strong>回文子串</strong>。</p><p><strong>说明:</strong></p><ul><li>如果字符串向前和向后读都相同，则它满足回文性。</li><li>子字符串是字符串中连续的非空字符序列。</li></ul><p><strong>示例 1:</strong></p><blockquote><p><strong>输入：</strong><code>s = &quot;babad&quot;</code><br><strong>输出：</strong><code>&quot;bab&quot;</code><br><strong>解释：</strong><code>&quot;aba&quot;</code> 同样是符合题意的答案。</p></blockquote><p><strong>示例 2:</strong></p><blockquote><p><strong>输入：</strong><code>s = &quot;cbbd&quot;</code><br><strong>输出：</strong><code>&quot;bb&quot;</code></p></blockquote><p><strong>提示:</strong></p><ul><li><code>1 &lt;= s.length &lt;= 1000</code></li><li><code>s</code> 仅由数字和英文字母组成</li></ul><span id="more"></span><h1 id="暴力法（不推荐）"><a href="#暴力法（不推荐）" class="headerlink" title="暴力法（不推荐）"></a>暴力法（不推荐）</h1><p>枚举所有子串，检查是否为回文，记录最长的一个。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">longestPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">null</span> || s.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxLen</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; s.length(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (longestPalindrome(s, i, j) &amp;&amp; (j - i + <span class="number">1</span> &gt; maxLen)) &#123;</span><br><span class="line">                maxLen = j - i + <span class="number">1</span>;</span><br><span class="line">                start = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.substring(start, start + maxLen);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">longestPalindrome</span><span class="params">(String s, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(start++) != s.charAt(end--)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li><strong>时间复杂度：</strong><code>O(n³)</code>，共有 <code>O(n²)</code> 个子串（两层循环：<code>i</code> 从 <code>0</code> 到 <code>n-1</code>，<code>j</code> 从 <code>i</code> 到 <code>n-1</code>）。每个子串检查是否为回文需要 <code>O(n)</code> 时间（如长度为 <code>k</code> 的子串需比较 <code>k/2</code> 次）。<br>总时间 = <code>O(n²) × O(n) = O(n³)</code>。</li><li><strong>空间复杂度：</strong><code>O(n)</code>，仅需常数空间存储临时变量（如 <code>maxLen</code>, <code>start</code>）。</li></ul><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p>利用二维数组 <code>dp[i][j]</code> 记录子串 <code>s[i...j]</code> 是否为回文，逐步扩展长度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">longestPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">null</span> || s.length() &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.length();</span><br><span class="line">    <span class="type">boolean</span>[][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[len][len];</span><br><span class="line">    <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxLen</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 长度为1的子串全都是回文串</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        dp[i][i] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断长度为2的子串是否是回文串</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.charAt(i) == s.charAt(i + <span class="number">1</span>)) &#123;</span><br><span class="line">            dp[i][i + <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">            start = i;</span><br><span class="line">            maxLen = <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断长度为3及更长的子串是否是回文串</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">3</span>; l &lt;= len; l++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len - l + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + l - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(i) == s.charAt(j) &amp;&amp; dp[i + <span class="number">1</span>][j - <span class="number">1</span>]) &#123;</span><br><span class="line">                dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                start = i;</span><br><span class="line">                maxLen = l;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> s.substring(start, start + maxLen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li><strong>时间复杂度：</strong><code>O(n²)</code>，外层循环遍历子串长度 <code>l</code>（从 <code>3</code> 到 <code>n</code>），内层循环遍历起始点 <code>i</code>，总时间 = <code>O(n²)</code>。</li><li><strong>空间复杂度：</strong><code>O(n²)</code>，需一个二维数组 <code>dp[n][n]</code> 存储所有子串的状态。</li></ul><h1 id="中心扩展法"><a href="#中心扩展法" class="headerlink" title="中心扩展法"></a>中心扩展法</h1><p>以每个字符或每两个字符为中心，向两侧扩展寻找最长回文。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">longestPalindrome1</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">null</span> || s.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">        <span class="comment">// 奇数长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len1</span> <span class="operator">=</span> expand(s, i, i);</span><br><span class="line">        <span class="comment">// 偶数长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len2</span> <span class="operator">=</span> expand(s, i, i + <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> Math.max(len1, len2);</span><br><span class="line">        <span class="keyword">if</span> (len &gt; end - start) &#123;</span><br><span class="line">            start = i - (len - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            end = i + len / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s.substring(start, end + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">expand</span><span class="params">(String s, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; right &lt; s.length() &amp;&amp; s.charAt(left) == s.charAt(right)) &#123;</span><br><span class="line">        left--;</span><br><span class="line">        right++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> right - left - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li><strong>时间复杂度：</strong><code>O(n²)</code>，共有 <code>2n-1</code> 个中心（每个字符作为奇中心，每两个字符之间作为偶中心），每个中心最多扩展 <code>O(n)</code> 次（如全相同字符时，扩展到边界）。<br>总时间 = <code>O(2n) × O(n) = O(n²)</code>。</li><li><strong>空间复杂度：</strong><code>O(1)</code>，仅需常数空间记录扩展的左右指针和最长回文的起止点。</li></ul><h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><blockquote><p><a href="https://leetcode.cn/problems/longest-palindromic-substring/" title="5. 最长回文子串 | 力扣（LeetCode）">5. 最长回文子串 | 力扣（LeetCode）</a></p></blockquote><hr>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;给你一个字符串 &lt;code&gt;s&lt;/code&gt;，找到 &lt;code&gt;s&lt;/code&gt; 中最长的 &lt;strong&gt;回文子串&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说明:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果字符串向前和向后读都相同，则它满足回文性。&lt;/li&gt;
&lt;li&gt;子字符串是字符串中连续的非空字符序列。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt;&lt;code&gt;s = &amp;quot;babad&amp;quot;&lt;/code&gt;&lt;br&gt;&lt;strong&gt;输出：&lt;/strong&gt;&lt;code&gt;&amp;quot;bab&amp;quot;&lt;/code&gt;&lt;br&gt;&lt;strong&gt;解释：&lt;/strong&gt;&lt;code&gt;&amp;quot;aba&amp;quot;&lt;/code&gt; 同样是符合题意的答案。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt;&lt;code&gt;s = &amp;quot;cbbd&amp;quot;&lt;/code&gt;&lt;br&gt;&lt;strong&gt;输出：&lt;/strong&gt;&lt;code&gt;&amp;quot;bb&amp;quot;&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;提示:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= s.length &amp;lt;= 1000&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;s&lt;/code&gt; 仅由数字和英文字母组成&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://www.cylong.com/categories/LeetCode/"/>
    
    
    <category term="Java" scheme="https://www.cylong.com/tags/Java/"/>
    
    <category term="LeetCode" scheme="https://www.cylong.com/tags/LeetCode/"/>
    
    <category term="学习笔记" scheme="https://www.cylong.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="字符串" scheme="https://www.cylong.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    <category term="动态规划" scheme="https://www.cylong.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="LeetCode中等" scheme="https://www.cylong.com/tags/LeetCode%E4%B8%AD%E7%AD%89/"/>
    
  </entry>
  
  <entry>
    <title>找到字符串中所有字母异位词</title>
    <link href="https://www.cylong.com/blog/2025/03/02/find-all-anagrams-in-a-string/"/>
    <id>https://www.cylong.com/blog/2025/03/02/find-all-anagrams-in-a-string/</id>
    <published>2025-03-02T15:00:44.000Z</published>
    <updated>2025-03-02T15:00:44.000Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定两个字符串 <code>s</code> 和 <code>p</code>，找到 <code>s</code> 中所有 <code>p</code> 的 <strong>异位词</strong> 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。</p><p><strong>字母异位词</strong> 是通过重新排列不同单词或短语的字母而形成的单词或短语，并使用所有原字母一次。</p><p><strong>示例 1:</strong></p><blockquote><p><strong>输入：</strong><code>s = &quot;cbaebabacd&quot;</code>, <code>p = &quot;abc&quot;</code><br><strong>输出：</strong><code>[0, 6]</code><br><strong>解释:</strong><br>起始索引等于 <code>0</code> 的子串是 <code>&quot;cba&quot;</code>, 它是 <code>&quot;abc&quot;</code> 的异位词。<br>起始索引等于 <code>6</code> 的子串是 <code>&quot;bac&quot;</code>, 它是 <code>&quot;abc&quot;</code> 的异位词。</p></blockquote><p><strong>示例 2:</strong></p><blockquote><p><strong>输入：</strong><code>s = &quot;abab&quot;</code>, <code>p = &quot;ab&quot;</code><br><strong>输出：</strong><code>[0, 1, 2]</code><br><strong>解释:</strong><br>起始索引等于 <code>0</code> 的子串是 <code>&quot;ab&quot;</code>, 它是 <code>&quot;ab&quot;</code> 的异位词。<br>起始索引等于 <code>1</code> 的子串是 <code>&quot;ba&quot;</code>, 它是 <code>&quot;ab&quot;</code> 的异位词。<br>起始索引等于 <code>2</code> 的子串是 <code>&quot;ab&quot;</code>, 它是 <code>&quot;ab&quot;</code> 的异位词。</p></blockquote><p><strong>提示:</strong></p><ul><li><code>1 &lt;= s.length</code>, <code>p.length &lt;= 3 * 10^4</code></li><li><code>s</code> 和 <code>p</code> 仅包含小写字母</li></ul><span id="more"></span><h1 id="固定窗口滑动-计数数组"><a href="#固定窗口滑动-计数数组" class="headerlink" title="固定窗口滑动 + 计数数组"></a>固定窗口滑动 + 计数数组</h1><ol><li><strong>初始化处理：</strong></li></ol><ul><li>若 <code>s</code> 长度小于 <code>p</code>，直接返回空列表。</li><li>创建两个长度为 <code>26</code> 的数组 <code>pCount</code> 和 <code>sCount</code>，分别统计 <code>p</code> 的字符频次和 <code>s</code> 中前 <code>p.length()</code> 个字符的频次。</li></ul><ol start="2"><li><strong>首次匹配检查：</strong></li></ol><ul><li>比较 <code>pCount</code> 和 <code>sCount</code>，若相等说明起始索引 <code>0</code> 是异位词，加入结果列表。</li></ul><ol start="3"><li><strong>滑动窗口：</strong></li></ol><ul><li>窗口长度固定为 <code>p.length()</code>，每次右移一位：<ul><li>移除窗口最左侧字符（对应频次减 <code>1</code>）。</li><li>加入窗口右侧新字符（对应频次加 <code>1</code>）。</li></ul></li><li>每次窗口移动后，比较 <code>pCount</code> 和 <code>sCount</code>，若相等则记录当前窗口起始索引（<code>i + 1</code>）。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">findAnagrams</span><span class="params">(String s, String p)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">null</span> || p == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">sLen</span> <span class="operator">=</span> s.length();</span><br><span class="line">    <span class="type">int</span> <span class="variable">pLen</span> <span class="operator">=</span> p.length();</span><br><span class="line">    <span class="keyword">if</span> (sLen &lt; pLen) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 统计 p 和 s 的前 pLen 个字符出现的次数，如果相等，则说明是异位词</span></span><br><span class="line">    <span class="type">int</span>[] pCount = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="type">int</span>[] sCount = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; pLen; i++) &#123;</span><br><span class="line">        pCount[p.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        sCount[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;Integer&gt; anagrams = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (Arrays.equals(pCount, sCount)) &#123;</span><br><span class="line">        anagrams.add(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定长滑动窗口，每次移动一个字符，判断是否是异位词</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length() - p.length(); i++) &#123;</span><br><span class="line">        sCount[s.charAt(i) - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">        sCount[s.charAt(i + p.length()) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        <span class="keyword">if</span> (Arrays.equals(pCount, sCount)) &#123;</span><br><span class="line">            anagrams.add(i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> anagrams;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li><strong>时间复杂度：</strong><code>O(26n)</code>，其中 <code>n</code> 是 <code>s</code> 的长度。因为每次窗口移动后，我们都要比较两个长度为 <code>26</code> 的数组（<code>Arrays.equals</code> 内部会循环 <code>26</code> 次）。</li><li><strong>空间复杂度：</strong><code>O(1)</code>，固定使用两个长度为 <code>26</code> 的数组（常数空间）。</li></ul><h1 id="不固定窗口滑动-计数数组"><a href="#不固定窗口滑动-计数数组" class="headerlink" title="不固定窗口滑动 + 计数数组"></a>不固定窗口滑动 + 计数数组</h1><p>以下参考大佬的解法：<a href="https://leetcode.cn/problems/find-all-anagrams-in-a-string/solutions/1/liang-chong-fang-fa-ding-chang-hua-chuan-14pd/" title="438. 找到字符串中所有字母异位词 | 题解 | 灵茶山艾府">438. 找到字符串中所有字母异位词 | 题解 | 灵茶山艾府</a></p><ol><li><strong>频次数组预处理：</strong></li></ol><ul><li>统计 <code>p</code> 的字符频次到数组 <code>pCount</code>。</li></ul><ol start="2"><li><strong>双指针滑动窗口：</strong></li></ol><ul><li>使用双指针 <code>left</code> 和 <code>right</code>，<code>right</code> 向右移动，将遇到的字符在 <code>pCount</code> 中减 <code>1</code>（相当于进入窗口）。</li><li>如果某个字符在 <code>pCount</code> 中的值小于 <code>0</code>，说明当前窗口中这个字符的数量超过了 <code>p</code> 中该字符的数量，或者 <code>p</code> 中根本没有这个字符。那么就需要移动 <code>left</code> 指针，将 <code>left</code> 指向的字符在 <code>pCount</code> 中加 <code>1</code>（相当于移出窗口），直到 <code>pCount[c]</code> 不再小于 <code>0</code>（即调整到当前字符数量正常）。</li><li>当窗口长度（<code>right - left + 1</code>）等于 <code>p</code> 的长度时，说明我们找到了一个异位词子串，将 <code>left</code> 加入结果列表。</li></ul><p><strong>注意：</strong>这种方法中，<code>pCount</code> 数组被复用，我们通过加减操作来维护窗口内字符的计数。当窗口长度等于 <code>p</code> 的长度时，由于我们保证了窗口内每个字符的出现次数都不超过 <code>p</code> 中的出现次数（通过 <code>while</code> 循环调整），并且窗口长度恰好等于 <code>p</code> 的长度，那么窗口内的字符串必然是 <code>p</code> 的一个异位词。因为如果窗口内某个字符的出现次数大于 <code>p</code> 中的出现次数，我们会通过 <code>left</code> 右移来减少它，直到它等于 <code>p</code> 中的出现次数（即不再为负）。而当窗口长度等于 <code>p</code> 的长度时，每个字符的出现次数恰好等于 <code>p</code> 中的出现次数（因为如果少了，那么 <code>pCount</code> 中对应的值应该是正数，但我们的操作中，进入窗口减 <code>1</code>，移出窗口加 <code>1</code>，并且我们保证了没有负值，所以每个字符都不多不少）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">findAnagrams</span><span class="params">(String s, String p)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; anagrams = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 统计 p 的每种字母的出现次数</span></span><br><span class="line">    <span class="type">int</span>[] pCount = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c : p.toCharArray()) &#123;</span><br><span class="line">        pCount[c - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>; right &lt; s.length(); right++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(right) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="comment">// 右端点字母进入窗口</span></span><br><span class="line">        pCount[c]--;</span><br><span class="line">        <span class="comment">// 字母 c 太多了，left右移，直到窗口中字母 c 的出现次数为 0</span></span><br><span class="line">        <span class="keyword">while</span> (pCount[c] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            pCount[s.charAt(left) - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// s&#x27; 和 p 的每种字母的出现次数都相同</span></span><br><span class="line">        <span class="keyword">if</span> (right - left + <span class="number">1</span> == p.length()) &#123;</span><br><span class="line">            <span class="comment">// s&#x27; 左端点下标加入答案</span></span><br><span class="line">            anagrams.add(left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> anagrams;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li><strong>时间复杂度：</strong><code>O(m + n)</code>，其中 <code>m</code> 是 <code>s</code> 的长度，<code>n</code> 是 <code>p</code> 的长度。虽然写了个二重循环，但是内层循环中对 <code>left</code> 加一的总执行次数不会超过 <code>m</code> 次，所以滑窗的时间复杂度为 <code>O(m)</code>。</li><li><strong>空间复杂度：</strong><code>O(1)</code>，使用固定大小的数组（ <code>26</code> 个整数）。</li></ul><h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><blockquote><p><a href="https://leetcode.cn/problems/find-all-anagrams-in-a-string/description/" title="438. 找到字符串中所有字母异位词 | 力扣（LeetCode）">438. 找到字符串中所有字母异位词 | 力扣（LeetCode）</a></p></blockquote><hr>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;给定两个字符串 &lt;code&gt;s&lt;/code&gt; 和 &lt;code&gt;p&lt;/code&gt;，找到 &lt;code&gt;s&lt;/code&gt; 中所有 &lt;code&gt;p&lt;/code&gt; 的 &lt;strong&gt;异位词&lt;/strong&gt; 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;字母异位词&lt;/strong&gt; 是通过重新排列不同单词或短语的字母而形成的单词或短语，并使用所有原字母一次。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt;&lt;code&gt;s = &amp;quot;cbaebabacd&amp;quot;&lt;/code&gt;, &lt;code&gt;p = &amp;quot;abc&amp;quot;&lt;/code&gt;&lt;br&gt;&lt;strong&gt;输出：&lt;/strong&gt;&lt;code&gt;[0, 6]&lt;/code&gt;&lt;br&gt;&lt;strong&gt;解释:&lt;/strong&gt;&lt;br&gt;起始索引等于 &lt;code&gt;0&lt;/code&gt; 的子串是 &lt;code&gt;&amp;quot;cba&amp;quot;&lt;/code&gt;, 它是 &lt;code&gt;&amp;quot;abc&amp;quot;&lt;/code&gt; 的异位词。&lt;br&gt;起始索引等于 &lt;code&gt;6&lt;/code&gt; 的子串是 &lt;code&gt;&amp;quot;bac&amp;quot;&lt;/code&gt;, 它是 &lt;code&gt;&amp;quot;abc&amp;quot;&lt;/code&gt; 的异位词。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt;&lt;code&gt;s = &amp;quot;abab&amp;quot;&lt;/code&gt;, &lt;code&gt;p = &amp;quot;ab&amp;quot;&lt;/code&gt;&lt;br&gt;&lt;strong&gt;输出：&lt;/strong&gt;&lt;code&gt;[0, 1, 2]&lt;/code&gt;&lt;br&gt;&lt;strong&gt;解释:&lt;/strong&gt;&lt;br&gt;起始索引等于 &lt;code&gt;0&lt;/code&gt; 的子串是 &lt;code&gt;&amp;quot;ab&amp;quot;&lt;/code&gt;, 它是 &lt;code&gt;&amp;quot;ab&amp;quot;&lt;/code&gt; 的异位词。&lt;br&gt;起始索引等于 &lt;code&gt;1&lt;/code&gt; 的子串是 &lt;code&gt;&amp;quot;ba&amp;quot;&lt;/code&gt;, 它是 &lt;code&gt;&amp;quot;ab&amp;quot;&lt;/code&gt; 的异位词。&lt;br&gt;起始索引等于 &lt;code&gt;2&lt;/code&gt; 的子串是 &lt;code&gt;&amp;quot;ab&amp;quot;&lt;/code&gt;, 它是 &lt;code&gt;&amp;quot;ab&amp;quot;&lt;/code&gt; 的异位词。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;提示:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= s.length&lt;/code&gt;, &lt;code&gt;p.length &amp;lt;= 3 * 10^4&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;s&lt;/code&gt; 和 &lt;code&gt;p&lt;/code&gt; 仅包含小写字母&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://www.cylong.com/categories/LeetCode/"/>
    
    
    <category term="Java" scheme="https://www.cylong.com/tags/Java/"/>
    
    <category term="LeetCode" scheme="https://www.cylong.com/tags/LeetCode/"/>
    
    <category term="学习笔记" scheme="https://www.cylong.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="哈希表" scheme="https://www.cylong.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
    <category term="字符串" scheme="https://www.cylong.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    <category term="滑动窗口" scheme="https://www.cylong.com/tags/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/"/>
    
    <category term="LeetCode中等" scheme="https://www.cylong.com/tags/LeetCode%E4%B8%AD%E7%AD%89/"/>
    
  </entry>
  
  <entry>
    <title>移动零</title>
    <link href="https://www.cylong.com/blog/2025/03/01/move-zeroes/"/>
    <id>https://www.cylong.com/blog/2025/03/01/move-zeroes/</id>
    <published>2025-03-01T13:59:48.000Z</published>
    <updated>2025-03-01T13:59:48.000Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p><p><strong>请注意，</strong>必须在不复制数组的情况下原地对数组进行操作。</p><p><strong>示例 1:</strong></p><blockquote><p><strong>输入：</strong><code>nums = [0, 1, 0, 3, 12]</code><br><strong>输出：</strong><code>[1, 3, 12, 0, 0]</code></p></blockquote><p><strong>示例 2:</strong></p><blockquote><p><strong>输入：</strong><code>nums = [0]</code><br><strong>输出：</strong><code>[0]</code></p></blockquote><p><strong>提示:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 10^4</code></li><li><code>-2^31 &lt;= nums[i] &lt;= 2^31 - 1</code></li></ul><span id="more"></span><h1 id="双指针（交换法）"><a href="#双指针（交换法）" class="headerlink" title="双指针（交换法）"></a>双指针（交换法）</h1><p>使用两个指针，<code>left</code> 和 <code>right</code>，<code>right</code> 指针用于遍历数组，<code>left</code> 指针用于指向当前已经处理好的序列的尾部（即非零序列的末尾，也就是下一个非零元素要放置的位置）。当 <code>right</code> 指针遇到非零元素时，就将其与 <code>left</code> 指针指向的元素交换，然后 <code>left</code> 指针右移。这样，非零元素被逐渐交换到前面，而 <code>0</code> 被交换到后面。</p><p><strong>注意：</strong>交换后，<code>left</code> 指向的位置可能是 <code>0</code>（如果之前 <code>left</code> 指向的是 <code>0</code>）或者非零（如果 <code>left</code> 和 <code>right</code> 相同，即自己交换自己，此时不会改变），但无论如何，<code>left</code> 指针的左侧都是非零元素，并且保持了原有顺序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">moveZeroes</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">0</span>; right &lt; nums.length; right++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[right] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 避免不必要的自交换</span></span><br><span class="line">            <span class="keyword">if</span> (left != right) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[left];</span><br><span class="line">                nums[left] = nums[right];</span><br><span class="line">                nums[right] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 数组变化过程</span></span><br><span class="line">    <span class="comment">// 输入：[0, 1, 0, 3, 12]</span></span><br><span class="line">    <span class="comment">// [0, 1, 0, 3, 12]</span></span><br><span class="line">    <span class="comment">// [1, 0, 0, 3, 12]</span></span><br><span class="line">    <span class="comment">// [1, 0, 0, 3, 12]</span></span><br><span class="line">    <span class="comment">// [1, 3, 0, 0, 12]</span></span><br><span class="line">    <span class="comment">// [1, 3, 12, 0, 0]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行过程（以 <code>[0, 1, 0, 3, 12]</code> 为例）<br><code>[0, 1, 0, 3, 12]</code> - <code>right=0: 0</code> → 跳过<br><code>[1, 0, 0, 3, 12]</code> - <code>right=1: 1</code> → 与 <code>left(0)</code> 交换<br><code>[1, 0, 0, 3, 12]</code> - <code>right=2: 0</code> → 跳过<br><code>[1, 3, 0, 0, 12]</code> - <code>right=3: 3</code> → 与 <code>left(1)</code> 交换<br><code>[1, 3, 12, 0, 0]</code> - <code>right=4: 12</code> → 与 <code>left(2)</code> 交换</p><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li><strong>时间复杂度：</strong><code>O(n)</code>，只需一次遍历数组。</li><li><strong>空间复杂度：</strong><code>O(1)</code>，原地操作，仅使用常数空间。</li></ul><h1 id="双指针（覆盖法）"><a href="#双指针（覆盖法）" class="headerlink" title="双指针（覆盖法）"></a>双指针（覆盖法）</h1><p>使用一个指针 <code>cur</code>，表示当前非零元素应该存放的位置。遍历数组，当遇到非零元素时，将其复制到 <code>cur</code> 位置，然后 <code>cur</code> 指针右移。遍历完成后，所有非零元素都被按顺序移动到了数组的前部，然后将 <code>cur</code> 之后的元素全部置为 <code>0</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">moveZeroes</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 第一阶段：移动非零元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] != <span class="number">0</span>) &#123;</span><br><span class="line">            nums[cur++] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 第二阶段：填充零</span></span><br><span class="line">    <span class="keyword">while</span> (cur &lt; nums.length) &#123;</span><br><span class="line">        nums[cur++] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 数组变化过程</span></span><br><span class="line">    <span class="comment">// 输入：[0, 1, 0, 3, 12]</span></span><br><span class="line">    <span class="comment">// [0, 1, 0, 3, 12]</span></span><br><span class="line">    <span class="comment">// [1, 0, 0, 3, 12]</span></span><br><span class="line">    <span class="comment">// [1, 0, 0, 3, 12]</span></span><br><span class="line">    <span class="comment">// [1, 3, 0, 0, 12]</span></span><br><span class="line">    <span class="comment">// [1, 3, 12, 0, 0]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行过程（以 <code>[0, 1, 0, 3, 12]</code> 为例）</p><p><strong>第一阶段：</strong></p><ul><li><code>i=0: 0</code> → 跳过</li><li><code>i=1: 1</code> → <code>nums[0]=1</code> (<code>cur=1</code>)</li><li><code>i=2: 0</code> → 跳过</li><li><code>i=3: 3</code> → <code>nums[1]=3</code> (<code>cur=2</code>)</li><li><code>i=4: 12</code> → <code>nums[2]=12</code> (<code>cur=3</code>)</li></ul><p><strong>第二阶段：</strong></p><ul><li>填充 <code>nums[3]=0</code>, <code>nums[4]=0</code></li><li>结果: <code>[1, 3, 12, 0, 0]</code></li></ul><h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li><strong>时间复杂度：</strong><code>O(n)</code>，两次独立遍历数组。</li><li><strong>空间复杂度：</strong><code>O(1)</code>，原地操作，仅使用常数空间。</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>两种方法都有效地解决了移动零的问题：</p><ol><li>交换法更高效，单次遍历完成操作，代码更简洁</li><li>覆盖法写操作更少，但需要两次遍历</li></ol><p>在实际应用中，交换法通常是更优选择，因为它只需要一次遍历且代码更简洁。理解这两种双指针策略有助于解决类似的数组重排问题，如移除指定元素、删除排序数组中的重复项等。</p><h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><blockquote><p><a href="https://leetcode.cn/problems/move-zeroes/description/" title="283. 移动零 | 力扣（LeetCode）">283. 移动零 | 力扣（LeetCode）</a></p></blockquote><hr>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;给定一个数组 &lt;code&gt;nums&lt;/code&gt;，编写一个函数将所有 &lt;code&gt;0&lt;/code&gt; 移动到数组的末尾，同时保持非零元素的相对顺序。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;请注意，&lt;/strong&gt;必须在不复制数组的情况下原地对数组进行操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt;&lt;code&gt;nums = [0, 1, 0, 3, 12]&lt;/code&gt;&lt;br&gt;&lt;strong&gt;输出：&lt;/strong&gt;&lt;code&gt;[1, 3, 12, 0, 0]&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt;&lt;code&gt;nums = [0]&lt;/code&gt;&lt;br&gt;&lt;strong&gt;输出：&lt;/strong&gt;&lt;code&gt;[0]&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;提示:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= nums.length &amp;lt;= 10^4&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-2^31 &amp;lt;= nums[i] &amp;lt;= 2^31 - 1&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://www.cylong.com/categories/LeetCode/"/>
    
    
    <category term="Java" scheme="https://www.cylong.com/tags/Java/"/>
    
    <category term="LeetCode" scheme="https://www.cylong.com/tags/LeetCode/"/>
    
    <category term="学习笔记" scheme="https://www.cylong.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="数组" scheme="https://www.cylong.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="双指针" scheme="https://www.cylong.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
    <category term="LeetCode简单" scheme="https://www.cylong.com/tags/LeetCode%E7%AE%80%E5%8D%95/"/>
    
  </entry>
  
  <entry>
    <title>连接两棵树后最大目标节点数目 Ⅰ</title>
    <link href="https://www.cylong.com/blog/2025/02/28/maximize-the-number-of-target-nodes-after-connecting-trees-i/"/>
    <id>https://www.cylong.com/blog/2025/02/28/maximize-the-number-of-target-nodes-after-connecting-trees-i/</id>
    <published>2025-02-28T14:52:11.000Z</published>
    <updated>2025-02-28T14:52:11.000Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>有两棵 <strong>无向树</strong>，分别有 <code>n</code> 和 <code>m</code> 个树节点。两棵树中的节点编号分别为 <code>[0, n - 1]</code> 和 <code>[0, m - 1]</code> 中的整数。</p><p>给你两个二维整数 <code>edges1</code> 和 <code>edges2</code> ，长度分别为 <code>n - 1</code> 和 <code>m - 1</code> ，其中 <code>edges1[i] = [ai, bi]</code> 表示第一棵树中节点 <code>ai</code> 和 <code>bi</code> 之间有一条边，<code>edges2[i] = [ui, vi]</code> 表示第二棵树中节点 <code>ui</code> 和 <code>vi</code> 之间有一条边。同时给你一个整数 <code>k</code> 。如果节点 <code>u</code> 和节点 <code>v</code> 之间路径的边数小于等于 <code>k</code> ，那么我们称节点 <code>u</code> 是节点 <code>v</code> 的 <strong>目标节点</strong> 。一个节点一定是它自己的 <strong>目标节点</strong> 。</p><p>请你返回一个长度为 <code>n</code> 的整数数组 <code>answer</code> ，<code>answer[i]</code> 表示将第一棵树中的一个节点与第二棵树中的一个节点连接一条边后，第一棵树中节点 <code>i</code> 的目标节点数目的最大值 。</p><p><strong>注意：</strong>每个查询相互独立。意味着进行下一次查询之前，你需要先把刚添加的边给删掉。</p><p><strong>示例 1:</strong></p><blockquote><p><strong>输入：</strong><code>edges1 = [[0, 1], [0, 2], [2, 3], [2, 4]], edges2 = [[0, 1], [0, 2], [0, 3], [2, 7], [1, 4], [4, 5], [4, 6]]</code>, <code>k = 2</code><br><strong>输出：</strong><code>[9, 7, 9, 8, 8]</code><br><strong>解释：</strong></p><ul><li>对于 <code>i = 0</code> ，连接第一棵树中的节点 0 和第二棵树中的节点 0 。</li><li>对于 <code>i = 1</code> ，连接第一棵树中的节点 1 和第二棵树中的节点 0 。</li><li>对于 <code>i = 2</code> ，连接第一棵树中的节点 2 和第二棵树中的节点 4 。</li><li>对于 <code>i = 3</code> ，连接第一棵树中的节点 3 和第二棵树中的节点 4 。</li><li>对于 <code>i = 4</code> ，连接第一棵树中的节点 4 和第二棵树中的节点 4 。</li></ul></blockquote><img src="/blog/2025/02/28/maximize-the-number-of-target-nodes-after-connecting-trees-i/3372-1.png" class=""><p><strong>示例 2:</strong></p><blockquote><p><strong>输入：</strong><code>edges1 = [[0, 1], [0, 2], [0, 3], [0, 4]], edges2 = [[0, 1], [1, 2], [2, 3]]</code>, <code>k = 1</code><br><strong>输出：</strong><code>[6, 3, 3, 3, 3]</code><br><strong>解释：</strong>对于每个 <code>i</code> ，连接第一棵树中的节点 <code>i</code> 和第二棵树中的任意一个节点。</p></blockquote><img src="/blog/2025/02/28/maximize-the-number-of-target-nodes-after-connecting-trees-i/3372-2.png" class=""><p><strong>提示:</strong></p><ul><li><code>2 &lt;= n, m &lt;= 1000</code></li><li><code>edges1.length == n - 1</code></li><li><code>edges2.length == m - 1</code></li><li><code>edges1[i].length == edges2[i].length == 2</code></li><li><code>edges1[i] = [ai, bi]</code></li><li><code>0 &lt;= ai, bi &lt; n</code></li><li><code>edges2[i] = [ui, vi]</code></li><li><code>0 &lt;= ui, vi &lt; m</code></li><li>输入保证 <code>edges1</code> 和 <code>edges2</code> 都表示合法的树。</li><li><code>0 &lt;= k &lt;= 1000</code></li></ul><span id="more"></span><h1 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h1><ol><li><strong>第一棵树内部目标节点计算：</strong>对于第一棵树中的每个节点 <code>i</code>，计算在不添加新边的情况下，距离 <code>i</code> 不超过 <code>k</code> 的节点数（包括自身）。这部分节点不受添加边的影响，因为新边连接的是另一棵树。</li><li><strong>第二棵树内部目标节点计算：</strong>对于第二棵树中的每个节点 <code>j</code>，计算距离 <code>j</code> 不超过 <code>k-1</code> 的节点数（包括自身）。这是因为添加边后，从第一棵树节点 <code>i</code> 到第二棵树节点 <code>v</code> 的路径为 <code>i → a → b → v</code>，其中 <code>a</code> 和 <code>b</code> 是添加边的两个端点，路径长度为 <code>d1(i, a) + 1 + d2(b, v)</code>。为最大化第二棵树部分的贡献，选择 <code>a = i</code>（即连接点选在 <code>i</code>），这样路径长度简化为 <code>1 + d2(b, v)</code>。因此，第二棵树部分最多贡献距离 <code>b</code> 不超过 <code>k-1</code> 的节点数。</li><li><strong>最大化第二棵树贡献：</strong>取第二棵树中所有节点在距离 <code>k-1</code> 内节点数的最大值 <code>maxCount2</code>。</li><li><strong>合并结果：</strong>对于第一棵树中的每个节点 <code>i</code>，其目标节点最大值为 <code>count1[i] + maxCount2</code>，其中 <code>count1[i]</code> 是第一棵树内部距离 <code>i</code> 不超过 <code>k</code> 的节点数。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] maxTargetNodes(<span class="type">int</span>[][] edges1, <span class="type">int</span>[][] edges2, <span class="type">int</span> k) &#123;</span><br><span class="line">    <span class="comment">// 计算第一课无向树中每个节点的目标节点数</span></span><br><span class="line">    <span class="type">int</span>[] count1 = count(edges1, k);</span><br><span class="line">    <span class="comment">// 计算第一课无向树中每个节点的目标节点数</span></span><br><span class="line">    <span class="type">int</span>[] count2 = count(edges2, k - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 计算第二课无向树中每个节点的目标节点数的最大值</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">maxCount2</span> <span class="operator">=</span> Arrays.stream(count2).max().orElse(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> edges1.length + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        result[i] = count1[i] + maxCount2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] count(<span class="type">int</span>[][] edges, <span class="type">int</span> k) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> edges.length + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 构建无向树</span></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        graph.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span>[] edge : edges) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> edge[<span class="number">0</span>], v = edge[<span class="number">1</span>];</span><br><span class="line">        graph.get(u).add(v);</span><br><span class="line">        graph.get(v).add(u);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        result[i] = dfs(i, -<span class="number">1</span>, graph, k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> parent, List&lt;List&lt;Integer&gt;&gt; graph, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (k &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> v : graph.get(u)) &#123;</span><br><span class="line">        <span class="comment">// 防止回溯到父节点，避免无限递归和重复计数</span></span><br><span class="line">        <span class="keyword">if</span> (v == parent) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        count += dfs(v, u, graph, k - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li><strong>时间复杂度：</strong><code>O(n² + m²)</code>，其中 <code>n</code> 和 <code>m</code> 分别是两棵树的节点数。计算 <code>count1</code> 和 <code>count2</code> 时，对每个节点进行 BFS，每次 BFS 最坏 <code>O(n)</code> 或 <code>O(m)</code>，总时间复杂度为 <code>O(n²)</code> 和 <code>O(m²)</code>。</li><li><strong>空间复杂度：</strong><code>O(n + m)</code>，用于存储树的邻接表 <code>O(n + m)</code> 和 BFS 的队列及访问标记 <code>O(n)</code> 或 <code>O(m)</code>。</li></ul><h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><blockquote><p><a href="https://leetcode.cn/problems/maximize-the-number-of-target-nodes-after-connecting-trees-i/description/" title="3372. 连接两棵树后最大目标节点数目 Ⅰ | 力扣（LeetCode）">3372. 连接两棵树后最大目标节点数目 Ⅰ | 力扣（LeetCode）</a></p></blockquote><hr>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;有两棵 &lt;strong&gt;无向树&lt;/strong&gt;，分别有 &lt;code&gt;n&lt;/code&gt; 和 &lt;code&gt;m&lt;/code&gt; 个树节点。两棵树中的节点编号分别为 &lt;code&gt;[0, n - 1]&lt;/code&gt; 和 &lt;code&gt;[0, m - 1]&lt;/code&gt; 中的整数。&lt;/p&gt;
&lt;p&gt;给你两个二维整数 &lt;code&gt;edges1&lt;/code&gt; 和 &lt;code&gt;edges2&lt;/code&gt; ，长度分别为 &lt;code&gt;n - 1&lt;/code&gt; 和 &lt;code&gt;m - 1&lt;/code&gt; ，其中 &lt;code&gt;edges1[i] = [ai, bi]&lt;/code&gt; 表示第一棵树中节点 &lt;code&gt;ai&lt;/code&gt; 和 &lt;code&gt;bi&lt;/code&gt; 之间有一条边，&lt;code&gt;edges2[i] = [ui, vi]&lt;/code&gt; 表示第二棵树中节点 &lt;code&gt;ui&lt;/code&gt; 和 &lt;code&gt;vi&lt;/code&gt; 之间有一条边。同时给你一个整数 &lt;code&gt;k&lt;/code&gt; 。如果节点 &lt;code&gt;u&lt;/code&gt; 和节点 &lt;code&gt;v&lt;/code&gt; 之间路径的边数小于等于 &lt;code&gt;k&lt;/code&gt; ，那么我们称节点 &lt;code&gt;u&lt;/code&gt; 是节点 &lt;code&gt;v&lt;/code&gt; 的 &lt;strong&gt;目标节点&lt;/strong&gt; 。一个节点一定是它自己的 &lt;strong&gt;目标节点&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;请你返回一个长度为 &lt;code&gt;n&lt;/code&gt; 的整数数组 &lt;code&gt;answer&lt;/code&gt; ，&lt;code&gt;answer[i]&lt;/code&gt; 表示将第一棵树中的一个节点与第二棵树中的一个节点连接一条边后，第一棵树中节点 &lt;code&gt;i&lt;/code&gt; 的目标节点数目的最大值 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;每个查询相互独立。意味着进行下一次查询之前，你需要先把刚添加的边给删掉。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt;&lt;code&gt;edges1 = [[0, 1], [0, 2], [2, 3], [2, 4]], edges2 = [[0, 1], [0, 2], [0, 3], [2, 7], [1, 4], [4, 5], [4, 6]]&lt;/code&gt;, &lt;code&gt;k = 2&lt;/code&gt;&lt;br&gt;&lt;strong&gt;输出：&lt;/strong&gt;&lt;code&gt;[9, 7, 9, 8, 8]&lt;/code&gt;&lt;br&gt;&lt;strong&gt;解释：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于 &lt;code&gt;i = 0&lt;/code&gt; ，连接第一棵树中的节点 0 和第二棵树中的节点 0 。&lt;/li&gt;
&lt;li&gt;对于 &lt;code&gt;i = 1&lt;/code&gt; ，连接第一棵树中的节点 1 和第二棵树中的节点 0 。&lt;/li&gt;
&lt;li&gt;对于 &lt;code&gt;i = 2&lt;/code&gt; ，连接第一棵树中的节点 2 和第二棵树中的节点 4 。&lt;/li&gt;
&lt;li&gt;对于 &lt;code&gt;i = 3&lt;/code&gt; ，连接第一棵树中的节点 3 和第二棵树中的节点 4 。&lt;/li&gt;
&lt;li&gt;对于 &lt;code&gt;i = 4&lt;/code&gt; ，连接第一棵树中的节点 4 和第二棵树中的节点 4 。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;img src=&quot;/blog/2025/02/28/maximize-the-number-of-target-nodes-after-connecting-trees-i/3372-1.png&quot; class=&quot;&quot;&gt;

&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt;&lt;code&gt;edges1 = [[0, 1], [0, 2], [0, 3], [0, 4]], edges2 = [[0, 1], [1, 2], [2, 3]]&lt;/code&gt;, &lt;code&gt;k = 1&lt;/code&gt;&lt;br&gt;&lt;strong&gt;输出：&lt;/strong&gt;&lt;code&gt;[6, 3, 3, 3, 3]&lt;/code&gt;&lt;br&gt;&lt;strong&gt;解释：&lt;/strong&gt;对于每个 &lt;code&gt;i&lt;/code&gt; ，连接第一棵树中的节点 &lt;code&gt;i&lt;/code&gt; 和第二棵树中的任意一个节点。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;img src=&quot;/blog/2025/02/28/maximize-the-number-of-target-nodes-after-connecting-trees-i/3372-2.png&quot; class=&quot;&quot;&gt;

&lt;p&gt;&lt;strong&gt;提示:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;2 &amp;lt;= n, m &amp;lt;= 1000&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;edges1.length == n - 1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;edges2.length == m - 1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;edges1[i].length == edges2[i].length == 2&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;edges1[i] = [ai, bi]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0 &amp;lt;= ai, bi &amp;lt; n&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;edges2[i] = [ui, vi]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0 &amp;lt;= ui, vi &amp;lt; m&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;输入保证 &lt;code&gt;edges1&lt;/code&gt; 和 &lt;code&gt;edges2&lt;/code&gt; 都表示合法的树。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0 &amp;lt;= k &amp;lt;= 1000&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://www.cylong.com/categories/LeetCode/"/>
    
    
    <category term="Java" scheme="https://www.cylong.com/tags/Java/"/>
    
    <category term="LeetCode" scheme="https://www.cylong.com/tags/LeetCode/"/>
    
    <category term="学习笔记" scheme="https://www.cylong.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="树" scheme="https://www.cylong.com/tags/%E6%A0%91/"/>
    
    <category term="深度优先搜索" scheme="https://www.cylong.com/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
    <category term="LeetCode中等" scheme="https://www.cylong.com/tags/LeetCode%E4%B8%AD%E7%AD%89/"/>
    
    <category term="无向树" scheme="https://www.cylong.com/tags/%E6%97%A0%E5%90%91%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>不同的二叉搜索树</title>
    <link href="https://www.cylong.com/blog/2025/02/17/unique-binary-search-trees/"/>
    <id>https://www.cylong.com/blog/2025/02/17/unique-binary-search-trees/</id>
    <published>2025-02-17T14:22:45.000Z</published>
    <updated>2025-02-17T14:22:45.000Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给你一个整数 <code>n</code> ，求恰由 <code>n</code> 个节点组成且节点值从 <code>1</code> 到 <code>n</code> 互不相同的 <strong>二叉搜索树</strong> 有多少种？返回满足题意的二叉搜索树的种数。</p><p><strong>示例 1:</strong></p><img src="/blog/2025/02/17/unique-binary-search-trees/uniquebstn3.jpg" class="" title="二叉搜索树"><blockquote><p><strong>输入：</strong>n = 3<br><strong>输出：</strong>5</p></blockquote><p><strong>示例 2:</strong></p><blockquote><p><strong>输入：</strong>n = 1<br><strong>输出：</strong>1</p></blockquote><p><strong>提示:</strong></p><ul><li><code>1 &lt;= n &lt;= 19</code></li></ul><span id="more"></span><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p>二叉搜索树的特点是，对于每个节点来说，左子树的所有节点的值都小于它，右子树的所有节点的值都大于它。为了求解由 <code>n</code> 个节点组成的二叉搜索树的数量，可以使用动态规划的方法。二叉搜索树的中序遍历是有序的，因此结构数目仅与节点数量有关。</p><p>假设以 <code>i</code> 为根节点，那么左子树由 <code>1</code> 到 <code>i-1</code> 组成，共有 <code>i-1</code> 个节点，右子树由 <code>i+1</code> 到 <code>n</code> 组成，共有 <code>n-i</code> 个节点。所以，以 <code>i</code> 为根的 BST 数目等于左子树的数目乘以右子树的数目。设 <code>G(n)</code> 为 <code>n</code> 个节点组成的 BST 数目，以不同根节点划分左右子树，总数目为左右子树数目的乘积之和。递推公式：<code>G(n) = G(0)G(n-1) + G(1)G(n-2) + ... + G(n-1)G(0)</code>，其中 <code>G(0)=1</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numTrees</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 遍历计算 dp[1] 到 dp[n]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="comment">// 枚举左子树的节点数 j</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            <span class="comment">// 左子树 j 节点，右子树 (i-j-1) 节点</span></span><br><span class="line">            dp[i] += dp[j] * dp[i - j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注：</strong>当 <code>n ≥ 19</code> 时，结果会超出 <code>int</code> 范围，需改用 <code>long</code> 或 <code>BigInteger</code>。</p><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li><strong>时间复杂度：</strong><code>O(n²)</code>。需要双层循环，外层循环 <code>n</code> 次，内层循环 <code>i</code> 次，总操作次数为 <code>n(n+1)/2</code>，因此总时间复杂度为 <code>O(n²)</code>。</li><li><strong>空间复杂度：</strong><code>O(n)</code>。使用长度为 <code>n+1</code> 的数组存储中间结果。</li></ul><h1 id="卡特兰数"><a href="#卡特兰数" class="headerlink" title="卡特兰数"></a>卡特兰数</h1><p>二叉搜索树的数目实际上是一个 <strong>卡特兰数</strong> 问题，卡特兰数是一个数列，满足递推关系 <code>C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)</code>，并且初始条件 <code>C(0)=1</code>。这和本题的二叉搜索树的数量问题是一样的，所以此问题其实已经接触过卡特兰数的一个应用案例。卡塔兰数更便于计算的定义如下:</p><img src="/blog/2025/02/17/unique-binary-search-trees/catalan.png" class="" title="卡特兰数"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numTrees</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="comment">// 我们在这里需要用 long 类型防止计算过程中的溢出</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">C</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        C = C * <span class="number">2</span> * (<span class="number">2</span> * i + <span class="number">1</span>) / (i + <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">int</span>) C;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li><strong>时间复杂度：</strong><code>O(n)</code>。其中 <code>n</code> 表示二叉搜索树的节点个数。我们只需要循环遍历一次即可。</li><li><strong>空间复杂度：</strong><code>O(1)</code>。我们只需要常数空间存放若干变量。</li></ul><h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><blockquote><p><a href="https://leetcode.cn/problems/unique-binary-search-trees/description/" title="96. 完全二叉树的节点个数 | 力扣（LeetCode）">96. 不同的二叉搜索树 | 力扣（LeetCode）</a></p></blockquote><hr>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;给你一个整数 &lt;code&gt;n&lt;/code&gt; ，求恰由 &lt;code&gt;n&lt;/code&gt; 个节点组成且节点值从 &lt;code&gt;1&lt;/code&gt; 到 &lt;code&gt;n&lt;/code&gt; 互不相同的 &lt;strong&gt;二叉搜索树&lt;/strong&gt; 有多少种？返回满足题意的二叉搜索树的种数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;img src=&quot;/blog/2025/02/17/unique-binary-search-trees/uniquebstn3.jpg&quot; class=&quot;&quot; title=&quot;二叉搜索树&quot;&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt;n = 3&lt;br&gt;&lt;strong&gt;输出：&lt;/strong&gt;5&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt;n = 1&lt;br&gt;&lt;strong&gt;输出：&lt;/strong&gt;1&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;提示:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= n &amp;lt;= 19&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://www.cylong.com/categories/LeetCode/"/>
    
    
    <category term="Java" scheme="https://www.cylong.com/tags/Java/"/>
    
    <category term="LeetCode" scheme="https://www.cylong.com/tags/LeetCode/"/>
    
    <category term="学习笔记" scheme="https://www.cylong.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="动态规划" scheme="https://www.cylong.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="树" scheme="https://www.cylong.com/tags/%E6%A0%91/"/>
    
    <category term="二叉树" scheme="https://www.cylong.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    <category term="二叉搜索树" scheme="https://www.cylong.com/tags/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    
    <category term="LeetCode中等" scheme="https://www.cylong.com/tags/LeetCode%E4%B8%AD%E7%AD%89/"/>
    
    <category term="数学公式" scheme="https://www.cylong.com/tags/%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>完全二叉树的节点个数</title>
    <link href="https://www.cylong.com/blog/2025/02/06/count-complete-tree-nodes/"/>
    <id>https://www.cylong.com/blog/2025/02/06/count-complete-tree-nodes/</id>
    <published>2025-02-06T14:10:56.000Z</published>
    <updated>2025-02-06T14:10:56.000Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给你一棵 <strong>完全二叉树</strong> 的根节点 <code>root</code> ，求出该树的节点个数。</p><p><strong>说明:</strong><br>完全二叉树：除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 <code>h</code> 层（从第 <code>0</code> 层开始），则该层包含 <code>1 ~ 2h</code> 个节点。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     1</span><br><span class="line">   /   \</span><br><span class="line">  2     3</span><br><span class="line"> / \   /</span><br><span class="line">4   5 6</span><br></pre></td></tr></table></figure><p><strong>示例 1:</strong></p><blockquote><p><strong>输入：</strong><code>root = [1,2,3,4,5,6]</code><br><strong>输出：</strong>6</p></blockquote><p><strong>示例 2:</strong></p><blockquote><p><strong>输入：</strong><code>root = []</code><br><strong>输出：</strong>0</p></blockquote><p><strong>示例 3:</strong></p><blockquote><p><strong>输入：</strong><code>root = [1]</code><br><strong>输出：</strong>1</p></blockquote><p><strong>提示:</strong></p><ul><li>树中节点的数目范围是 <code>[0, 5 * 10^4]</code></li><li><code>0 &lt;= Node.val &lt;= 5 * 10^4</code></li><li>题目数据保证输入的树是 <strong>完全二叉树</strong></li></ul><span id="more"></span><h1 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h1><p>如果是普通二叉树的话，最直接的方法就是递归或者迭代遍历每个节点，然后统计个数，这样时间复杂度是 <code>O(n)</code>，其中 <code>n</code> 是树的节点总数。空间复杂度是 <code>O(h)</code>，其中 <code>h</code> 是树的高度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countNodes</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + countNodes(root.left) + countNodes(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但这是一个普适的解法，对于此题给的完全二叉树的特点没有利用起来，我们先了解一下 <code>满二叉树</code> 的概念：一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是满二叉树，满二叉树的节点总数是 <code>(2^h) - 1 </code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">     1</span><br><span class="line">   /   \</span><br><span class="line">  2     3</span><br><span class="line"> / \   / \</span><br><span class="line">4   5 6   7</span><br></pre></td></tr></table></figure><p>而完全二叉树的特点是除了最后一层外，其余层都是满的，并且最后一层的节点尽可能靠左。因此，可以利用这个特性来高效计算节点数，而不是普通的遍历方法。首先计算左子树高度 <code>left</code> 和右子树高度 <code>right</code>，接下来比较 <code>left</code> 和 <code>right</code>。</p><ul><li>如果两者相等，说明左子树是满的，此时左子树的节点数为 <code>2^left - 1</code>，加上根节点，总共是 <code>2^left</code>。然后递归计算右子树的节点数。</li><li>如果 <code>left</code> 不等于 <code>right</code>，则说明右子树是满的，但层数比左子树少一层，所以右子树的节点数是 <code>2^right - 1</code>，加上根节点，再递归计算左子树的节点数。</li></ul><p>这里的关键在于，当左右子树高度相等时，左子树一定是满的，可以快速计算其节点数，而无需递归下去；反之，右子树是满的，可以同样处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countNodes</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算左子树高度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> countLevel(root.left);</span><br><span class="line">    <span class="comment">// 计算右子树高度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> countLevel(root.right);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">        <span class="comment">// 左子树是满的，直接计算左子树节点数 (2^left)，递归计算右子树</span></span><br><span class="line">        <span class="keyword">return</span> countNodes(root.right) + (<span class="number">1</span> &lt;&lt; left);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 右子树是满的，直接计算右子树节点数 (2^right)，递归计算左子树</span></span><br><span class="line">        <span class="keyword">return</span> countNodes(root.left) + (<span class="number">1</span> &lt;&lt; right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">countLevel</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">level</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (root != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 完全二叉树的高度由最左路径决定</span></span><br><span class="line">        level++;</span><br><span class="line">        root = root.left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> level;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li><strong>时间复杂度：</strong><code>O((logN)^2)</code>，每次递归调用 countLevel 的时间为 <code>O(h)</code>（<code>h</code> 是当前子树高度），递归深度为树的高度 <code>O(logN)</code>（完全二叉树高度为 <code>logN</code>）。</li><li><strong>空间复杂度：</strong>递归深度为树的高度 <code>O(logN)</code>。</li></ul><h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><blockquote><p><a href="https://leetcode.cn/problems/count-complete-tree-nodes/description/" title="222. 完全二叉树的节点个数 | 力扣（LeetCode）">222. 完全二叉树的节点个数 | 力扣（LeetCode）</a></p></blockquote><hr>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;给你一棵 &lt;strong&gt;完全二叉树&lt;/strong&gt; 的根节点 &lt;code&gt;root&lt;/code&gt; ，求出该树的节点个数。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说明:&lt;/strong&gt;&lt;br&gt;完全二叉树：除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 &lt;code&gt;h&lt;/code&gt; 层（从第 &lt;code&gt;0&lt;/code&gt; 层开始），则该层包含 &lt;code&gt;1 ~ 2h&lt;/code&gt; 个节点。&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;     1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   /   &#92;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  2     3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; / &#92;   /&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4   5 6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt;&lt;code&gt;root = [1,2,3,4,5,6]&lt;/code&gt;&lt;br&gt;&lt;strong&gt;输出：&lt;/strong&gt;6&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt;&lt;code&gt;root = []&lt;/code&gt;&lt;br&gt;&lt;strong&gt;输出：&lt;/strong&gt;0&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例 3:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt;&lt;code&gt;root = [1]&lt;/code&gt;&lt;br&gt;&lt;strong&gt;输出：&lt;/strong&gt;1&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;提示:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;树中节点的数目范围是 &lt;code&gt;[0, 5 * 10^4]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0 &amp;lt;= Node.val &amp;lt;= 5 * 10^4&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;题目数据保证输入的树是 &lt;strong&gt;完全二叉树&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://www.cylong.com/categories/LeetCode/"/>
    
    
    <category term="Java" scheme="https://www.cylong.com/tags/Java/"/>
    
    <category term="LeetCode" scheme="https://www.cylong.com/tags/LeetCode/"/>
    
    <category term="学习笔记" scheme="https://www.cylong.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="递归" scheme="https://www.cylong.com/tags/%E9%80%92%E5%BD%92/"/>
    
    <category term="树" scheme="https://www.cylong.com/tags/%E6%A0%91/"/>
    
    <category term="二叉树" scheme="https://www.cylong.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    <category term="LeetCode简单" scheme="https://www.cylong.com/tags/LeetCode%E7%AE%80%E5%8D%95/"/>
    
    <category term="完全二叉树" scheme="https://www.cylong.com/tags/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    <category term="满二叉树" scheme="https://www.cylong.com/tags/%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>国内如何注册国外 Apple ID</title>
    <link href="https://www.cylong.com/blog/2023/10/10/sign-up-apple-id/"/>
    <id>https://www.cylong.com/blog/2023/10/10/sign-up-apple-id/</id>
    <published>2023-10-10T14:54:22.000Z</published>
    <updated>2023-10-10T14:54:22.000Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近喜欢玩 ChatGPT，奈何手机 IOS 版的 ChatGPT 没有上架中国大陆区 App Store，所以折腾下想要注册美国的 Apple ID，同时也方便下载一些其他有用的软件，比如 PayPal 和 Shadowrocket，话不多说，操作起来也是很简单的 👻</p><span id="more"></span><h1 id="如何注册"><a href="#如何注册" class="headerlink" title="如何注册"></a>如何注册</h1><ol><li>首先去 Apple 官网 <a href="https://appleid.apple.com/account" title="创建你的 Apple ID">创建你的 Apple ID</a>，这里 <code>国家或地区</code> 选择 <code>美国</code>，其他的填写你的真实信息，手机号可以填写中国大陆手机号，用于后续接收验证码，验证通过后你就获得了一个国外的 Apple ID ，但是还没结束。<img src="/blog/2023/10/10/sign-up-apple-id/%E5%88%9B%E5%BB%BA%E4%BD%A0%E7%9A%84-Apple-ID.png" class="" title="创建你的 Apple ID"></li><li>用你刚刚注册的 Apple ID 登录你的苹果设备，我用我的 iPad 做了小白鼠，第一次登录，有各种验证和同意条款等操作，确认即可。</li><li><code>设置</code> 里点击你的头像，找到 <code>付款与配送</code>，编辑配送地址（如果默认跳转到添加付款方式页面，回到上一页即可），这里要选择一个美国的地址，可以通过 <a href="https://www.meiguodizhi.com/" title="美国地址生成器">美国地址生成器</a>（链接打不开的话直接去谷歌或者百度搜索关键字）随机生成填入后保存。<img src="/blog/2023/10/10/sign-up-apple-id/%E7%BC%96%E8%BE%91%E9%80%81%E8%B4%A7%E5%9C%B0%E5%9D%80.jpg" class="" title="编辑送货地址"></li><li>接下来就可以尽情的在 App Store 里下载各种神秘的软件啦（第3步没设置的话，这里下载软件的时候也是会提示设置送货地址的）<img src="/blog/2023/10/10/sign-up-apple-id/%E4%B8%8B%E8%BD%BDChatGPT.jpg" class="" title="下载ChatGPT"></li></ol><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote><p><a href="/blog/2023/10/08/sign-up-chatgpt/" title="国内如何注册 ChatGPT 账号 | 笑话人生">国内如何注册 ChatGPT 账号 | 笑话人生</a><br><a href="https://zhuanlan.zhihu.com/p/373675995" title="手把手教你注册国外apple ID（超简单） | 知乎">手把手教你注册国外apple ID（超简单） | 知乎</a><br><a href="https://imtoken.fans/t/topic/243" title="如何创建海外 Apple ID | imToken Fans">如何创建海外 Apple ID | imToken Fans</a></p></blockquote><hr>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近喜欢玩 ChatGPT，奈何手机 IOS 版的 ChatGPT 没有上架中国大陆区 App Store，所以折腾下想要注册美国的 Apple ID，同时也方便下载一些其他有用的软件，比如 PayPal 和 Shadowrocket，话不多说，操作起来也是很简单的 👻&lt;/p&gt;</summary>
    
    
    
    <category term="Apple" scheme="https://www.cylong.com/categories/Apple/"/>
    
    
    <category term="IOS" scheme="https://www.cylong.com/tags/IOS/"/>
    
    <category term="ChatGPT" scheme="https://www.cylong.com/tags/ChatGPT/"/>
    
    <category term="Apple" scheme="https://www.cylong.com/tags/Apple/"/>
    
  </entry>
  
  <entry>
    <title>国内如何注册 ChatGPT 账号</title>
    <link href="https://www.cylong.com/blog/2023/10/08/sign-up-chatgpt/"/>
    <id>https://www.cylong.com/blog/2023/10/08/sign-up-chatgpt/</id>
    <published>2023-10-08T08:30:47.000Z</published>
    <updated>2023-10-08T08:30:47.000Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>OpenAI 公司是一家位于美国的人工智能研究与开发公司，成立于2015年，致力于推动人工智能技术的发展。该公司的使命是确保人工智能技术对整个人类社会的利益产生积极影响。OpenAI 在自然语言处理领域取得了重要突破，其中的一个产品就是 ChatGPT。<br>ChatGPT 是 OpenAI 开发的一款强大的自然语言处理模型。它可以理解和生成人类语言，能够回答问题、执行任务、进行对话等多种应用。ChatGPT 可以用于在线客服、智能助手、内容生成、教育支持等众多领域，为用户提供自然而流畅的文本交互体验。<br>OpenAI 不断改进和扩展 ChatGPT，以提供更准确、有用和安全的服务。这一技术的发展代表了人工智能在改善人们的生活、工作和沟通方面的潜力，并在多个领域产生了广泛的应用。</p><p>在国内并不支持 OpenAI 账号注册，多数会提示：<code>OpenAI&#39;s services are not available in your country</code>，查阅了一些资料后发现以下方式可以注册成功。</p><h1 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h1><ol><li>国外梯子，没有的话可以参考 <a href="/blog/2016/05/26/shadowsocks/" title="站在 Shadowsocks 的肩膀上发现精彩的世界 | 笑话人生">站在 Shadowsocks 的肩膀上发现精彩的世界</a></li><li>国外手机号，没有的话可以通过 <a href="https://sms-activate.org/" title="SMS-Activate是在线接收短信的虚拟号码服务">SMS-Activate</a> 购买一个</li></ol><span id="more"></span><h1 id="注册ChatGPT账号"><a href="#注册ChatGPT账号" class="headerlink" title="注册ChatGPT账号"></a>注册ChatGPT账号</h1><ol><li>访问 <a href="https://openai.com/" title="OpenAI">OpenAI</a> 右上角注册（建议使用国外IP），可以使用 Google、Microsoft、Apple 或者直接使用邮箱注册<img src="/blog/2023/10/08/sign-up-chatgpt/%E6%B3%A8%E5%86%8CChatGPT.png" class="" title="注册ChatGPT"></li><li>这里输入你国外的手机号，如果没有的话，参考下文注册 <a href="https://sms-activate.org/" title="SMS-Activate是在线接收短信的虚拟号码服务">SMS-Activate</a><img src="/blog/2023/10/08/sign-up-chatgpt/%E9%AA%8C%E8%AF%81%E6%89%8B%E6%9C%BA%E5%8F%B7.png" class="" title="验证手机号"></li><li>OpenAI 产品列表，选择 ChatGPT（DALL·E有兴趣可以玩玩，可以生成与文本描述相关的图像，收费）<img src="/blog/2023/10/08/sign-up-chatgpt/OpenAI%E4%BA%A7%E5%93%81%E5%88%97%E8%A1%A8.png" class="" title="OpenAI产品列表"></li><li>初体验 ChatGPT，免费的是 ChatGPT-3.5，想要使用 ChatGPT-4 需要 ChatGPT Plus，收费20$/月<img src="/blog/2023/10/08/sign-up-chatgpt/%E5%88%9D%E4%BD%93%E9%AA%8CChatGPT.png" class="" title="初体验ChatGPT"></li></ol><h1 id="注册短信服务"><a href="#注册短信服务" class="headerlink" title="注册短信服务"></a>注册短信服务</h1><ol><li>打开 <a href="https://sms-activate.org/" title="SMS-Activate是在线接收短信的虚拟号码服务">SMS-Activate</a> 右上角注册登录，登录后右上角充值<img src="/blog/2023/10/08/sign-up-chatgpt/SMS-Activate%E5%85%85%E5%80%BC.png" class="" title="SMS-Activate充值"></li><li>往下拉选择支付宝，最低充值2$（吐槽一下，之前没有最低充值额度的，估计是发现了商机😒）<img src="/blog/2023/10/08/sign-up-chatgpt/SMS-Activate%E6%94%AF%E4%BB%98%E5%AE%9D%E5%85%85%E5%80%BC.jpg" class="" title="SMS-Activate支付宝充值"></li><li>左侧服务选择搜索 <code>OpenAI</code><img src="/blog/2023/10/08/sign-up-chatgpt/SMS-Activate%E6%9C%8D%E5%8A%A1%E9%80%89%E6%8B%A9.jpg" class="" title="SMS-Activate服务选择"></li><li>国家选择印度并购买<img src="/blog/2023/10/08/sign-up-chatgpt/SMS-Activate%E5%9B%BD%E5%AE%B6%E9%80%89%E6%8B%A9.png" class="" title="SMS-Activate国家选择"></li><li>此时你就有了一个可以接收验证码的国外手机号，用于后续注册 ChatGPT 使用，此号码在20分钟有效期内并且未使用的情况下可以退款取消注册，如果注册 ChatGPT 过程中一直收不到验证码，可以多试几次，我是一次就成功了哈哈哈😁<img src="/blog/2023/10/08/sign-up-chatgpt/SMS-Activate%E5%8F%B7%E7%A0%81.png" class="" title="SMS-Activate号码"></li></ol><h1 id="下载-ChatGPT-IOS-APP"><a href="#下载-ChatGPT-IOS-APP" class="headerlink" title="下载 ChatGPT IOS APP"></a>下载 ChatGPT IOS APP</h1><p>参考：<a href="/blog/2023/10/10/sign-up-apple-id/" title="国内如何注册国外 Apple ID | 笑话人生">国内如何注册国外 Apple ID | 笑话人生</a></p><h1 id="开通-ChatGPT-Plus"><a href="#开通-ChatGPT-Plus" class="headerlink" title="开通 ChatGPT Plus"></a>开通 ChatGPT Plus</h1><p>想要使用 ChatGPT-4 ，需要开通 Plus 订阅，网上找了些资料，还比较复杂，先挖个坑，待实操一遍再埋坑，可以先参考：</p><blockquote><p><a href="https://chatgpt-plus.github.io/chatgpt-plus/" title="国内开通 ChatGPT Plus 保姆级教程">国内开通 ChatGPT Plus 保姆级教程</a><br><a href="https://sites.google.com/view/chatgptcn/ChatGpt-upgrade-Plus-subscription" title="ChatGPT 怎样升级 Plus 订阅">ChatGPT 怎样升级 Plus 订阅</a></p></blockquote><h1 id="一些感想"><a href="#一些感想" class="headerlink" title="一些感想"></a>一些感想</h1><p>自从接触 ChatGPT 之后，平时写文章，写代码都会想到先问问 ChatGPT，确实能得到很多不错的答案。网络上各行各业的人使用后发出感叹，大部分人要失业了。我认为 ChatGPT 不会让大部分人失业，但是会让不会用 ChatGPT 的人失业。</p><img src="/blog/2023/10/08/sign-up-chatgpt/ChatGPT%E4%BC%9A%E8%AE%A9%E5%A4%A7%E9%83%A8%E5%88%86%E4%BA%BA%E5%A4%B1%E4%B8%9A%E4%B9%88.png" class="" title="ChatGPT会让大部分人失业么"><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><blockquote><p><a href="https://v2ex.com/t/900126" title="OpenAI 推出超神 ChatGPT 注册攻略来了 | V2EX">OpenAI 推出超神 ChatGPT 注册攻略来了 | V2EX</a><br><a href="https://cloud.tencent.com/developer/article/2192253" title="最近很火的 ChatGPT，带你注册体验全攻略 | 腾讯云开发者社区">最近很火的 ChatGPT，带你注册体验全攻略 | 腾讯云开发者社区</a><br><a href="https://readdevdocs.com/blog/tech/%E5%A6%82%E4%BD%95%E7%BC%96%E7%A8%8B%E8%B0%83%E7%94%A8OpenAI%E7%9A%84ChatGPT%20API%E6%8E%A5%E5%8F%A3.html" title="如何编程调用 OpenAI 的 ChatGPT API 接口 | Read dev Docs 博客">如何编程调用 OpenAI 的 ChatGPT API 接口 | Read dev Docs 博客</a></p></blockquote><hr>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;OpenAI 公司是一家位于美国的人工智能研究与开发公司，成立于2015年，致力于推动人工智能技术的发展。该公司的使命是确保人工智能技术对整个人类社会的利益产生积极影响。OpenAI 在自然语言处理领域取得了重要突破，其中的一个产品就是 ChatGPT。&lt;br&gt;ChatGPT 是 OpenAI 开发的一款强大的自然语言处理模型。它可以理解和生成人类语言，能够回答问题、执行任务、进行对话等多种应用。ChatGPT 可以用于在线客服、智能助手、内容生成、教育支持等众多领域，为用户提供自然而流畅的文本交互体验。&lt;br&gt;OpenAI 不断改进和扩展 ChatGPT，以提供更准确、有用和安全的服务。这一技术的发展代表了人工智能在改善人们的生活、工作和沟通方面的潜力，并在多个领域产生了广泛的应用。&lt;/p&gt;
&lt;p&gt;在国内并不支持 OpenAI 账号注册，多数会提示：&lt;code&gt;OpenAI&amp;#39;s services are not available in your country&lt;/code&gt;，查阅了一些资料后发现以下方式可以注册成功。&lt;/p&gt;
&lt;h1 id=&quot;前期准备&quot;&gt;&lt;a href=&quot;#前期准备&quot; class=&quot;headerlink&quot; title=&quot;前期准备&quot;&gt;&lt;/a&gt;前期准备&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;国外梯子，没有的话可以参考 &lt;a href=&quot;/blog/2016/05/26/shadowsocks/&quot; title=&quot;站在 Shadowsocks 的肩膀上发现精彩的世界 | 笑话人生&quot;&gt;站在 Shadowsocks 的肩膀上发现精彩的世界&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;国外手机号，没有的话可以通过 &lt;a href=&quot;https://sms-activate.org/&quot; title=&quot;SMS-Activate是在线接收短信的虚拟号码服务&quot;&gt;SMS-Activate&lt;/a&gt; 购买一个&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="人工智能" scheme="https://www.cylong.com/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    
    <category term="人工智能" scheme="https://www.cylong.com/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    <category term="OpenAI" scheme="https://www.cylong.com/tags/OpenAI/"/>
    
    <category term="ChatGPT" scheme="https://www.cylong.com/tags/ChatGPT/"/>
    
    <category term="AIGC" scheme="https://www.cylong.com/tags/AIGC/"/>
    
    <category term="AGI" scheme="https://www.cylong.com/tags/AGI/"/>
    
  </entry>
  
  <entry>
    <title>2022届实习生-蚂蚁集团-支付宝事业线</title>
    <link href="https://www.cylong.com/blog/2021/03/01/job-alipay/"/>
    <id>https://www.cylong.com/blog/2021/03/01/job-alipay/</id>
    <published>2021-03-01T03:35:35.000Z</published>
    <updated>2021-03-01T03:35:35.000Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>看到学弟学妹都很热情的联系我，所以我整理了这个博客，方便给大家答疑，并同步招聘动态给大家。先自我介绍一下，我是南大软院17届毕业的，目前在支付宝就职，我叫陈云龙【花名奇策】，作为学长，可以根据自己亲身经历，给学弟学妹量身定做春招实习建议。大家有任何的疑问或者职业咨询，随时都可以联系我。</p><p>周围有其他感兴趣的小伙伴，都可以让他们联系我，哪怕不想投递这个部门，也可以听听学长的唠叨【实习经验、注意事项、简历建议、面试建议等】随时联系学长咨询各种实习内推问题呀～</p><p><strong>微信：cylong1016</strong>【加微信请备注姓名 + 学校 + 学历 + 学弟or学妹】</p><img src="/blog/2021/03/01/job-alipay/%E5%BE%AE%E4%BF%A1.jpg" class="" title="微信"><p><strong>PS：加学长微信，可以给你24小时的热心答疑服务！(oﾟvﾟ)ノ</strong></p><h1 id="招聘招聘"><a href="#招聘招聘" class="headerlink" title="招聘招聘"></a>招聘招聘</h1><p>2022届蚂蚁集团-支付宝事业线-区域中台技术部招聘实习生啦（内推），如果有意愿来支付宝的，给自己一次机会简历速度砸过来吧，我帮助大家内推。<strong>后续可转正！</strong></p><p><strong>招聘对象：</strong> 2021.11 - 2022.10毕业的应届毕业生。<br><strong>招聘流程：</strong> 简历投递-&gt;在线笔试及测评-&gt;面试-&gt;发放实习offer-&gt;实习入职<br><strong>岗位类型：</strong> Java研发、数据研发、产品经理，欢迎加入钉钉群交流：31091227<br><strong>工作地点：</strong> 杭州、上海、成都<br><strong>简历请发送到邮箱：</strong> chenyunlong.cyl@antgroup.com<br><strong>注意简历命名格式：</strong> 姓名 + 学校 + 手机号 + 邮箱</p><p><strong>附：</strong> 投递简历后学长将把关简历，提供修改建议，并提供实习问题咨询及职业指导，简历快快砸过来～</p><span id="more"></span><h2 id="关于我们"><a href="#关于我们" class="headerlink" title="关于我们"></a>关于我们</h2><p>蚂蚁集团是中国最大的移动支付平台支付宝的母公司，也是全球领先的金融科技开放平台，致力于以科技推动包括金融服务业在内的全球现代服务业的数字化升级，携手合作伙伴为消费者和小微企业提供普惠、绿色、可持续的服务，为世界带来微小而美好的改变，用科技让普通人和小企业，享受平等的金融和生活服务。未来三年，支付宝将携手5万家服务商，帮助4000W服务业商家完成数字化升级。</p><p>我们区域中台技术部正式为了这一目标而诞生。核心团队来自蚂蚁两大超域的主架构。我们用工程、数据、算法、分布式架构等能力，为区域化作战提供：数字化的指挥决策系统、场景覆盖的销售及技术交付系统、区域化运营及招商技术。为推进百城的数字化提供完善的技术支持和保障。</p><p><strong>为什么加入我们</strong></p><ul><li>有数据：支付宝万亿级规模交易/营销数据。</li><li>有挑战：大型分布式系统和大数据应用场景。</li><li>有影响力：支付宝核心团队，各路领域专家和高手。</li><li>有成长：快速成长的通道，助力成长为技术领域大牛。</li></ul><p>期待你的加入，助力你成长为技术大牛！</p><h1 id="春招问题汇总"><a href="#春招问题汇总" class="headerlink" title="春招问题汇总"></a>春招问题汇总</h1><p>整理了下大家问我的问题，有漏的或者后续有其他问题也都可以随时联系我。</p><p><strong>Q：内推投了大概多久面试？内推系统什么时候开放？</strong><br>A：目前是收集简历阶段，内推系统会在3月8号开启，之前给我发简历的同学，我就会投递到系统中，这个时候你就会收到一个我（陈云龙）内推邮件的，你点击确认后就进入后续的春招笔试、面试流程。第一批笔试是3月9日开始，每周两次，之后也会有面试官联系你安排面试。</p><p><strong>Q：内推投递简历截止时间？</strong><br>A：校招系统内推投递通道全年开放，可以长期推荐，主要集中在3-4月。越早投递越有优势～不要因为练题等原因错过最佳投递时间，毕竟机会总是留给有准备的人。</p><p><strong>Q：内推同时只能投一个部门？</strong><br><del>A：是的，如果同时找多个学长学姐内推，投递多个部门，最后可能收到多个内推邮件，只能确认一个部门，只能走一个部门的面试流程。</del><br>A: 校招系统改版，每位同学投递，可以选择三个意向部门。系统默认会把首次内推该简历的同学所在的BG推荐为该学生第一志愿，学生保留修改的权力；学生可自主填写二志愿和三志愿。当前志愿不通过后，会通过一些条件及学生意愿，流转到下一个志愿。</p><p><strong>Q：内推没过的话还能继续投其他部门么？</strong><br><del>A：内推如果没通过，大家还是可以继续去阿里官网，投递其他部门的。（内推和官网申请各有一次机会）</del><br>A：参考上一条答疑，新系统上线后，就是一次投递三个部门了。不分内推和网申了。</p><p><strong>Q：新系统上线，哪些同学会收到填写意向的邮件？</strong></p><ol><li>此前已在官网投递，且处于“新投递”状态下的同学（可登录官网个人中心查看），请留意自己的邮箱，系统会发送意向填写邮件。</li><li>此前已经内推的同学，如果面试未通过，我们会发送意向邮件，同学可以补填第二和第三志愿。</li><li>目前已经被回绝的同学，也将收到填写意向的邮件，可以补填第二及第三志愿。</li></ol><p><strong>Q：实习待遇？</strong><br>A：我们会提供具有市场竞争力的薪酬（不会亏待大家滴），其他的福利如餐补、房补、交通补贴、入职酒店住宿等会根据同学的实际情况按照公司标准给到大家，具体的数字面试通过后HRG会和大家沟通~</p><p><strong>Q：什么时候实习？</strong><br>A：拿到实习Offer后，实习时间可以沟通，随时来实习。如果有意外情况无法来实习，后续也会有秋季校招直通面试（前面的面试结果都会保留）。</p><p><strong>Q：实习可能直接发正式Offer？</strong><br>A：实习后会有述职，评定是否发正式的校招Offer。</p><p><strong>Q：笔试题型是什么样的？有没有编程机试，限不限语言？笔试是统一的么？</strong><br>A：2道在线编程题，知识点为计算机学科基础知识点，如动态规划、字符串、数学问题等，不区分岗位，不区分语言。所有岗位每场考试考同一套题目。还有一块是测评，主要有一些计算、推理，考察逻辑思维等。</p><p><strong>Q：实习生会有同事带么？</strong><br>A：每个人入职都会指定专门的师兄带你，熟悉阿里的文化、生活、熟悉项目组业务，指导你工作上的事情，让你更快的提升自己。除了师兄以外，任何问题都可以找周围的同事，每个人都会愿意为你解答的~</p><p><strong>Q：有同学是海外读书，回国需要隔离，隔离期间能否远程实习？</strong><br>A：目前集团没有远程实习政策，后续是否有新的政策，或者其他特殊情况可以远程实习，可以拿到offer后和HR沟通。</p><p><strong>Q：要怎么查看面试进展？</strong><br>A：请进入<a href="https://campus.alibaba.com/index.htm" title="阿里巴巴校招官网">阿里巴巴校招官网</a>→个人中心查看。【3月8号开放】</p><p><strong>Q：还有N个无法解决的问题？</strong><br>A：有任何问题，可在工作日9:00-12:00、13:00-18:00期间拨打校招热线咨询：0571-81595981。也可咨询校园小蜜人工客服：校园招聘官网右侧→校园小蜜→人工客服</p><p><strong>你们可能的担心、疑虑：</strong></p><ol><li>如果后续不考虑来我们部门，可以不点我的内推确认邮件，就不会走春招流程；</li><li>如果想多些时间准备笔试、面试，那么笔试、面试时间也是可以自己决定的；投递简历、笔试、面试并没有截止时间，目前系统会一直开放的。想晚一点点击确认邮件，想晚一点笔试、想晚一点面试，都不会有影响，想给自己充分的准备时间，都可以由自己决定。但是建议大家在3月份，最晚4月份搞定这些事情，因为不清楚后面会不会有什么政策改变，比如部门人招满了，可能后续就不招了。越早投递越有优势～不要因为练题等原因错过最佳投递时间。</li><li>越早投递简历，越早内推，越早面试，越早拿offer，越早安心。</li><li>后续拿到offer，什么时候实习，也是可以自由决定的。</li></ol><p><strong>总结重点：</strong> 大家有简历现在就可以投递了！现在就可以投递了！现在就可以投递了！不会有任何的后顾之忧！简历后续也是可以随时更新的！</p><h1 id="经验之谈"><a href="#经验之谈" class="headerlink" title="经验之谈"></a>经验之谈</h1><ol><li>大学生实习是一个很好的机会，特别是大公司的实习，千万不要错过，首先实习是很容易拿到正式校招Offer的。如果后续想去其他公司，那么有实习经历，是很大的加分项。</li><li>机会总是给有准备的人，不要等待，要主动出击，先写好简历就是开始，接下来就可以准备，不知道准备啥，就可以看看你简历里写的啥，深入了解，很多面试官都会根据简历问你问题的。不知道简历写啥，可以看平时学校里做的项目（课内作业、课外项目，团队项目写写自己在项目中担任的角色，负责的模块），参加的竞赛，学习的课程知识，有没有发表过论文，比赛获得过什么奖，有没有自己的技术博客，参加过什么交流，讲座，开源项目等等。非技术相关的也可以写，比如社团，学生会的工作职责，参加某某公益，社会项目等等，有没有奖学金，读了哪些书。都可以写，有什么写什么（但是不要太多，太啰嗦，挑亮点写）。</li><li>面试也可以很快的提升自己，不要怕挂，也不要担心其他的，无论通过与否，都会积累很有价值的经验，也能快速的发现自己的不足。</li><li>自信点，大家都是从学校出来的，你可能觉得，要学的太多了，这也不会，那也不会，学无止境，大学不可能都被你学完，学会的。只要认真准备，认真学习了，把大学里的知识学会，就已经超越很多人了。</li><li>很多同学都会问面试可能都面试些什么，我虽然没有做过面试官，但是我被面试过啊，可以跟大家分享下。<br> a. 基础的信息，比如成绩、竞赛、奖学金、社团、学生会、课外实践，这些面试官可能会简单提及下，确认下实际情况（这个可能是HR面试官会问）<br> b. 技术问题就是一些基础知识、由浅入深，就看你都掌握程度。简历里写的优先深入了解。面试官可能还会扩散问，这个时候就看自己知识的广度和深度了。<br> c. 项目面试都话，会问你项目为了解决什么问题，在项目中担任什么角色，负责什么部分，用了什么技术，过程中遇到了什么困难，怎么解决的，最后这个项目做完，有哪些收获总结，自己得到了哪些成长。<br> d. 自己的优点，缺点，自己的价值，自己对未来的规划。<br> e. 最后有没有什么问题要问面试官。</li><li>知乎上有几篇下如何写简历的文章感觉可借鉴，可以参考：<blockquote><p><a href="https://www.zhihu.com/question/26265144">https://www.zhihu.com/question/26265144</a><br><a href="https://www.zhihu.com/question/23734172">https://www.zhihu.com/question/23734172</a></p></blockquote></li></ol><h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>祝愿学弟学妹们都能拿到自己满意的实习Offer(ง •_•)ง</p><p>本文档也会不断的更新，欢迎大家推荐给周围的小伙伴呀(●ˇ∀ˇ●)</p><hr>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;看到学弟学妹都很热情的联系我，所以我整理了这个博客，方便给大家答疑，并同步招聘动态给大家。先自我介绍一下，我是南大软院17届毕业的，目前在支付宝就职，我叫陈云龙【花名奇策】，作为学长，可以根据自己亲身经历，给学弟学妹量身定做春招实习建议。大家有任何的疑问或者职业咨询，随时都可以联系我。&lt;/p&gt;
&lt;p&gt;周围有其他感兴趣的小伙伴，都可以让他们联系我，哪怕不想投递这个部门，也可以听听学长的唠叨【实习经验、注意事项、简历建议、面试建议等】随时联系学长咨询各种实习内推问题呀～&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;微信：cylong1016&lt;/strong&gt;【加微信请备注姓名 + 学校 + 学历 + 学弟or学妹】&lt;/p&gt;
&lt;img src=&quot;/blog/2021/03/01/job-alipay/%E5%BE%AE%E4%BF%A1.jpg&quot; class=&quot;&quot; title=&quot;微信&quot;&gt;

&lt;p&gt;&lt;strong&gt;PS：加学长微信，可以给你24小时的热心答疑服务！(oﾟvﾟ)ノ&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;招聘招聘&quot;&gt;&lt;a href=&quot;#招聘招聘&quot; class=&quot;headerlink&quot; title=&quot;招聘招聘&quot;&gt;&lt;/a&gt;招聘招聘&lt;/h1&gt;&lt;p&gt;2022届蚂蚁集团-支付宝事业线-区域中台技术部招聘实习生啦（内推），如果有意愿来支付宝的，给自己一次机会简历速度砸过来吧，我帮助大家内推。&lt;strong&gt;后续可转正！&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;招聘对象：&lt;/strong&gt; 2021.11 - 2022.10毕业的应届毕业生。&lt;br&gt;&lt;strong&gt;招聘流程：&lt;/strong&gt; 简历投递-&amp;gt;在线笔试及测评-&amp;gt;面试-&amp;gt;发放实习offer-&amp;gt;实习入职&lt;br&gt;&lt;strong&gt;岗位类型：&lt;/strong&gt; Java研发、数据研发、产品经理，欢迎加入钉钉群交流：31091227&lt;br&gt;&lt;strong&gt;工作地点：&lt;/strong&gt; 杭州、上海、成都&lt;br&gt;&lt;strong&gt;简历请发送到邮箱：&lt;/strong&gt; chenyunlong.cyl@antgroup.com&lt;br&gt;&lt;strong&gt;注意简历命名格式：&lt;/strong&gt; 姓名 + 学校 + 手机号 + 邮箱&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;附：&lt;/strong&gt; 投递简历后学长将把关简历，提供修改建议，并提供实习问题咨询及职业指导，简历快快砸过来～&lt;/p&gt;</summary>
    
    
    
    <category term="招聘" scheme="https://www.cylong.com/categories/%E6%8B%9B%E8%81%98/"/>
    
    
    <category term="招聘" scheme="https://www.cylong.com/tags/%E6%8B%9B%E8%81%98/"/>
    
    <category term="实习生" scheme="https://www.cylong.com/tags/%E5%AE%9E%E4%B9%A0%E7%94%9F/"/>
    
  </entry>
  
  <entry>
    <title>求根到叶子节点数字之和</title>
    <link href="https://www.cylong.com/blog/2020/10/29/sum-root-to-leaf-numbers/"/>
    <id>https://www.cylong.com/blog/2020/10/29/sum-root-to-leaf-numbers/</id>
    <published>2020-10-29T14:52:29.000Z</published>
    <updated>2020-10-29T14:52:29.000Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个二叉树，它的每个结点都存放一个 0-9 的数字，每条从根到叶子节点的路径都代表一个数字。<br>例如，从根到叶子节点路径 1-&gt;2-&gt;3 代表数字 123。计算从根到叶子节点生成的所有数字之和。</p><p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p><p><strong>示例 1:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入: [1, 2, 3]</span><br><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   3</span><br><span class="line">输出: 25</span><br><span class="line">解释:</span><br><span class="line">从根到叶子节点路径 1-&gt;2 代表数字 12.</span><br><span class="line">从根到叶子节点路径 1-&gt;3 代表数字 13.</span><br><span class="line">因此，数字总和 = 12 + 13 = 25.</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入: [4, 9, 0, 5, 1]</span><br><span class="line">    4</span><br><span class="line">   / \</span><br><span class="line">  9   0</span><br><span class="line"> / \</span><br><span class="line">5   1</span><br><span class="line">输出: 1026</span><br><span class="line">解释:</span><br><span class="line">从根到叶子节点路径 4-&gt;9-&gt;5 代表数字 495.</span><br><span class="line">从根到叶子节点路径 4-&gt;9-&gt;1 代表数字 491.</span><br><span class="line">从根到叶子节点路径 4-&gt;0 代表数字 40.</span><br><span class="line">因此，数字总和 = 495 + 491 + 40 = 1026.</span><br></pre></td></tr></table></figure><span id="more"></span><h1 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h1><p>此题中，每个节点都对应一个 0-9 的数字，每条从根节点到叶子节点的路径都代表一个数字。我们只要通过深度优先搜索加回溯算法，求出所有路径组成的数字，再将所有数字相加求和即可。具体的，从根节点开始，遍历每个节点，如果遇到叶子节点，则将组成的数字保存，并进行回溯。如果不是叶子节点，则递归遍历子节点构造数字。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">LinkedList&lt;Integer&gt; item = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumNumbers</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    dfsBuildNumbers(root);</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (List&lt;Integer&gt; list : res) &#123;</span><br><span class="line">        sum += parseInt(list);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfsBuildNumbers</span><span class="params">(TreeNode node)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    item.add(node.val);</span><br><span class="line">    <span class="keyword">if</span> (node.left == <span class="literal">null</span> &amp;&amp; node.right == <span class="literal">null</span>) &#123;</span><br><span class="line">        res.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;(item));</span><br><span class="line">    &#125;</span><br><span class="line">    dfsBuildNumbers(node.left);</span><br><span class="line">    dfsBuildNumbers(node.right);</span><br><span class="line">    item.removeLast();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">parseInt</span><span class="params">(List&lt;Integer&gt; list)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> n : list) &#123;</span><br><span class="line">        res = res * <span class="number">10</span> + n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实，每个节点都对应一个数字，等于其父节点对应的数字乘以 10 再加上该节点的值（这里假设根节点的父节点对应的数字是 0）。只要计算出每个叶子节点对应的数字，然后计算所有叶子节点对应的数字之和，即可得到结果。可以通过深度优先搜索实现。</p><img src="/blog/2020/10/29/sum-root-to-leaf-numbers/number.png" class="" title="图解"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumNumbers</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> dfs(root, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(TreeNode root, <span class="type">int</span> prevSum)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> prevSum * <span class="number">10</span> + root.val;</span><br><span class="line">    <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dfs(root.left, sum) + dfs(root.right, sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li>时间复杂度：O(n)，其中 n 是二叉树的节点个数。对每个节点访问一次。</li><li>空间复杂度：O(n)，其中 n 是二叉树的节点个数。空间复杂度主要取决于递归调用的栈空间，递归栈的深度等于二叉树的高度，最坏情况下，二叉树的高度等于节点个数，空间复杂度为 O(n)。</li></ul><h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><blockquote><p><a href="https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/" title="求根到叶子节点数字之和 | 力扣（LeetCode）">求根到叶子节点数字之和 | 力扣（LeetCode）</a><br><a href="https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/solution/qiu-gen-dao-xie-zi-jie-dian-shu-zi-zhi-he-by-leetc/" title="求根到叶子节点数字之和 | 题解（LeetCode）">求根到叶子节点数字之和 | 题解（LeetCode）</a></p></blockquote><hr>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;给定一个二叉树，它的每个结点都存放一个 0-9 的数字，每条从根到叶子节点的路径都代表一个数字。&lt;br&gt;例如，从根到叶子节点路径 1-&amp;gt;2-&amp;gt;3 代表数字 123。计算从根到叶子节点生成的所有数字之和。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说明:&lt;/strong&gt; 叶子节点是指没有子节点的节点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: [1, 2, 3]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   / &#92;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  2   3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;从根到叶子节点路径 1-&amp;gt;2 代表数字 12.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;从根到叶子节点路径 1-&amp;gt;3 代表数字 13.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;因此，数字总和 = 12 + 13 = 25.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: [4, 9, 0, 5, 1]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   / &#92;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  9   0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; / &#92;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5   1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 1026&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;从根到叶子节点路径 4-&amp;gt;9-&amp;gt;5 代表数字 495.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;从根到叶子节点路径 4-&amp;gt;9-&amp;gt;1 代表数字 491.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;从根到叶子节点路径 4-&amp;gt;0 代表数字 40.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;因此，数字总和 = 495 + 491 + 40 = 1026.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://www.cylong.com/categories/LeetCode/"/>
    
    
    <category term="Java" scheme="https://www.cylong.com/tags/Java/"/>
    
    <category term="LeetCode" scheme="https://www.cylong.com/tags/LeetCode/"/>
    
    <category term="学习笔记" scheme="https://www.cylong.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="递归" scheme="https://www.cylong.com/tags/%E9%80%92%E5%BD%92/"/>
    
    <category term="回溯算法" scheme="https://www.cylong.com/tags/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
    
    <category term="树" scheme="https://www.cylong.com/tags/%E6%A0%91/"/>
    
    <category term="二叉树" scheme="https://www.cylong.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    <category term="深度优先搜索" scheme="https://www.cylong.com/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>二叉树的前序遍历</title>
    <link href="https://www.cylong.com/blog/2020/10/27/binary-tree-preorder-traversal/"/>
    <id>https://www.cylong.com/blog/2020/10/27/binary-tree-preorder-traversal/</id>
    <published>2020-10-27T15:15:09.000Z</published>
    <updated>2020-10-27T15:15:09.000Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给你二叉树的根节点 root ，返回它节点值的 前序 遍历。</p><p><strong>示例 1：</strong></p><img src="/blog/2020/10/27/binary-tree-preorder-traversal/inorder.jpg" class="" title="前序遍历"><blockquote><p>输入：root = [1, null, 2, 3]<br>输出：[1, 2, 3]</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p>输入：root = []<br>输出：[]</p></blockquote><span id="more"></span><h1 id="递归与非递归版本"><a href="#递归与非递归版本" class="headerlink" title="递归与非递归版本"></a>递归与非递归版本</h1><p>前序遍历的输出顺序就是根节点 -&gt; 左子树 -&gt; 右子树。前序遍历是先输出根节点的值，再去递归的输出左子树和右子树。整个遍历过程就是递归的性质，我们可以直接使用递归来完成计算。非递归版本其实是等阶的，只是我们将递归的栈显示的表达出来。下面是递归的版本解法，非递归的解法和二叉树的其他遍历方式可以参考我的另外一篇博客：<a href="/blog/2020/09/02/binary-tree-traverse/" title="二叉树的遍历">二叉树的遍历</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    dfsPreOrder(root);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfsPreOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ans.add(root.val);</span><br><span class="line">    dfsPreOrder(root.left);</span><br><span class="line">    dfsPreOrder(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li>时间复杂度：O(n)，其中 n 是二叉树的节点数。每一个节点恰好被遍历一次。</li><li>空间复杂度：O(n)，为迭代过程中显式栈的开销，平均情况下为 O(logn)，最坏情况下树呈现链状，为 O(n)。</li></ul><h1 id="Morris-遍历"><a href="#Morris-遍历" class="headerlink" title="Morris 遍历"></a>Morris 遍历</h1><p>所谓再简单的题，通过看官方的题解，总能发现惊喜。有一种巧妙的方法可以在线性时间内，只占用常数空间来实现前序遍历。这种方法由 J. H. Morris 在 1979 年的论文「Traversing Binary Trees Simply and Cheaply」中首次提出，因此被称为 Morris 遍历。</p><p>Morris 遍历的核心思想是利用树的大量空闲指针，实现空间开销的极限缩减。其前序遍历规则总结如下：</p><ol><li>新建临时节点，令该节点为 root；</li><li>如果当前节点的左子节点为空，将当前节点加入答案，并遍历当前节点的右子节点；</li><li>如果当前节点的左子节点不为空，在当前节点的左子树中找到当前节点在中序遍历下的前驱节点：</li><li>如果前驱节点的右子节点为空，将前驱节点的右子节点设置为当前节点。然后将当前节点加入答案，并将前驱节点的右子节点更新为当前节点。当前节点更新为当前节点的左子节点。</li><li>如果前驱节点的右子节点为当前节点，将它的右子节点重新设为空。当前节点更新为当前节点的右子节点。</li><li>重复步骤 2 和步骤 3，直到遍历结束。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">preorderTraversal</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">p1</span> <span class="operator">=</span> root, p2 = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (p1 != <span class="literal">null</span>) &#123;</span><br><span class="line">        p2 = p1.left;</span><br><span class="line">        <span class="keyword">if</span> (p2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (p2.right != <span class="literal">null</span> &amp;&amp; p2.right != p1) &#123;</span><br><span class="line">                p2 = p2.right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (p2.right == <span class="literal">null</span>) &#123;</span><br><span class="line">                res.add(p1.val);</span><br><span class="line">                p2.right = p1;</span><br><span class="line">                p1 = p1.left;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                p2.right = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res.add(p1.val);</span><br><span class="line">        &#125;</span><br><span class="line">        p1 = p1.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li>时间复杂度：O(n)，其中 n 是二叉树的节点数。没有左子树的节点只被访问一次，有左子树的节点被访问两次。</li><li>空间复杂度：O(1)。只操作已经存在的指针（树的空闲指针），因此只需要常数的额外空间。</li></ul><h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><blockquote><p><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/" title="二叉树的前序遍历 | 力扣（LeetCode）">二叉树的前序遍历 | 力扣（LeetCode）</a><br><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/solution/er-cha-shu-de-qian-xu-bian-li-by-leetcode-solution/" title="二叉树的前序遍历 | 题解（LeetCode）">二叉树的前序遍历 | 题解（LeetCode）</a></p></blockquote><hr>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;给你二叉树的根节点 root ，返回它节点值的 前序 遍历。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1：&lt;/strong&gt;&lt;/p&gt;
&lt;img src=&quot;/blog/2020/10/27/binary-tree-preorder-traversal/inorder.jpg&quot; class=&quot;&quot; title=&quot;前序遍历&quot;&gt;
&lt;blockquote&gt;
&lt;p&gt;输入：root = [1, null, 2, 3]&lt;br&gt;输出：[1, 2, 3]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例 2：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入：root = []&lt;br&gt;输出：[]&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://www.cylong.com/categories/LeetCode/"/>
    
    
    <category term="Java" scheme="https://www.cylong.com/tags/Java/"/>
    
    <category term="LeetCode" scheme="https://www.cylong.com/tags/LeetCode/"/>
    
    <category term="学习笔记" scheme="https://www.cylong.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="递归" scheme="https://www.cylong.com/tags/%E9%80%92%E5%BD%92/"/>
    
    <category term="树" scheme="https://www.cylong.com/tags/%E6%A0%91/"/>
    
    <category term="二叉树" scheme="https://www.cylong.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    <category term="深度优先搜索" scheme="https://www.cylong.com/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
  </entry>
  
  <entry>
    <title>划分字母区间</title>
    <link href="https://www.cylong.com/blog/2020/10/22/partition-labels/"/>
    <id>https://www.cylong.com/blog/2020/10/22/partition-labels/</id>
    <published>2020-10-22T15:08:50.000Z</published>
    <updated>2020-10-22T15:08:50.000Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>字符串 S 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。返回一个表示每个字符串片段的长度的列表。</p><p><strong>示例：</strong></p><blockquote><p>输入：S = “ababcbacadefegdehijhklij”<br>输出：[9, 7, 8]<br>解释：<br>划分结果为 “ababcbaca”, “defegde”, “hijhklij”。<br>每个字母最多出现在一个片段中。像 “ababcbacadefegde”, “hijhklij” 的划分是错误的，因为划分的片段数较少。</p></blockquote><p><strong>提示：</strong></p><ul><li>S的长度在 [1, 500] 之间。</li><li>S只包含小写字母 ‘a’ 到 ‘z’。</li></ul><span id="more"></span><h1 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h1><p>由于同一个字母只能出现在同一个片段，显然同一个字母的第一次出现的下标位置和最后一次出现的下标位置必须出现在同一个片段。我们从第一个字母开始遍历，初始的时候，我们认为划分的字符串就是当前字母，即 <code>maxLen = 1</code>，然后我们求当前字母的最后一次出现的下标 index。并更新当前划分的字符串最长长度为 <code>maxLen = Math.max(index + 1, maxLen)</code>。遍历的截止条件就是 <code>i &lt; maxLen</code>。说明已经满足了题目条件。接下来，我们只要递归的处理剩下的字符串即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">partitionLabels</span><span class="params">(String S)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (S == <span class="literal">null</span> || S.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxLen</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; maxLen; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> S.lastIndexOf(S.charAt(i));</span><br><span class="line">        maxLen = Math.max(index + <span class="number">1</span>, maxLen);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ans.add(maxLen);</span><br><span class="line">    partitionLabels(S.substring(maxLen));</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考官方的解法后发现，其实以上代码有几处可以优化的点，首先就是，我们可以先遍历一遍字符串，求出每个字符最后一次出现的下标位置。在得到每个字母最后一次出现的下标位置之后，可以使用贪心算法和双指针的方法将字符串划分为尽可能多的片段，具体做法如下。</p><ul><li>从左到右遍历字符串，遍历的同时维护当前片段的开始下标 start 和结束下标 end，初始时 <code>start = end = 0</code>。</li><li>对于每个访问到的字母 c，得到当前字母的最后一次出现的下标位置 end_c，则当前片段的结束下标一定不会小于 end_c，因此令 <code>end = max(end, end_c)</code>。</li><li>当访问到下标 end 时，当前片段访问结束，当前片段的下标范围是 [start, end]，长度为 <code>end − start + 1</code>，将当前片段的长度添加到返回值，然后令 <code>start = end + 1</code>，继续寻找下一个片段。</li><li>重复上述过程，直到遍历完字符串。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">partitionLabels</span><span class="params">(String S)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] last = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> S.length();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        last[S.charAt(i) - <span class="string">&#x27;a&#x27;</span>] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    List&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        end = Math.max(end, last[S.charAt(i) - <span class="string">&#x27;a&#x27;</span>]);</span><br><span class="line">        <span class="keyword">if</span> (i == end) &#123;</span><br><span class="line">            ans.add(end - start + <span class="number">1</span>);</span><br><span class="line">            start = end + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li>时间复杂度：O(n)，其中 n 是字符串的长度。需要遍历字符串两次，第一次遍历时记录每个字母最后一次出现的下标位置，第二次遍历时进行字符串的划分。</li><li>空间复杂度：O(Σ)，其中 Σ 是字符串中的字符集大小。这道题中，字符串只包含小写字母，因此 Σ = 26。</li></ul><h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><blockquote><p><a href="https://leetcode-cn.com/problems/partition-labels/" title="划分字母区间 | 力扣（LeetCode）">划分字母区间 | 力扣（LeetCode）</a><br><a href="https://leetcode-cn.com/problems/partition-labels/solution/hua-fen-zi-mu-qu-jian-by-leetcode-solution/" title="划分字母区间 | 题解（LeetCode）">划分字母区间 | 题解（LeetCode）</a></p></blockquote><hr>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;字符串 S 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。返回一个表示每个字符串片段的长度的列表。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例：&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;输入：S = “ababcbacadefegdehijhklij”&lt;br&gt;输出：[9, 7, 8]&lt;br&gt;解释：&lt;br&gt;划分结果为 “ababcbaca”, “defegde”, “hijhklij”。&lt;br&gt;每个字母最多出现在一个片段中。像 “ababcbacadefegde”, “hijhklij” 的划分是错误的，因为划分的片段数较少。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;提示：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;S的长度在 [1, 500] 之间。&lt;/li&gt;
&lt;li&gt;S只包含小写字母 ‘a’ 到 ‘z’。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://www.cylong.com/categories/LeetCode/"/>
    
    
    <category term="Java" scheme="https://www.cylong.com/tags/Java/"/>
    
    <category term="LeetCode" scheme="https://www.cylong.com/tags/LeetCode/"/>
    
    <category term="学习笔记" scheme="https://www.cylong.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="字符串" scheme="https://www.cylong.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    <category term="指针" scheme="https://www.cylong.com/tags/%E6%8C%87%E9%92%88/"/>
    
    <category term="双指针" scheme="https://www.cylong.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
    <category term="贪心算法" scheme="https://www.cylong.com/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
    <category term="递归" scheme="https://www.cylong.com/tags/%E9%80%92%E5%BD%92/"/>
    
  </entry>
  
</feed>
