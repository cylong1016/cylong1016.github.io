<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>笑话人生</title>
  
  <subtitle>年华易逝 懂得珍惜</subtitle>
  <link href="https://www.cylong.com/atom.xml" rel="self"/>
  
  <link href="https://www.cylong.com/"/>
  <updated>2025-08-21T16:49:13.000Z</updated>
  <id>https://www.cylong.com/</id>
  
  <author>
    <name>cylong</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>贪心算法判断数组终点可达性：维护最大位置（LeetCode 55）</title>
    <link href="https://www.cylong.com/blog/2025/08/22/jump-game/"/>
    <id>https://www.cylong.com/blog/2025/08/22/jump-game/</id>
    <published>2025-08-21T16:49:13.000Z</published>
    <updated>2025-08-21T16:49:13.000Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给你一个非负整数数组 <code>nums</code> ，你最初位于数组的第一个下标 。数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>判断你是否能够到达最后一个下标，如果可以，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p><strong>示例 1:</strong></p><blockquote><p><strong>输入：</strong><code>nums = [2, 3, 1, 1, 4]</code><br><strong>输出：</strong><code>true</code><br><strong>解释：</strong>可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。</p></blockquote><p><strong>示例 2:</strong></p><blockquote><p><strong>输入：</strong><code>nums = [3, 2, 1, 0, 4]</code><br><strong>输出：</strong><code>false</code><br><strong>解释：</strong>无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。</p></blockquote><p><strong>提示:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 10^4</code></li><li><code>0 &lt;= nums[i] &lt;= 10^5</code></li></ul><span id="more"></span><h1 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h1><h2 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h2><p>维护一个变量 <code>max</code>，表示当前能够到达的最远位置。遍历数组时，对于每个位置 <code>i</code>，如果 <code>i</code> 在当前能够到达的范围内（即 <code>i &lt;= max</code>），则更新 <code>max</code> 为 <code>max</code> 和 <code>i + nums[i]</code> 中的较大值。如果 <code>max</code> 已经大于或等于数组的最后一个位置（即数组长度减一），则说明可以到达最后一个位置，返回 <code>true</code>。如果遍历结束都没有达到最后一个位置，则返回 <code>false</code>。</p><p>这种方法确保了在每一步都贪心地扩展最远可达距离，从而高效地判断是否可达。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canJump</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length; <span class="comment">// 数组长度</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 当前能到达的最远位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="comment">// 如果当前索引i在可达范围内，才更新最远位置</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt;= max) &#123;</span><br><span class="line">            <span class="comment">// 更新最远可达位置：取当前最远位置和i + nums[i]的较大值</span></span><br><span class="line">            max = Math.max(max, i + nums[i]);</span><br><span class="line">            <span class="comment">// 如果最远可达位置已经超过或等于最后一个位置，则返回true</span></span><br><span class="line">            <span class="keyword">if</span> (max &gt;= len - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 遍历结束仍未到达最后位置，返回false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li><strong>时间复杂度：</strong><code>O(n)</code>，其中 <code>n</code> 是数组的长度。我们只需要遍历数组一次。</li><li><strong>空间复杂度：</strong><code>O(1)</code>，只使用了常数级别的额外空间。</li></ul><h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><blockquote><p><a href="https://leetcode.cn/problems/jump-game/description/" title="55. 跳跃游戏 | 力扣（LeetCode）">55. 跳跃游戏 | 力扣（LeetCode）</a></p></blockquote><hr>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;给你一个非负整数数组 &lt;code&gt;nums&lt;/code&gt; ，你最初位于数组的第一个下标 。数组中的每个元素代表你在该位置可以跳跃的最大长度。&lt;/p&gt;
&lt;p&gt;判断你是否能够到达最后一个下标，如果可以，返回 &lt;code&gt;true&lt;/code&gt; ；否则，返回 &lt;code&gt;false&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt;&lt;code&gt;nums = [2, 3, 1, 1, 4]&lt;/code&gt;&lt;br&gt;&lt;strong&gt;输出：&lt;/strong&gt;&lt;code&gt;true&lt;/code&gt;&lt;br&gt;&lt;strong&gt;解释：&lt;/strong&gt;可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt;&lt;code&gt;nums = [3, 2, 1, 0, 4]&lt;/code&gt;&lt;br&gt;&lt;strong&gt;输出：&lt;/strong&gt;&lt;code&gt;false&lt;/code&gt;&lt;br&gt;&lt;strong&gt;解释：&lt;/strong&gt;无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;提示:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= nums.length &amp;lt;= 10^4&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0 &amp;lt;= nums[i] &amp;lt;= 10^5&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://www.cylong.com/categories/LeetCode/"/>
    
    
    <category term="Java" scheme="https://www.cylong.com/tags/Java/"/>
    
    <category term="LeetCode" scheme="https://www.cylong.com/tags/LeetCode/"/>
    
    <category term="学习笔记" scheme="https://www.cylong.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="贪心算法" scheme="https://www.cylong.com/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
    <category term="LeetCode中等" scheme="https://www.cylong.com/tags/LeetCode%E4%B8%AD%E7%AD%89/"/>
    
  </entry>
  
  <entry>
    <title>一次遍历计算买卖股票的最佳时机（LeetCode 121）</title>
    <link href="https://www.cylong.com/blog/2025/08/21/best-time-to-buy-and-sell-stock/"/>
    <id>https://www.cylong.com/blog/2025/08/21/best-time-to-buy-and-sell-stock/</id>
    <published>2025-08-21T03:05:21.000Z</published>
    <updated>2025-08-21T03:05:21.000Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格。</p><p>你只能选择 <strong>某一天</strong> 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 <code>0</code> 。</p><p><strong>示例 1:</strong></p><blockquote><p><strong>输入：</strong><code>prices = [7, 1, 5, 3, 6, 4]</code><br><strong>输出：</strong><code>5</code><br><strong>解释：</strong>在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。</p></blockquote><p><strong>示例 2:</strong></p><blockquote><p><strong>输入：</strong><code>prices = [7, 6, 4, 3, 1]</code><br><strong>输出：</strong><code>0</code><br><strong>解释：</strong>在这种情况下, 没有交易完成, 所以最大利润为 0。</p></blockquote><p><strong>提示:</strong></p><ul><li><code>1 &lt;= prices.length &lt;= 10^5</code></li><li><code>0 &lt;= prices[i] &lt;= 10^4</code></li></ul><span id="more"></span><h1 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h1><h2 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h2><p>我们可以通过遍历数组一次来计算最大利润。在遍历过程中，记录当前遇到的最小价格，并计算当前价格与最小价格的差值（即利润），同时更新最大利润。</p><ul><li><strong>初始化：</strong>将最小价格设置为一个很大的值（如 <code>Integer.MAX_VALUE</code>），将最大利润设置为 <code>0</code>。</li><li><strong>遍历数组：</strong><ul><li>如果当前价格小于最小价格，更新最小价格。</li><li>否则，计算当前价格与最小价格的差值，如果大于当前最大利润，则更新最大利润。</li></ul></li><li><strong>返回最大利润</strong></li></ul><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果数组为空或长度为零，直接返回0</span></span><br><span class="line">    <span class="keyword">if</span> (prices == <span class="literal">null</span> || prices.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化最小价格为最大整数，最大利润为0</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">minPrice</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">    <span class="type">int</span> <span class="variable">maxProfit</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 遍历价格数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (prices[i] &lt; minPrice) &#123;</span><br><span class="line">            <span class="comment">// 如果当前价格小于最小价格，更新最小价格</span></span><br><span class="line">            minPrice = prices[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (prices[i] - minPrice &gt; maxProfit) &#123;</span><br><span class="line">            <span class="comment">// 如果当前价格减去最小价格大于最大利润，更新最大利润</span></span><br><span class="line">            maxProfit = prices[i] - minPrice;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxProfit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li><strong>时间复杂度：</strong><code>O(n)</code>，其中 <code>n</code> 是数组的长度。我们只需要遍历数组一次。</li><li><strong>空间复杂度：</strong><code>O(1)</code>，只使用了常数级别的额外空间。</li></ul><h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><blockquote><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/description/" title="121. 买卖股票的最佳时机 | 力扣（LeetCode）">121. 买卖股票的最佳时机 | 力扣（LeetCode）</a></p></blockquote><hr>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;给定一个数组 &lt;code&gt;prices&lt;/code&gt; ，它的第 &lt;code&gt;i&lt;/code&gt; 个元素 &lt;code&gt;prices[i]&lt;/code&gt; 表示一支给定股票第 &lt;code&gt;i&lt;/code&gt; 天的价格。&lt;/p&gt;
&lt;p&gt;你只能选择 &lt;strong&gt;某一天&lt;/strong&gt; 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 &lt;code&gt;0&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt;&lt;code&gt;prices = [7, 1, 5, 3, 6, 4]&lt;/code&gt;&lt;br&gt;&lt;strong&gt;输出：&lt;/strong&gt;&lt;code&gt;5&lt;/code&gt;&lt;br&gt;&lt;strong&gt;解释：&lt;/strong&gt;在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt;&lt;code&gt;prices = [7, 6, 4, 3, 1]&lt;/code&gt;&lt;br&gt;&lt;strong&gt;输出：&lt;/strong&gt;&lt;code&gt;0&lt;/code&gt;&lt;br&gt;&lt;strong&gt;解释：&lt;/strong&gt;在这种情况下, 没有交易完成, 所以最大利润为 0。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;提示:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= prices.length &amp;lt;= 10^5&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0 &amp;lt;= prices[i] &amp;lt;= 10^4&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://www.cylong.com/categories/LeetCode/"/>
    
    
    <category term="Java" scheme="https://www.cylong.com/tags/Java/"/>
    
    <category term="LeetCode" scheme="https://www.cylong.com/tags/LeetCode/"/>
    
    <category term="学习笔记" scheme="https://www.cylong.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="贪心算法" scheme="https://www.cylong.com/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
    <category term="LeetCode中等" scheme="https://www.cylong.com/tags/LeetCode%E4%B8%AD%E7%AD%89/"/>
    
  </entry>
  
  <entry>
    <title>哈希表统计与桶排序筛选前 K 个高频元素（LeetCode 347）</title>
    <link href="https://www.cylong.com/blog/2025/08/19/top-k-frequent-elements/"/>
    <id>https://www.cylong.com/blog/2025/08/19/top-k-frequent-elements/</id>
    <published>2025-08-19T15:10:03.000Z</published>
    <updated>2025-08-19T15:10:03.000Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，请你返回其中出现频率前 <code>k</code> 高的元素。你可以按 <strong>任意顺序</strong> 返回答案。</p><p>你所设计算法的时间复杂度 <strong>必须</strong> 优于 <code>O(n log n)</code> ，其中 <code>n</code> 是数组大小。</p><p><strong>示例 1:</strong></p><blockquote><p><strong>输入：</strong><code>nums = [1, 1, 1, 2, 2, 3]</code>, <code>k = 2</code><br><strong>输出：</strong><code>[1, 2]</code></p></blockquote><p><strong>示例 2:</strong></p><blockquote><p><strong>输入：</strong><code>nums = [1]</code>, <code>k = 1</code><br><strong>输出：</strong><code>[1]</code></p></blockquote><p><strong>提示:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 10^5</code></li><li><code>k</code> 的取值范围是 <code>[1, 数组中不相同的元素的个数]</code></li><li>题目数据保证答案唯一，换句话说，数组中前 <code>k</code> 个高频元素的集合是唯一的</li></ul><span id="more"></span><h1 id="哈希表-频率映射"><a href="#哈希表-频率映射" class="headerlink" title="哈希表 + 频率映射"></a>哈希表 + 频率映射</h1><h2 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h2><p>使用哈希表统计频率，然后通过映射频率到数字列表，最后从高到低遍历频率；</p><ol><li><strong>统计频率：</strong>使用哈希表记录每个数字出现的次数。</li><li><strong>频率映射：</strong>创建另一个哈希表，将频率作为键，对应的数字列表作为值。</li><li><strong>收集结果：</strong>从最高频率（最大可能为数组长度）向下遍历，收集数字直到收集到 <code>k</code> 个。</li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] topKFrequent(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">    <span class="comment">// 处理边界情况</span></span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤1：统计每个数字的出现次数</span></span><br><span class="line">    Map&lt;Integer, Integer&gt; numToCountMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">        <span class="comment">// 使用 merge 方法统计次数，等价于 getOrDefault 和 put</span></span><br><span class="line">        <span class="comment">// numToCountMap.put(num, numToCountMap.getOrDefault(num, 0) + 1);</span></span><br><span class="line">        numToCountMap.merge(num, <span class="number">1</span>, Integer::sum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤2：将频率映射到数字列表</span></span><br><span class="line">    Map&lt;Integer, List&lt;Integer&gt;&gt; countToNumMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : numToCountMap.entrySet()) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> entry.getKey();</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> entry.getValue();</span><br><span class="line">        <span class="comment">// 如果该频率还没有列表，创建一个新列表</span></span><br><span class="line">        <span class="keyword">if</span> (!countToNumMap.containsKey(count)) &#123;</span><br><span class="line">            countToNumMap.put(count, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将数字添加到对应频率的列表中</span></span><br><span class="line">        countToNumMap.get(count).add(num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤3：从最高频率开始收集数字</span></span><br><span class="line">    List&lt;Integer&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">// 频率最大可能为数组长度，从高到低遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> nums.length; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (countToNumMap.containsKey(i)) &#123;</span><br><span class="line">            List&lt;Integer&gt; numList = countToNumMap.get(i);</span><br><span class="line">            <span class="keyword">for</span> (Integer num : numList) &#123;</span><br><span class="line">                res.add(num);</span><br><span class="line">                <span class="comment">// 如果已收集到 k 个数字，转换为数组返回</span></span><br><span class="line">                <span class="keyword">if</span> (res.size() == k) &#123;</span><br><span class="line">                    <span class="keyword">return</span> res.stream().mapToInt(Integer::intValue).toArray();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li><strong>时间复杂度：</strong><code>O(n)</code>，其中 <code>n</code> 是数组的长度。统计频率需要 <code>O(n)</code>，映射频率需要 <code>O(n)</code>，收集结果时最坏情况需要遍历所有频率（从 <code>n</code> 到 <code>0</code>），但每个数字只被处理一次，因此总体是 <code>O(n)</code>。</li><li><strong>空间复杂度：</strong><code>O(n)</code>，需要两个哈希表来存储数字和频率的映射关系，最坏情况下每个数字的频率都不同，因此需要 <code>O(n)</code> 空间。</li></ul><h1 id="哈希表-桶排序"><a href="#哈希表-桶排序" class="headerlink" title="哈希表 + 桶排序"></a>哈希表 + 桶排序</h1><h2 id="核心思路-1"><a href="#核心思路-1" class="headerlink" title="核心思路"></a>核心思路</h2><p>将数字按频率分配到不同的桶中，然后从高频率桶开始收集元素。思路和方法一一致，这里其实只是把代码做了一些优化</p><ol><li><strong>统计频率：</strong>使用哈希表记录每个数字出现的次数。</li><li><strong>桶排序：</strong>创建一个桶数组，索引表示频率，每个桶存储具有该频率的数字列表。（<strong>与方法一区别：</strong><code>Map</code> 改为数组）</li><li><strong>收集结果：</strong>从最高频率桶开始向下遍历，收集数字直到收集到 <code>k</code> 个。（<strong>与方法一区别：</strong> 频率最大由数组长度优化为统计后的最大值）</li></ol><h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] topKFrequent(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">    <span class="comment">// 处理边界情况</span></span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤1：统计每个数字的出现次数</span></span><br><span class="line">    Map&lt;Integer, Integer&gt; numToCountMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">        <span class="comment">// 使用 merge 方法统计次数，等价于 getOrDefault 和 put</span></span><br><span class="line">        <span class="comment">// numToCountMap.put(num, numToCountMap.getOrDefault(num, 0) + 1);</span></span><br><span class="line">        <span class="comment">// 1-&gt;3, 2-&gt;2, 3-&gt;1</span></span><br><span class="line">        numToCountMap.merge(num, <span class="number">1</span>, Integer::sum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤2：创建桶数组，索引代表频率</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">maxCnt</span> <span class="operator">=</span> Collections.max(numToCountMap.values()); <span class="comment">// 获取最大频率</span></span><br><span class="line">    List&lt;Integer&gt;[] buckets = <span class="keyword">new</span> <span class="title class_">ArrayList</span>[maxCnt + <span class="number">1</span>];  <span class="comment">// 桶数组，从 0 到 maxCnt</span></span><br><span class="line">    Arrays.setAll(buckets, i -&gt; <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());       <span class="comment">// 初始化每个桶为空列表</span></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Integer, Integer&gt; entry : numToCountMap.entrySet()) &#123;</span><br><span class="line">        <span class="comment">// 将数字添加到对应频率的桶中</span></span><br><span class="line">        <span class="comment">// 1-&gt;[3], 2-&gt;[2], 3-&gt;[1]</span></span><br><span class="line">        buckets[entry.getValue()].add(entry.getKey());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤3：从最高频率桶开始收集数字</span></span><br><span class="line">    <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> buckets.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Integer num : buckets[i]) &#123;</span><br><span class="line">            res[--k] = num;</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li><strong>时间复杂度：</strong><code>O(n)</code>，其中 <code>n</code> 是数组的长度。统计频率需要 <code>O(n)</code>，创建桶需要 <code>O(n)</code>，收集结果需要 <code>O(n)</code>（因为每个数字只被处理一次）。</li><li><strong>空间复杂度：</strong><code>O(n)</code>，需要哈希表存储频率，桶数组的空间最多为 <code>O(n)</code>。</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>两种方法都是基于频率统计，但方法二使用桶排序更直观，效率也更高，因为避免了在方法一中可能的多余遍历。方法二的空间复杂度略高，但实际应用中差异不大。推荐使用方法二，代码更简洁且易于理解。</p><h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><blockquote><p><a href="https://leetcode.cn/problems/top-k-frequent-elements/description/" title="347. 前 K 个高频元素 | 力扣（LeetCode）">347. 前 K 个高频元素 | 力扣（LeetCode）</a><br><a href="https://leetcode.cn/problems/top-k-frequent-elements/solutions/3655287/tong-pai-xu-on-xian-xing-zuo-fa-pythonja-oqq2/" title="347. 前 K 个高频元素 | 题解 | 灵茶山艾府">347. 前 K 个高频元素 | 题解 | 灵茶山艾府</a></p></blockquote><hr>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;给你一个整数数组 &lt;code&gt;nums&lt;/code&gt; 和一个整数 &lt;code&gt;k&lt;/code&gt; ，请你返回其中出现频率前 &lt;code&gt;k&lt;/code&gt; 高的元素。你可以按 &lt;strong&gt;任意顺序&lt;/strong&gt; 返回答案。&lt;/p&gt;
&lt;p&gt;你所设计算法的时间复杂度 &lt;strong&gt;必须&lt;/strong&gt; 优于 &lt;code&gt;O(n log n)&lt;/code&gt; ，其中 &lt;code&gt;n&lt;/code&gt; 是数组大小。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt;&lt;code&gt;nums = [1, 1, 1, 2, 2, 3]&lt;/code&gt;, &lt;code&gt;k = 2&lt;/code&gt;&lt;br&gt;&lt;strong&gt;输出：&lt;/strong&gt;&lt;code&gt;[1, 2]&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt;&lt;code&gt;nums = [1]&lt;/code&gt;, &lt;code&gt;k = 1&lt;/code&gt;&lt;br&gt;&lt;strong&gt;输出：&lt;/strong&gt;&lt;code&gt;[1]&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;提示:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= nums.length &amp;lt;= 10^5&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;k&lt;/code&gt; 的取值范围是 &lt;code&gt;[1, 数组中不相同的元素的个数]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;题目数据保证答案唯一，换句话说，数组中前 &lt;code&gt;k&lt;/code&gt; 个高频元素的集合是唯一的&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://www.cylong.com/categories/LeetCode/"/>
    
    
    <category term="Java" scheme="https://www.cylong.com/tags/Java/"/>
    
    <category term="LeetCode" scheme="https://www.cylong.com/tags/LeetCode/"/>
    
    <category term="学习笔记" scheme="https://www.cylong.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="数组" scheme="https://www.cylong.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="哈希表" scheme="https://www.cylong.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
    <category term="LeetCode中等" scheme="https://www.cylong.com/tags/LeetCode%E4%B8%AD%E7%AD%89/"/>
    
    <category term="分治" scheme="https://www.cylong.com/tags/%E5%88%86%E6%B2%BB/"/>
    
    <category term="堆" scheme="https://www.cylong.com/tags/%E5%A0%86/"/>
    
    <category term="桶" scheme="https://www.cylong.com/tags/%E6%A1%B6/"/>
    
  </entry>
  
  <entry>
    <title>基于分治思想的第 K 大元素查找实现（LeetCode 215）</title>
    <link href="https://www.cylong.com/blog/2025/08/18/kth-largest-element-in-an-array/"/>
    <id>https://www.cylong.com/blog/2025/08/18/kth-largest-element-in-an-array/</id>
    <published>2025-08-18T15:14:00.000Z</published>
    <updated>2025-08-18T15:14:00.000Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定整数数组 <code>nums</code> 和整数 <code>k</code>，请返回数组中第 <code>k</code> 个最大的元素。请注意，你需要找的是数组排序后的第 <code>k</code> 个最大的元素，而不是第 <code>k</code> 个不同的元素。</p><p>你必须设计并实现时间复杂度为 <code>O(n)</code> 的算法解决此问题。</p><p><strong>示例 1:</strong></p><blockquote><p><strong>输入：</strong><code>[3, 2, 1, 5, 6, 4]</code>, <code>k = 2</code><br><strong>输出：</strong><code>5</code></p></blockquote><p><strong>示例 2:</strong></p><blockquote><p><strong>输入：</strong><code>[3, 2, 3, 1, 2, 4, 5, 5, 6]</code>, <code>k = 4</code><br><strong>输出：</strong><code>4</code></p></blockquote><p><strong>提示:</strong></p><ul><li><code>1 &lt;= k &lt;= nums.length &lt;= 10^5</code></li><li><code>-10^4 &lt;= nums[i] &lt;= 10^4</code></li></ul><span id="more"></span><h1 id="直接排序"><a href="#直接排序" class="headerlink" title="直接排序"></a>直接排序</h1><h2 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h2><p>将数组升序排序后，第 <code>k</code> 大的元素位于索引 <code>nums.length - k</code> 处。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Arrays.sort(nums);            <span class="comment">// 升序排序</span></span><br><span class="line">    <span class="keyword">return</span> nums[nums.length - k]; <span class="comment">// 返回倒数第k个元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li><strong>时间复杂度：</strong><code>O(n log n)</code>，由排序算法决定。</li><li><strong>空间复杂度：</strong><code>O(1)</code>（忽略排序的栈空间开销）。</li></ul><h1 id="快速选择（分治）"><a href="#快速选择（分治）" class="headerlink" title="快速选择（分治）"></a>快速选择（分治）</h1><h2 id="核心思路-1"><a href="#核心思路-1" class="headerlink" title="核心思路"></a>核心思路</h2><p>利用快速排序的分区思想：</p><ol><li>随机选择基准值 <code>pivot</code>。</li><li>将数组分为三部分：<code>big</code>（大于 <code>pivot</code>）、<code>small</code>（小于 <code>pivot</code>）和等于 <code>pivot</code> 的元素。</li><li>根据 <code>k</code> 与 <code>big.size()</code> 的关系递归处理：<ul><li>若 <code>k &lt;= big.size()</code>：第 <code>k</code> 大元素在 <code>big</code> 中。</li><li>若 <code>k &gt; nums.size() - small.size()</code>：第 <code>k</code> 大元素在 <code>small</code> 中（需调整 <code>k</code> 值）。</li><li>否则，<code>pivot</code> 即为目标值。</li></ul></li></ol><h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    List&lt;Integer&gt; numList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">        numList.add(num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> quickSelect(numList, k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">quickSelect</span><span class="params">(List&lt;Integer&gt; nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="comment">// 随机选择基准值</span></span><br><span class="line">    <span class="type">Random</span> <span class="variable">rand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> nums.get(rand.nextInt(nums.size()));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 划分大于、小于基准值的元素</span></span><br><span class="line">    List&lt;Integer&gt; big = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; small = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (num &gt; pivot) &#123;</span><br><span class="line">            big.add(num);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num &lt; pivot) &#123;</span><br><span class="line">            small.add(num();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (k &lt;= big.size()) &#123;</span><br><span class="line">        <span class="comment">// 在 big 中递归查找</span></span><br><span class="line">        <span class="keyword">return</span> quickSelect(big, k);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums.size() - small.size() &lt; k) &#123;</span><br><span class="line">        <span class="comment">// 调整 k 值后在 small 中查找</span></span><br><span class="line">        <span class="keyword">return</span> quickSelect(small, k - (nums.size() - small.size()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// pivot 是第 k 大元素</span></span><br><span class="line">    <span class="keyword">return</span> pivot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li><strong>时间复杂度：</strong>平均 <code>O(n)</code>，最坏 <code>O(n²)</code>（随机化避免最坏情况）。</li><li><strong>空间复杂度：</strong><code>O(n)</code>（递归栈和列表存储）。</li></ul><h1 id="原地快速选择（空间优化）"><a href="#原地快速选择（空间优化）" class="headerlink" title="原地快速选择（空间优化）"></a>原地快速选择（空间优化）</h1><h2 id="核心思路-2"><a href="#核心思路-2" class="headerlink" title="核心思路"></a>核心思路</h2><p>在方法二基础上优化空间：</p><ol><li>目标位置 <code>target = nums.length - k</code>（升序后第 <code>target</code> 个元素）。</li><li>分区时随机选择基准值并交换到末尾。</li><li>使用双指针分区：<ul><li><code>i</code> 标记小于基准值的边界。</li><li>遍历数组，将小于基准值的元素交换到 <code>i</code> 左侧。</li></ul></li><li>根据分区结果递归左/右子数组。</li></ol><h2 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> n - k; <span class="comment">// 升序排序后第 target 个元素是第 k 大</span></span><br><span class="line">    <span class="keyword">return</span> quickSelect(nums, <span class="number">0</span>, n - <span class="number">1</span>, target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="title function_">quickSelect</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">    <span class="comment">// 递归终止</span></span><br><span class="line">    <span class="keyword">if</span> (left == right) &#123;</span><br><span class="line">        <span class="keyword">return</span> nums[left];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 随机选择基准值并交换到末尾</span></span><br><span class="line">    <span class="type">Random</span> <span class="variable">rand</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">pivotIdx</span> <span class="operator">=</span> left + rand.nextInt(right - left + <span class="number">1</span>);</span><br><span class="line">    swap(nums, pivotIdx, right);</span><br><span class="line">    <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> nums[right];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 分区操作</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> left; <span class="comment">// i 左侧元素均 &lt; pivot</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> left; j &lt; right; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[j] &lt; pivot) &#123;</span><br><span class="line">            swap(nums, i, j);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap(nums, i, right); <span class="comment">// 将基准值放到正确位置</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (i == target) &#123;</span><br><span class="line">        <span class="keyword">return</span> nums[i]; <span class="comment">// 找到目标</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &lt; target) &#123;</span><br><span class="line">        <span class="keyword">return</span> quickSelect(nums, i + <span class="number">1</span>, right, target); <span class="comment">// 递归右子数组</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> quickSelect(nums, left, i - <span class="number">1</span>, target); <span class="comment">// 递归左子数组</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> nums[i];</span><br><span class="line">    nums[i] = nums[j];</span><br><span class="line">    nums[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li><strong>时间复杂度：</strong>平均 <code>O(n)</code>，最坏 <code>O(n²)</code>（随机化避免最坏情况）。</li><li><strong>空间复杂度：</strong><code>O(1)</code>（原地分区），递归栈平均 <code>O(log n)</code>。</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><table><thead><tr><th>解法</th><th>时间复杂度</th><th>空间复杂度</th><th>适用场景</th></tr></thead><tbody><tr><td>直接排序</td><td>O(n log n)</td><td>O(1)</td><td>快速实现</td></tr><tr><td>快速选择（分治）</td><td>平均 O(n)</td><td>O(n)</td><td>无需严格空间约束</td></tr><tr><td>原地快速选择</td><td>平均 O(n)</td><td>O(log n)</td><td>空间效率最优</td></tr></tbody></table><p>实际应用中，原地快速选择综合性能最佳，尤其适合处理大规模数据。</p><h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><blockquote><p><a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/description/" title="215. 数组中的第K个最大元素 | 力扣（LeetCode）">215. 数组中的第K个最大元素 | 力扣（LeetCode）</a><br><a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/solutions/2361969/215-shu-zu-zhong-de-di-k-ge-zui-da-yuan-d786p/" title="215. 数组中的第K个最大元素 | 题解 | Krahets">215. 数组中的第K个最大元素 | 题解 | Krahets</a></p></blockquote><hr>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;给定整数数组 &lt;code&gt;nums&lt;/code&gt; 和整数 &lt;code&gt;k&lt;/code&gt;，请返回数组中第 &lt;code&gt;k&lt;/code&gt; 个最大的元素。请注意，你需要找的是数组排序后的第 &lt;code&gt;k&lt;/code&gt; 个最大的元素，而不是第 &lt;code&gt;k&lt;/code&gt; 个不同的元素。&lt;/p&gt;
&lt;p&gt;你必须设计并实现时间复杂度为 &lt;code&gt;O(n)&lt;/code&gt; 的算法解决此问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt;&lt;code&gt;[3, 2, 1, 5, 6, 4]&lt;/code&gt;, &lt;code&gt;k = 2&lt;/code&gt;&lt;br&gt;&lt;strong&gt;输出：&lt;/strong&gt;&lt;code&gt;5&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt;&lt;code&gt;[3, 2, 3, 1, 2, 4, 5, 5, 6]&lt;/code&gt;, &lt;code&gt;k = 4&lt;/code&gt;&lt;br&gt;&lt;strong&gt;输出：&lt;/strong&gt;&lt;code&gt;4&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;提示:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= k &amp;lt;= nums.length &amp;lt;= 10^5&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-10^4 &amp;lt;= nums[i] &amp;lt;= 10^4&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://www.cylong.com/categories/LeetCode/"/>
    
    
    <category term="Java" scheme="https://www.cylong.com/tags/Java/"/>
    
    <category term="LeetCode" scheme="https://www.cylong.com/tags/LeetCode/"/>
    
    <category term="学习笔记" scheme="https://www.cylong.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="数组" scheme="https://www.cylong.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="双指针" scheme="https://www.cylong.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
    <category term="LeetCode中等" scheme="https://www.cylong.com/tags/LeetCode%E4%B8%AD%E7%AD%89/"/>
    
    <category term="分治" scheme="https://www.cylong.com/tags/%E5%88%86%E6%B2%BB/"/>
    
    <category term="堆" scheme="https://www.cylong.com/tags/%E5%A0%86/"/>
    
  </entry>
  
  <entry>
    <title>递归操作解析嵌套编码字符串：数字与字符分段处理（LeetCode 394）</title>
    <link href="https://www.cylong.com/blog/2025/08/17/decode-string/"/>
    <id>https://www.cylong.com/blog/2025/08/17/decode-string/</id>
    <published>2025-08-17T12:50:34.000Z</published>
    <updated>2025-08-17T12:50:34.000Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个经过编码的字符串，返回它解码后的字符串。编码规则为: <code>k[encoded_string]</code>，表示其中方括号内部的 <code>encoded_string</code> 正好重复 <code>k</code> 次。注意 <code>k</code> 保证为正整数。</p><p>你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 <code>k</code> ，例如不会出现像 <code>3a</code> 或 <code>2[4]</code> 的输入。</p><p>测试用例保证输出的长度不会超过 <code>10^5</code>。</p><p><strong>示例 1:</strong></p><blockquote><p><strong>输入：</strong><code>s = &quot;3[a]2[bc]&quot;</code><br><strong>输出：</strong><code>&quot;aaabcbc&quot;</code></p></blockquote><p><strong>示例 2:</strong></p><blockquote><p><strong>输入：</strong><code>s = &quot;3[a2[c]]&quot;</code><br><strong>输出：</strong><code>&quot;accaccacc&quot;</code></p></blockquote><p><strong>示例 3:</strong></p><blockquote><p><strong>输入：</strong><code>s = &quot;2[abc]3[cd]ef&quot;</code><br><strong>输出：</strong><code>&quot;abcabccdcdcdef&quot;</code></p></blockquote><p><strong>示例 4:</strong></p><blockquote><p><strong>输入：</strong><code>s = &quot;abc3[cd]xyz&quot;</code><br><strong>输出：</strong><code>&quot;abccdcdcdxyz&quot;</code></p></blockquote><p><strong>提示:</strong></p><ul><li><code>1 &lt;= s.length &lt;= 30</code></li><li><code>s</code> 由小写英文字母、数字和方括号 <code>&#39;[]&#39;</code> 组成</li><li><code>s</code> 保证是一个有效的输入。</li><li><code>s</code> 中所有整数的取值范围为 <code>[1, 300] </code></li></ul><span id="more"></span><h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><h2 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h2><p>使用<strong>递归（DFS）</strong> 逐层解析嵌套括号：</p><ol><li>全局指针 <code>i</code>：记录当前处理的字符位置。</li><li>递归函数 <code>decode()</code>：<ul><li>遇到 <strong>字母</strong>：直接拼接到结果。</li><li>遇到 <strong>数字</strong>：计算重复次数 <code>k</code>。</li><li>遇到 <strong>左括号</strong> <code>[</code>：递归解析子字符串，并将结果重复 <code>k</code> 次拼接到当前结果。</li><li>遇到 <strong>右括号</strong> <code>]</code>：结束当前递归层，返回结果。</li></ul></li><li>重置 <code>k</code>：每次处理完 <code>k[encoded_string]</code> 后重置 <code>k</code>，避免影响后续数字。</li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局指针</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">decodeString</span><span class="params">(String s)</span> &#123;</span><br><span class="line">    i = <span class="number">0</span>; <span class="comment">// 重置指针（避免多次调用干扰）</span></span><br><span class="line">    <span class="keyword">return</span> decode(s.toCharArray());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String <span class="title function_">decode</span><span class="params">(<span class="type">char</span>[] s)</span> &#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 当前重复次数</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (i &lt; s.length) &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s[i];</span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">if</span> (Character.isLetter(c)) &#123;</span><br><span class="line">            res.append(c); <span class="comment">// 字母直接拼接</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Character.isDigit(c)) &#123;</span><br><span class="line">            k = k * <span class="number">10</span> + (c - <span class="string">&#x27;0&#x27;</span>); <span class="comment">// 计算重复次数（处理多位数）</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;[&#x27;</span>) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">sub</span> <span class="operator">=</span> decode(s); <span class="comment">// 递归解析子字符串</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; k; j++) &#123;</span><br><span class="line">                res.append(sub); <span class="comment">// 重复拼接子字符串</span></span><br><span class="line">            &#125;</span><br><span class="line">            k = <span class="number">0</span>; <span class="comment">// 重置重复次数</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">&#x27;]&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// 结束当前递归层</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li><strong>时间复杂度：</strong><code>O(n)</code>，其中 <code>n</code> 是解码后字符串的长度。每个字符只处理一次，但重复拼接操作会增加时间。</li><li><strong>空间复杂度：</strong><code>O(m)</code>，<code>m</code> 是递归栈的最大深度（即嵌套括号层数）。</li></ul><h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><blockquote><p><a href="https://leetcode.cn/problems/decode-string/description/" title="394. 字符串解码 | 力扣（LeetCode）">394. 字符串解码 | 力扣（LeetCode）</a><br><a href="https://leetcode.cn/problems/decode-string/solutions/3744428/di-gui-yong-zhan-mo-ni-di-gui-pythonjava-kcsv/" title="394. 字符串解码 | 题解 | 灵茶山艾府">394. 字符串解码 | 题解 | 灵茶山艾府</a><br><a href="https://leetcode.cn/problems/decode-string/solutions/19447/decode-string-fu-zhu-zhan-fa-di-gui-fa-by-jyd/" title="394. 字符串解码 | 题解 | Krahets">394. 字符串解码 | 题解 | Krahets</a></p></blockquote><hr>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;给定一个经过编码的字符串，返回它解码后的字符串。编码规则为: &lt;code&gt;k[encoded_string]&lt;/code&gt;，表示其中方括号内部的 &lt;code&gt;encoded_string&lt;/code&gt; 正好重复 &lt;code&gt;k&lt;/code&gt; 次。注意 &lt;code&gt;k&lt;/code&gt; 保证为正整数。&lt;/p&gt;
&lt;p&gt;你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 &lt;code&gt;k&lt;/code&gt; ，例如不会出现像 &lt;code&gt;3a&lt;/code&gt; 或 &lt;code&gt;2[4]&lt;/code&gt; 的输入。&lt;/p&gt;
&lt;p&gt;测试用例保证输出的长度不会超过 &lt;code&gt;10^5&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt;&lt;code&gt;s = &amp;quot;3[a]2[bc]&amp;quot;&lt;/code&gt;&lt;br&gt;&lt;strong&gt;输出：&lt;/strong&gt;&lt;code&gt;&amp;quot;aaabcbc&amp;quot;&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt;&lt;code&gt;s = &amp;quot;3[a2[c]]&amp;quot;&lt;/code&gt;&lt;br&gt;&lt;strong&gt;输出：&lt;/strong&gt;&lt;code&gt;&amp;quot;accaccacc&amp;quot;&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例 3:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt;&lt;code&gt;s = &amp;quot;2[abc]3[cd]ef&amp;quot;&lt;/code&gt;&lt;br&gt;&lt;strong&gt;输出：&lt;/strong&gt;&lt;code&gt;&amp;quot;abcabccdcdcdef&amp;quot;&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例 4:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt;&lt;code&gt;s = &amp;quot;abc3[cd]xyz&amp;quot;&lt;/code&gt;&lt;br&gt;&lt;strong&gt;输出：&lt;/strong&gt;&lt;code&gt;&amp;quot;abccdcdcdxyz&amp;quot;&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;提示:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= s.length &amp;lt;= 30&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;s&lt;/code&gt; 由小写英文字母、数字和方括号 &lt;code&gt;&amp;#39;[]&amp;#39;&lt;/code&gt; 组成&lt;/li&gt;
&lt;li&gt;&lt;code&gt;s&lt;/code&gt; 保证是一个有效的输入。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;s&lt;/code&gt; 中所有整数的取值范围为 &lt;code&gt;[1, 300] &lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://www.cylong.com/categories/LeetCode/"/>
    
    
    <category term="Java" scheme="https://www.cylong.com/tags/Java/"/>
    
    <category term="LeetCode" scheme="https://www.cylong.com/tags/LeetCode/"/>
    
    <category term="学习笔记" scheme="https://www.cylong.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="递归" scheme="https://www.cylong.com/tags/%E9%80%92%E5%BD%92/"/>
    
    <category term="栈" scheme="https://www.cylong.com/tags/%E6%A0%88/"/>
    
    <category term="LeetCode中等" scheme="https://www.cylong.com/tags/LeetCode%E4%B8%AD%E7%AD%89/"/>
    
  </entry>
  
  <entry>
    <title>双栈结构实现最小栈功能：同步记录最小值（LeetCode 155）</title>
    <link href="https://www.cylong.com/blog/2025/08/16/min-stack/"/>
    <id>https://www.cylong.com/blog/2025/08/16/min-stack/</id>
    <published>2025-08-16T07:48:02.000Z</published>
    <updated>2025-08-16T07:48:02.000Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>设计一个支持 <code>push</code> ，<code>pop</code> ，<code>top</code> 操作，并能在常数时间内检索到最小元素的栈。<br>实现 <code>MinStack</code> 类:</p><ul><li><code>MinStack()</code> 初始化堆栈对象。</li><li><code>void push(int val)</code> 将元素 <code>val</code> 推入堆栈。</li><li><code>void pop()</code> 删除堆栈顶部的元素。</li><li><code>int top()</code> 获取堆栈顶部的元素。</li><li><code>int getMin()</code> 获取堆栈中的最小元素。</li></ul><p><strong>示例 1:</strong></p><blockquote><p><strong>输入：</strong><br><code>[&quot;MinStack&quot;, &quot;push&quot;, &quot;push&quot;, &quot;push&quot;, &quot;getMin&quot;, &quot;pop&quot;, &quot;top&quot;, &quot;getMin&quot;]</code><br><code>[[], [-2], [0], [-3], [], [], [], []]</code><br><strong>输出：</strong><code>[null, null, null, null, -3, null, 0, -2]</code><br><strong>解释：</strong><br>MinStack minStack = new MinStack();<br>minStack.push(-2);<br>minStack.push(0);<br>minStack.push(-3);<br>minStack.getMin();   –&gt; 返回 -3.<br>minStack.pop();<br>minStack.top();      –&gt; 返回 0.<br>minStack.getMin();   –&gt; 返回 -2.</p></blockquote><p><strong>提示:</strong></p><ul><li><code>-2^31 &lt;= val &lt;= 2^31 - 1</code></li><li><code>pop</code>、<code>top</code> 和 <code>getMin</code> 操作总是在 非空栈 上调用</li><li><code>push</code>, <code>pop</code>, <code>top</code>, 和 <code>getMin</code> 最多被调用 <code>3 * 10^4</code> 次</li></ul><span id="more"></span><h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>要设计一个支持常数时间内获取最小元素的栈，我们可以使用两个栈：</p><ol><li><strong>主栈（stack）：</strong>用于存储所有元素，支持常规的栈操作。</li><li><strong>最小栈（minStack）：</strong>用于存储当前主栈中每个状态下的最小值。</li></ol><h2 id="关键操作"><a href="#关键操作" class="headerlink" title="关键操作"></a>关键操作</h2><ul><li><strong>push 操作：</strong><ul><li>将元素推入主栈。</li><li>如果最小栈为空，或者新元素小于等于最小栈的栈顶元素，则将该元素也推入最小栈。</li></ul></li><li><strong>pop 操作：</strong><ul><li>弹出主栈的栈顶元素。</li><li>如果弹出的元素等于最小栈的栈顶元素，则同时弹出最小栈的栈顶元素（表示当前最小值已从主栈移除）。</li></ul></li><li><strong>top 操作：</strong>直接返回主栈的栈顶元素。</li><li><strong>getMin 操作：</strong>直接返回最小栈的栈顶元素（即当前栈中的最小元素）。</li></ul><h2 id="为什么使用“小于等于”？"><a href="#为什么使用“小于等于”？" class="headerlink" title="为什么使用“小于等于”？"></a>为什么使用“小于等于”？</h2><p>当新元素等于最小栈的栈顶元素时，也需要将其推入最小栈。这样可以确保当多个相同的最小值存在时，最小栈中也有多个相同的值，避免在 <code>pop</code> 操作时提前将最小值移除。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line">    <span class="comment">// 注意不要使用 Stack 类，因为它继承自 Vector，是同步的，会导致一些性能问题</span></span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Integer&gt; stack;    <span class="comment">// 主栈</span></span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Integer&gt; minStack; <span class="comment">// 最小栈</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MinStack</span><span class="params">()</span> &#123;</span><br><span class="line">        stack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        minStack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        stack.push(val);</span><br><span class="line">        <span class="comment">// 如果最小栈为空，或者新元素小于等于最小栈栈顶元素，则推入最小栈</span></span><br><span class="line">        <span class="keyword">if</span> (minStack.isEmpty() || val &lt;= minStack.peek()) &#123;</span><br><span class="line">            minStack.push(val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">popVal</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">        <span class="comment">// 如果弹出的元素等于最小栈栈顶元素，则同时弹出最小栈栈顶元素</span></span><br><span class="line">        <span class="keyword">if</span> (popVal == minStack.peek()) &#123;</span><br><span class="line">            minStack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMin</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> minStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li><strong>时间复杂度：</strong><ul><li><strong>push：</strong><code>O(1)</code>，每次操作只涉及常数次栈操作。</li><li><strong>pop：</strong><code>O(1)</code>，每次操作只涉及常数次栈操作。</li><li><strong>top：</strong><code>O(1)</code>，直接返回主栈栈顶元素。</li><li><strong>getMin：</strong><code>O(1)</code>，直接返回最小栈栈顶元素。</li></ul></li><li><strong>空间复杂度：</strong><code>O(n)</code>，最坏情况下需要两个栈存储所有元素，但最小栈在优化后通常存储元素较少。</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过使用两个栈（主栈和最小栈），我们可以在常数时间内完成所有栈操作并获取当前栈中的最小元素。最小栈的维护确保了在每次操作后都能快速获取到最小值，而主栈则负责常规的栈功能。这种方法既高效又易于实现，是解决此类问题的经典方案。</p><h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><blockquote><p><a href="https://leetcode.cn/problems/min-stack/description/" title="155. 最小栈 | 力扣（LeetCode）">155. 最小栈 | 力扣（LeetCode）</a></p></blockquote><hr>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;设计一个支持 &lt;code&gt;push&lt;/code&gt; ，&lt;code&gt;pop&lt;/code&gt; ，&lt;code&gt;top&lt;/code&gt; 操作，并能在常数时间内检索到最小元素的栈。&lt;br&gt;实现 &lt;code&gt;MinStack&lt;/code&gt; 类:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;MinStack()&lt;/code&gt; 初始化堆栈对象。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;void push(int val)&lt;/code&gt; 将元素 &lt;code&gt;val&lt;/code&gt; 推入堆栈。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;void pop()&lt;/code&gt; 删除堆栈顶部的元素。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;int top()&lt;/code&gt; 获取堆栈顶部的元素。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;int getMin()&lt;/code&gt; 获取堆栈中的最小元素。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt;&lt;br&gt;&lt;code&gt;[&amp;quot;MinStack&amp;quot;, &amp;quot;push&amp;quot;, &amp;quot;push&amp;quot;, &amp;quot;push&amp;quot;, &amp;quot;getMin&amp;quot;, &amp;quot;pop&amp;quot;, &amp;quot;top&amp;quot;, &amp;quot;getMin&amp;quot;]&lt;/code&gt;&lt;br&gt;&lt;code&gt;[[], [-2], [0], [-3], [], [], [], []]&lt;/code&gt;&lt;br&gt;&lt;strong&gt;输出：&lt;/strong&gt;&lt;code&gt;[null, null, null, null, -3, null, 0, -2]&lt;/code&gt;&lt;br&gt;&lt;strong&gt;解释：&lt;/strong&gt;&lt;br&gt;MinStack minStack = new MinStack();&lt;br&gt;minStack.push(-2);&lt;br&gt;minStack.push(0);&lt;br&gt;minStack.push(-3);&lt;br&gt;minStack.getMin();   –&amp;gt; 返回 -3.&lt;br&gt;minStack.pop();&lt;br&gt;minStack.top();      –&amp;gt; 返回 0.&lt;br&gt;minStack.getMin();   –&amp;gt; 返回 -2.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;提示:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-2^31 &amp;lt;= val &amp;lt;= 2^31 - 1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pop&lt;/code&gt;、&lt;code&gt;top&lt;/code&gt; 和 &lt;code&gt;getMin&lt;/code&gt; 操作总是在 非空栈 上调用&lt;/li&gt;
&lt;li&gt;&lt;code&gt;push&lt;/code&gt;, &lt;code&gt;pop&lt;/code&gt;, &lt;code&gt;top&lt;/code&gt;, 和 &lt;code&gt;getMin&lt;/code&gt; 最多被调用 &lt;code&gt;3 * 10^4&lt;/code&gt; 次&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://www.cylong.com/categories/LeetCode/"/>
    
    
    <category term="Java" scheme="https://www.cylong.com/tags/Java/"/>
    
    <category term="LeetCode" scheme="https://www.cylong.com/tags/LeetCode/"/>
    
    <category term="学习笔记" scheme="https://www.cylong.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="栈" scheme="https://www.cylong.com/tags/%E6%A0%88/"/>
    
    <category term="LeetCode中等" scheme="https://www.cylong.com/tags/LeetCode%E4%B8%AD%E7%AD%89/"/>
    
  </entry>
  
  <entry>
    <title>两次二分查找定位有序数组元素边界（LeetCode 34）</title>
    <link href="https://www.cylong.com/blog/2025/08/02/find-first-and-last-position-of-element-in-sorted-array/"/>
    <id>https://www.cylong.com/blog/2025/08/02/find-first-and-last-position-of-element-in-sorted-array/</id>
    <published>2025-08-02T06:22:23.000Z</published>
    <updated>2025-08-02T06:22:23.000Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给你一个按照非递减顺序排列的整数数组 <code>nums</code>，和一个目标值 <code>target</code>。请你找出给定目标值在数组中的开始位置和结束位置。如果数组中不存在目标值 <code>target</code>，返回 <code>[-1, -1]</code>。</p><p>你必须设计并实现时间复杂度为 <code>O(log n)</code> 的算法解决此问题。</p><p><strong>示例 1:</strong></p><blockquote><p><strong>输入：</strong><code>nums = [5, 7, 7, 8, 8, 10]</code>, <code>target = 8</code><br><strong>输出：</strong><code>[3, 4]</code></p></blockquote><p><strong>示例 2:</strong></p><blockquote><p><strong>输入：</strong><code>nums = [5, 7, 7, 8, 8, 10]</code>, <code>target = 6</code><br><strong>输出：</strong><code>[-1, -1]</code></p></blockquote><p><strong>示例 3:</strong></p><blockquote><p><strong>输入：</strong><code>nums = []</code>, <code>target = 0</code><br><strong>输出：</strong><code>[-1, -1]</code></p></blockquote><p><strong>提示:</strong></p><ul><li><code>0 &lt;= nums.length &lt;= 10^5</code></li><li><code>-10^9 &lt;= nums[i] &lt;= 10^9</code></li><li><code>nums</code> 是一个非递减数组</li><li><code>-10^9 &lt;= target &lt;= 10^9</code></li></ul><span id="more"></span><h1 id="一次二分查找-线性扩展"><a href="#一次二分查找-线性扩展" class="headerlink" title="一次二分查找 + 线性扩展"></a>一次二分查找 + 线性扩展</h1><h2 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h2><p>使用二分查找找到目标值，然后向左右两边扩展，直到找到边界。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] searchRange(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">    <span class="comment">// 处理空数组的情况</span></span><br><span class="line">    <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="comment">// 计算中间位置，防止整数溢出</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="comment">// 找到目标值，继续向两边搜索边界</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> mid, end = mid;</span><br><span class="line">            <span class="comment">// 向左搜索起始位置</span></span><br><span class="line">            <span class="keyword">while</span> (start &gt; left &amp;&amp; nums[start - <span class="number">1</span>] == target) &#123;</span><br><span class="line">                start--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 向右搜索结束位置</span></span><br><span class="line">            <span class="keyword">while</span> (end &lt; right &amp;&amp; nums[end + <span class="number">1</span>] == target) &#123;</span><br><span class="line">                end++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;start, end&#125;;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li><strong>时间复杂度：</strong>平均情况 <code>O(logn)</code>，但在最坏情况下（整个数组都是目标值）会退化为 <code>O(n)</code>。</li><li><strong>空间复杂度：</strong><code>O(1)</code>，仅使用常数空间存储变量。</li></ul><h1 id="两次二分查找"><a href="#两次二分查找" class="headerlink" title="两次二分查找"></a>两次二分查找</h1><h2 id="核心思路-1"><a href="#核心思路-1" class="headerlink" title="核心思路"></a>核心思路</h2><p>分别使用二分查找寻找左边界和右边界：</p><ul><li><strong>查找左边界：</strong>第一个等于目标值的位置<ul><li>初始化左右指针 <code>left = 0</code>, <code>right = nums.length - 1</code></li><li>当 <code>left &lt;= right</code> 时循环：<ul><li>计算中间位置 <code>mid = left + (right - left) / 2</code>（防止整数溢出）</li><li>如果 <code>nums[mid] &gt;= target</code>，则目标可能在左半部分，调整右指针 <code>right = mid - 1</code></li><li>否则调整左指针 <code>left = mid + 1</code></li></ul></li><li>循环结束后，检查 <code>left</code> 是否在数组范围内且对应值等于 <code>target</code></li></ul></li><li><strong>查找右边界：</strong>最后一个等于目标值的位置<ul><li>初始化左右指针 <code>left = 0</code>, <code>right = nums.length - 1</code></li><li>当 <code>left &lt;= right</code> 时循环：<ul><li>计算中间位置 <code>mid = left + (right - left) / 2</code>（防止整数溢出）</li><li>如果 <code>nums[mid] &lt;= target</code>，则目标可能在右半部分，调整左指针 <code>left = mid + 1</code></li><li>否则调整右指针 <code>right = mid - 1</code></li></ul></li><li>循环结束后，检查 <code>right</code> 是否在数组范围内且对应值等于 <code>target</code></li></ul></li></ul><h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] searchRange(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        <span class="comment">// 处理空数组的情况</span></span><br><span class="line">        <span class="keyword">if</span> (nums == <span class="literal">null</span> || nums.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> <span class="variable">leftBound</span> <span class="operator">=</span> findLeftBound(nums, target);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightBound</span> <span class="operator">=</span> findRightBound(nums, target);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;leftBound, rightBound&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查找左边界：第一个等于 target 的位置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">findLeftBound</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt;= target) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>; <span class="comment">// 向左搜索</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 检查 left 是否在数组范围内且等于 target</span></span><br><span class="line">        <span class="keyword">if</span> (left &lt; nums.length &amp;&amp; nums[left] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 查找右边界：最后一个等于 target 的位置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">findRightBound</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt;= target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>; <span class="comment">// 向右搜索</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 检查 right 是否在数组范围内且等于 target</span></span><br><span class="line">        <span class="keyword">if</span> (right &gt;= <span class="number">0</span> &amp;&amp; nums[right] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li><strong>时间复杂度：</strong><code>O(log n)</code>。两次二分查找，每次时间复杂度为 <code>O(log n)</code>。</li><li><strong>空间复杂度：</strong><code>O(1)</code>。仅使用常数空间存储变量。</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><table><thead><tr><th>解法</th><th>时间复杂度</th><th>空间复杂度</th><th>优点</th></tr></thead><tbody><tr><td>一次二分查找 + 线性扩展</td><td>O(n)（最坏）<br>O(log n)（最好）</td><td>O(1)</td><td>代码简单，但是受重复元素数量影响，最坏情况时间复杂度 O(n)</td></tr><tr><td>两次二分查找</td><td>O(log n)（所有情况）</td><td>O(1)</td><td>保证最坏情况下的性能，不受输入数据分布影响</td></tr></tbody></table><p>最终推荐两次二分查找方法，它严格满足题目要求，在各种情况下都能保持高效稳定的性能，是符合题目要求的解法。</p><h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><blockquote><p><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/" title="34. 在排序数组中查找元素的第一个和最后一个位置 | 力扣（LeetCode）">34. 在排序数组中查找元素的第一个和最后一个位置 | 力扣（LeetCode）</a></p></blockquote><hr>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;给你一个按照非递减顺序排列的整数数组 &lt;code&gt;nums&lt;/code&gt;，和一个目标值 &lt;code&gt;target&lt;/code&gt;。请你找出给定目标值在数组中的开始位置和结束位置。如果数组中不存在目标值 &lt;code&gt;target&lt;/code&gt;，返回 &lt;code&gt;[-1, -1]&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;你必须设计并实现时间复杂度为 &lt;code&gt;O(log n)&lt;/code&gt; 的算法解决此问题。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt;&lt;code&gt;nums = [5, 7, 7, 8, 8, 10]&lt;/code&gt;, &lt;code&gt;target = 8&lt;/code&gt;&lt;br&gt;&lt;strong&gt;输出：&lt;/strong&gt;&lt;code&gt;[3, 4]&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt;&lt;code&gt;nums = [5, 7, 7, 8, 8, 10]&lt;/code&gt;, &lt;code&gt;target = 6&lt;/code&gt;&lt;br&gt;&lt;strong&gt;输出：&lt;/strong&gt;&lt;code&gt;[-1, -1]&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例 3:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt;&lt;code&gt;nums = []&lt;/code&gt;, &lt;code&gt;target = 0&lt;/code&gt;&lt;br&gt;&lt;strong&gt;输出：&lt;/strong&gt;&lt;code&gt;[-1, -1]&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;提示:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;0 &amp;lt;= nums.length &amp;lt;= 10^5&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-10^9 &amp;lt;= nums[i] &amp;lt;= 10^9&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nums&lt;/code&gt; 是一个非递减数组&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-10^9 &amp;lt;= target &amp;lt;= 10^9&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://www.cylong.com/categories/LeetCode/"/>
    
    
    <category term="Java" scheme="https://www.cylong.com/tags/Java/"/>
    
    <category term="LeetCode" scheme="https://www.cylong.com/tags/LeetCode/"/>
    
    <category term="学习笔记" scheme="https://www.cylong.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="数组" scheme="https://www.cylong.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="二分查找" scheme="https://www.cylong.com/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
    <category term="LeetCode中等" scheme="https://www.cylong.com/tags/LeetCode%E4%B8%AD%E7%AD%89/"/>
    
  </entry>
  
  <entry>
    <title>链表数字相加的逆序计算：栈实现与进位处理（LeetCode 445）</title>
    <link href="https://www.cylong.com/blog/2025/07/25/add-two-numbers-ii/"/>
    <id>https://www.cylong.com/blog/2025/07/25/add-two-numbers-ii/</id>
    <published>2025-07-24T16:23:06.000Z</published>
    <updated>2025-07-24T16:23:06.000Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给你两个非空链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。你可以假设除了数字 0 之外，这两个数字都不会以零开头。</p><p><strong>示例 1:</strong></p><img src="/blog/2025/07/25/add-two-numbers-ii/445-image.png" class=""><blockquote><p><strong>输入：</strong><code>l1 = [7, 2, 4, 3], l2 = [5, 6, 4]</code><br><strong>输出：</strong><code>[7, 8, 0, 7]</code></p></blockquote><p><strong>示例 2:</strong></p><blockquote><p><strong>输入：</strong><code>l1 = [2, 4, 3], l2 = [5, 6, 4]</code><br><strong>输出：</strong><code>[8, 0, 7]</code></p></blockquote><p><strong>示例 3:</strong></p><blockquote><p><strong>输入：</strong><code>l1 = [0], l2 = [0]</code><br><strong>输出：</strong><code>[0]</code></p></blockquote><p><strong>提示:</strong></p><ul><li>链表的长度范围为 <code>[1, 100]</code></li><li><code>0 &lt;= node.val &lt;= 9</code></li><li>输入数据保证链表代表的数字无前导 <code>0</code></li></ul><span id="more"></span><h1 id="栈辅助法"><a href="#栈辅助法" class="headerlink" title="栈辅助法"></a>栈辅助法</h1><h2 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h2><p>利用栈的 <strong>后进先出</strong> 特性实现逆序处理：</p><ol><li>遍历两个链表，将节点值分别压入两个栈。</li><li>同时弹出栈顶元素进行相加，处理进位。</li><li>使用头插法构建结果链表。</li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack1 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; stack2 = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将链表节点值压入栈中</span></span><br><span class="line">    <span class="keyword">while</span> (l1 != <span class="literal">null</span>) &#123;</span><br><span class="line">        stack1.push(l1.val);</span><br><span class="line">        l1 = l1.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (l2 != <span class="literal">null</span>) &#123;</span><br><span class="line">        stack2.push(l2.val);</span><br><span class="line">        l2 = l2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> <span class="variable">carry</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 进位值</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">resultHead</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">// 结果链表头节点</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 当栈非空或仍有进位时继续计算</span></span><br><span class="line">    <span class="keyword">while</span> (!stack1.isEmpty() || !stack2.isEmpty() || carry != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取栈顶元素（栈空则取0）</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">num1</span> <span class="operator">=</span> stack1.isEmpty() ? <span class="number">0</span> : stack1.pop();</span><br><span class="line">        <span class="type">int</span> <span class="variable">num2</span> <span class="operator">=</span> stack2.isEmpty() ? <span class="number">0</span> : stack2.pop();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 计算当前位的和</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> num1 + num2 + carry;</span><br><span class="line">        carry = sum / <span class="number">10</span>; <span class="comment">// 更新进位</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">digit</span> <span class="operator">=</span> sum % <span class="number">10</span>; <span class="comment">// 当前位的值</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 使用头插法构建结果链表</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(digit);</span><br><span class="line">        newNode.next = resultHead;</span><br><span class="line">        resultHead = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> resultHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li><strong>时间复杂度：</strong><code>O(max(m, n))</code>，其中 <code>m</code> 和 <code>n</code> 分别为两个链表的长度。</li><li><strong>空间复杂度：</strong><code>O(m + n)</code>，用于存储两个栈。</li></ul><h1 id="链表反转法"><a href="#链表反转法" class="headerlink" title="链表反转法"></a>链表反转法</h1><h2 id="核心思路-1"><a href="#核心思路-1" class="headerlink" title="核心思路"></a>核心思路</h2><p>通过反转链表实现低位对齐：</p><ol><li>反转两个输入链表。</li><li>按照两数相加I的方法计算（低位对齐）</li><li>反转结果链表得到最终答案</li></ol><p>参考：</p><blockquote><p><a href="/blog/2019/11/25/add-two-numbers/" title="两数相加 I | 笑话人生">两数相加 I | 笑话人生</a><br><a href="/blog/2025/07/22/reverse-linked-list/" title="反转链表的指针操作与递归实现（LeetCode 206）| 笑话人生">反转链表的指针操作与递归实现（LeetCode 206）| 笑话人生</a></p></blockquote><h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">    <span class="comment">// 反转两个链表</span></span><br><span class="line">    l1 = reverseList(l1);</span><br><span class="line">    l2 = reverseList(l2);</span><br><span class="line">    <span class="comment">// 相加得到结果链表（低位在前）</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">l3</span> <span class="operator">=</span> addTwo(l1, l2);</span><br><span class="line">    <span class="comment">// 反转结果链表得到高位在前</span></span><br><span class="line">    <span class="keyword">return</span> reverseList(l3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反转链表（LeetCode 206）</span></span><br><span class="line"><span class="keyword">private</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head, pre = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">tmp</span> <span class="operator">=</span> cur.next; <span class="comment">// 保存下一个节点</span></span><br><span class="line">        cur.next = pre;          <span class="comment">// 当前节点指向前一个节点</span></span><br><span class="line">        pre = cur;               <span class="comment">// 前节点后移</span></span><br><span class="line">        cur = tmp;               <span class="comment">// 当前节点后移</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre; <span class="comment">// 返回反转后的头节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 两数相加（LeetCode 2）</span></span><br><span class="line"><span class="keyword">private</span> ListNode <span class="title function_">addTwo</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>); <span class="comment">// 虚拟头节点</span></span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummy;</span><br><span class="line">    <span class="type">int</span> <span class="variable">carry</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 进位值</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (l1 != <span class="literal">null</span> || l2 != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> (l1 != <span class="literal">null</span>) ? l1.val : <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> (l2 != <span class="literal">null</span>) ? l2.val : <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> x + y + carry;</span><br><span class="line">        </span><br><span class="line">        carry = sum / <span class="number">10</span>; <span class="comment">// 计算进位</span></span><br><span class="line">        cur.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(sum % <span class="number">10</span>); <span class="comment">// 创建新节点</span></span><br><span class="line">        cur = cur.next; <span class="comment">// 移动当前指针</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 移动链表指针</span></span><br><span class="line">        <span class="keyword">if</span> (l1 != <span class="literal">null</span>) l1 = l1.next;</span><br><span class="line">        <span class="keyword">if</span> (l2 != <span class="literal">null</span>) l2 = l2.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 处理最后的进位</span></span><br><span class="line">    <span class="keyword">if</span> (carry &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        cur.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(carry);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dummy.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li><strong>时间复杂度：</strong><code>O(max(m, n))</code>，反转链表和相加操作都是线性时间。</li><li><strong>空间复杂度：</strong><code>O(1)</code>，仅使用固定数量的指针。</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><table><thead><tr><th>解法</th><th>时间复杂度</th><th>空间复杂度</th><th>优点</th></tr></thead><tbody><tr><td>栈辅助法</td><td>O(max(m, n))</td><td>O(m + n)</td><td>逻辑清晰，但需要额外栈空间</td></tr><tr><td>链表反转法</td><td>O(max(m, n))</td><td>O(1)</td><td>空间更优，但修改了原始链表</td></tr></tbody></table><p>两种方法各有优劣：</p><ol><li><strong>栈辅助法：</strong>不修改原始链表，逻辑清晰，但需要额外空间存储栈。</li><li><strong>链表反转法：</strong>空间效率更高，但会修改原始链表结构。</li></ol><p>在实际应用中，如果原始链表不可修改，应选择栈辅助法；若空间效率是首要考虑因素，则链表反转法更优。两种方法的时间复杂度相同，都能高效解决该问题。</p><h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><blockquote><p><a href="https://leetcode.cn/problems/add-two-numbers-ii/description/" title="445. 两数相加 II | 力扣（LeetCode）">445. 两数相加 II | 力扣（LeetCode）</a></p></blockquote><hr>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;给你两个非空链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。你可以假设除了数字 0 之外，这两个数字都不会以零开头。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;img src=&quot;/blog/2025/07/25/add-two-numbers-ii/445-image.png&quot; class=&quot;&quot;&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt;&lt;code&gt;l1 = [7, 2, 4, 3], l2 = [5, 6, 4]&lt;/code&gt;&lt;br&gt;&lt;strong&gt;输出：&lt;/strong&gt;&lt;code&gt;[7, 8, 0, 7]&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt;&lt;code&gt;l1 = [2, 4, 3], l2 = [5, 6, 4]&lt;/code&gt;&lt;br&gt;&lt;strong&gt;输出：&lt;/strong&gt;&lt;code&gt;[8, 0, 7]&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例 3:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt;&lt;code&gt;l1 = [0], l2 = [0]&lt;/code&gt;&lt;br&gt;&lt;strong&gt;输出：&lt;/strong&gt;&lt;code&gt;[0]&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;提示:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;链表的长度范围为 &lt;code&gt;[1, 100]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0 &amp;lt;= node.val &amp;lt;= 9&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;输入数据保证链表代表的数字无前导 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://www.cylong.com/categories/LeetCode/"/>
    
    
    <category term="Java" scheme="https://www.cylong.com/tags/Java/"/>
    
    <category term="LeetCode" scheme="https://www.cylong.com/tags/LeetCode/"/>
    
    <category term="学习笔记" scheme="https://www.cylong.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="链表" scheme="https://www.cylong.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
    <category term="双指针" scheme="https://www.cylong.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
    <category term="递归" scheme="https://www.cylong.com/tags/%E9%80%92%E5%BD%92/"/>
    
    <category term="栈" scheme="https://www.cylong.com/tags/%E6%A0%88/"/>
    
    <category term="LeetCode中等" scheme="https://www.cylong.com/tags/LeetCode%E4%B8%AD%E7%AD%89/"/>
    
    <category term="回溯" scheme="https://www.cylong.com/tags/%E5%9B%9E%E6%BA%AF/"/>
    
    <category term="迭代" scheme="https://www.cylong.com/tags/%E8%BF%AD%E4%BB%A3/"/>
    
  </entry>
  
  <entry>
    <title>反转链表的指针操作与递归实现（LeetCode 206）</title>
    <link href="https://www.cylong.com/blog/2025/07/22/reverse-linked-list/"/>
    <id>https://www.cylong.com/blog/2025/07/22/reverse-linked-list/</id>
    <published>2025-07-22T15:52:44.000Z</published>
    <updated>2025-07-22T15:52:44.000Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p><p><strong>示例 1:</strong></p><img src="/blog/2025/07/22/reverse-linked-list/rev1ex1.jpg" class=""><blockquote><p><strong>输入：</strong><code>head = [1, 2, 3, 4, 5]</code><br><strong>输出：</strong><code>[5, 4, 3, 2, 1]</code></p></blockquote><p><strong>示例 2:</strong></p><img src="/blog/2025/07/22/reverse-linked-list/rev1ex2.jpg" class=""><blockquote><p><strong>输入：</strong><code>head = [1, 2]</code><br><strong>输出：</strong><code>[2, 1]</code></p></blockquote><p><strong>示例 3:</strong></p><blockquote><p><strong>输入：</strong><code>head = []</code><br><strong>输出：</strong><code>[]</code></p></blockquote><p><strong>提示:</strong></p><ul><li>链表中节点的数目范围是 <code>[0, 5000]</code></li><li><code>-5000 &lt;= Node.val &lt;= 5000</code></li></ul><span id="more"></span><h1 id="迭代法"><a href="#迭代法" class="headerlink" title="迭代法"></a>迭代法</h1><h2 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h2><p>通过遍历链表，逐个修改节点指向。使用双指针 <code>pre</code> 和 <code>cur</code>，每次将 <code>cur.next</code> 指向 <code>pre</code> 并同步移动指针，直到遍历完成。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">tmp</span> <span class="operator">=</span> cur.next; <span class="comment">// 暂存后继节点</span></span><br><span class="line">            cur.next = pre;          <span class="comment">// 反转当前节点的指针</span></span><br><span class="line">            pre = cur;               <span class="comment">// pre 移动至当前节点</span></span><br><span class="line">            cur = tmp;               <span class="comment">// cur 访问下一节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre; <span class="comment">// 返回新头节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动态变化过程"><a href="#动态变化过程" class="headerlink" title="动态变化过程"></a>动态变化过程</h2><p>以链表 <code>1→2→3→NULL</code> 为例</p><p><strong>初始状态</strong><br><code>pre = null</code>, <code>cur = 1</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NULL ← ?    1 → 2 → 3 → NULL</span><br><span class="line"> ↑          ↑</span><br><span class="line">pre        cur</span><br></pre></td></tr></table></figure><p><strong>第一步</strong><br>暂存 <code>cur.next = 2</code> → 修改 <code>1.next = pre(null)</code> → 移动 <code>pre=1</code>, <code>cur=2</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NULL ← 1    2 → 3 → NULL</span><br><span class="line">       ↑    ↑</span><br><span class="line">      pre  cur</span><br></pre></td></tr></table></figure><p><strong>第二步</strong><br>暂存 <code>cur.next = 3</code> → 修改 <code>2.next = pre(1)</code> → 移动 <code>pre=2</code>, <code>cur=3</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NULL ← 1 ← 2    3 → NULL</span><br><span class="line">           ↑    ↑</span><br><span class="line">          pre  cur</span><br></pre></td></tr></table></figure><p><strong>第三步</strong><br>暂存 <code>cur.next = NULL</code> → 修改 <code>3.next = pre(2)</code> → 移动 <code>pre=3</code>, <code>cur=NULL</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NULL ← 1 ← 2 ← 3    NULL</span><br><span class="line">               ↑     ↑</span><br><span class="line">              pre   cur</span><br></pre></td></tr></table></figure><p><strong>结果</strong><br>返回 <code>pre = 3</code>，新链表为 <code>3→2→1→NULL</code>。</p><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li><strong>时间复杂度：</strong><code>O(n)</code>，遍历链表一次。</li><li><strong>空间复杂度：</strong><code>O(1)</code>，仅使用常量额外空间。</li></ul><h1 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h1><h2 id="核心思路-1"><a href="#核心思路-1" class="headerlink" title="核心思路"></a>核心思路</h2><p>递归到链表末端，回溯时逐层反转节点指向：</p><ol><li>递归终止条件：当前节点为尾节点（<code>head.next == null</code>）。</li><li>回溯过程中，将下一节点的 <code>next</code> 指向当前节点，并断开原指向。</li></ol><h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> head; <span class="comment">// 终止条件：返回尾节点作为新头节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">newHead</span> <span class="operator">=</span> reverseList(head.next); <span class="comment">// 递归至下一层</span></span><br><span class="line">        head.next.next = head; <span class="comment">// 反转指向：下一节点指向当前节点</span></span><br><span class="line">        head.next = <span class="literal">null</span>;      <span class="comment">// 断开当前节点原指向</span></span><br><span class="line">        <span class="keyword">return</span> newHead;        <span class="comment">// 始终返回新头节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动态变化过程-1"><a href="#动态变化过程-1" class="headerlink" title="动态变化过程"></a>动态变化过程</h2><p>以链表 <code>1→2→3→NULL</code> 为例</p><p><strong>递归至最深层</strong><br>当 <code>head=3</code> 时满足终止条件，返回 <code>3</code> 作为 <code>newHead</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 → 2 → 3 → NULL</span><br><span class="line">        ↑</span><br><span class="line">      head (返回3)</span><br></pre></td></tr></table></figure><p><strong>回溯第一层</strong></p><ul><li><code>head=2</code></li><li>执行 <code>head.next.next = head</code> → <code>3.next = 2</code></li><li>执行 <code>head.next = null</code> → <code>2.next = NULL</code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 → 2    3 → 2 → NULL   // 3指向2，2指向NULL</span><br><span class="line">    ↑    ↑</span><br><span class="line">  head newHead(3)</span><br></pre></td></tr></table></figure></li></ul><p><strong>回溯第二层</strong></p><ul><li><code>head=1</code></li><li>执行 <code>head.next.next = head</code> → <code>2.next = 1</code></li><li>执行 <code>head.next = null</code> → <code>1.next = NULL</code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  1    2 → 1 → NULL   // 2指向1，1指向NULL</span><br><span class="line">  ↑    ↑</span><br><span class="line">head newHead(3)</span><br></pre></td></tr></table></figure></li></ul><p><strong>最终结果</strong><br>返回 <code>newHead = 3</code>，链表变为 <code>3→2→1→NULL</code>。</p><h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li><strong>时间复杂度：</strong><code>O(n)</code>，递归深度为链表长度。</li><li><strong>空间复杂度：</strong><code>O(n)</code>，递归栈深度为链表长度。</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><table><thead><tr><th>解法</th><th>时间复杂度</th><th>空间复杂度</th><th>优点</th></tr></thead><tbody><tr><td>迭代法</td><td>O(n)</td><td>O(1)</td><td>空间复杂度低</td></tr><tr><td>递归法</td><td>O(n)</td><td>O(n)</td><td>代码简洁</td></tr></tbody></table><h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><blockquote><p><a href="https://leetcode.cn/problems/reverse-linked-list/description/" title="206. 反转链表 | 力扣（LeetCode）">206. 反转链表 | 力扣（LeetCode）</a></p></blockquote><hr>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;给你单链表的头节点 &lt;code&gt;head&lt;/code&gt; ，请你反转链表，并返回反转后的链表。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;img src=&quot;/blog/2025/07/22/reverse-linked-list/rev1ex1.jpg&quot; class=&quot;&quot;&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt;&lt;code&gt;head = [1, 2, 3, 4, 5]&lt;/code&gt;&lt;br&gt;&lt;strong&gt;输出：&lt;/strong&gt;&lt;code&gt;[5, 4, 3, 2, 1]&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;/p&gt;
&lt;img src=&quot;/blog/2025/07/22/reverse-linked-list/rev1ex2.jpg&quot; class=&quot;&quot;&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt;&lt;code&gt;head = [1, 2]&lt;/code&gt;&lt;br&gt;&lt;strong&gt;输出：&lt;/strong&gt;&lt;code&gt;[2, 1]&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例 3:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt;&lt;code&gt;head = []&lt;/code&gt;&lt;br&gt;&lt;strong&gt;输出：&lt;/strong&gt;&lt;code&gt;[]&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;提示:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;链表中节点的数目范围是 &lt;code&gt;[0, 5000]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-5000 &amp;lt;= Node.val &amp;lt;= 5000&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://www.cylong.com/categories/LeetCode/"/>
    
    
    <category term="Java" scheme="https://www.cylong.com/tags/Java/"/>
    
    <category term="LeetCode" scheme="https://www.cylong.com/tags/LeetCode/"/>
    
    <category term="学习笔记" scheme="https://www.cylong.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="链表" scheme="https://www.cylong.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
    <category term="双指针" scheme="https://www.cylong.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
    <category term="递归" scheme="https://www.cylong.com/tags/%E9%80%92%E5%BD%92/"/>
    
    <category term="LeetCode中等" scheme="https://www.cylong.com/tags/LeetCode%E4%B8%AD%E7%AD%89/"/>
    
    <category term="回溯" scheme="https://www.cylong.com/tags/%E5%9B%9E%E6%BA%AF/"/>
    
    <category term="迭代" scheme="https://www.cylong.com/tags/%E8%BF%AD%E4%BB%A3/"/>
    
  </entry>
  
  <entry>
    <title>全排列问题的递归回溯解法实现（LeetCode 46）</title>
    <link href="https://www.cylong.com/blog/2025/07/15/permutations/"/>
    <id>https://www.cylong.com/blog/2025/07/15/permutations/</id>
    <published>2025-07-15T14:54:28.000Z</published>
    <updated>2025-07-15T14:54:28.000Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个不含重复数字的数组 <code>nums</code> ，返回其所有可能的全排列 。你可以按任意顺序返回答案。</p><p><strong>示例 1:</strong></p><blockquote><p><strong>输入：</strong><code>nums = [1, 2, 3]</code><br><strong>输出：</strong><code>[[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]</code></p></blockquote><p><strong>示例 2:</strong></p><blockquote><p><strong>输入：</strong><code>nums = [0, 1]</code><br><strong>输出：</strong><code>[[0, 1], [1, 0]]</code></p></blockquote><p><strong>示例 3:</strong></p><blockquote><p><strong>输入：</strong><code>nums = [1]</code><br><strong>输出：</strong><code>[[1]]</code></p></blockquote><p><strong>提示:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 6</code></li><li><code>-10 &lt;= nums[i] &lt;= 10</code></li><li><code>nums</code> 中的所有整数互不相同</li></ul><span id="more"></span><h1 id="回溯算法（DFS）"><a href="#回溯算法（DFS）" class="headerlink" title="回溯算法（DFS）"></a>回溯算法（DFS）</h1><h2 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h2><p>全排列问题可以通过回溯算法解决。核心思想是：每次从数组中选取一个未被使用的元素加入当前路径，当路径长度等于数组长度时，将当前路径加入结果集。之后通过回溯撤销选择，尝试其他可能的元素。</p><ol><li>初始化结果列表 <code>ans</code> 和当前路径列表 <code>t</code></li><li>创建布尔数组 <code>vis</code> 标记元素是否已被使用</li><li>使用深度优先搜索（DFS）进行回溯：<ul><li><strong>终止条件：</strong>当前路径长度等于数组长度，将路径拷贝加入结果集</li><li><strong>遍历选择：</strong>遍历数组中的每个元素：<ul><li>如果元素未被使用，则将其加入路径并标记为已使用</li><li>递归进入下一层决策树</li><li>回溯：移除路径最后一个元素并取消标记</li></ul></li></ul></li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permute</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    List&lt;Integer&gt; t = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">boolean</span>[] vis = <span class="keyword">new</span> <span class="title class_">boolean</span>[nums.length];</span><br><span class="line">    dfs(nums, ans, t, vis);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[] nums, List&lt;List&lt;Integer&gt;&gt; ans, List&lt;Integer&gt; t, <span class="type">boolean</span>[] vis)</span> &#123;</span><br><span class="line">    <span class="comment">// 当路径长度等于数组长度时，将当前路径加入结果集</span></span><br><span class="line">    <span class="keyword">if</span> (t.size() == nums.length) &#123;</span><br><span class="line">        <span class="comment">// 注意创建新列表</span></span><br><span class="line">        ans.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(t));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历所有元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 如果元素未被使用</span></span><br><span class="line">        <span class="keyword">if</span> (!vis[i]) &#123;</span><br><span class="line">            <span class="comment">// 做出选择</span></span><br><span class="line">            t.add(nums[i]);</span><br><span class="line">            vis[i] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 递归进入下一层</span></span><br><span class="line">            dfs(nums, ans, t, vis);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 撤销选择（回溯）</span></span><br><span class="line">            t.removeLast();</span><br><span class="line">            vis[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="关键步骤图示"><a href="#关键步骤图示" class="headerlink" title="关键步骤图示"></a>关键步骤图示</h2><p><strong>初始状态</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Level 0: </span><br><span class="line">  t = [] </span><br><span class="line">  vis = [false, false, false]</span><br></pre></td></tr></table></figure><p><strong>第一层递归（选择第一个元素）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">选择1:</span><br><span class="line">  t = [1]</span><br><span class="line">  vis = [true, false, false]</span><br><span class="line">  └─ 进入第二层递归</span><br></pre></td></tr></table></figure><p><strong>第二层递归（选择第二个元素）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">选择2:</span><br><span class="line">  t = [1, 2]</span><br><span class="line">  vis = [true, true, false]</span><br><span class="line">  └─ 进入第三层递归</span><br></pre></td></tr></table></figure><p><strong>第三层递归（选择第三个元素）</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">选择3:</span><br><span class="line">  t = [1, 2, 3] → 添加到结果集 ✅</span><br><span class="line">  vis = [true, true, true]</span><br><span class="line">  ├─ 回溯：移除3</span><br><span class="line">  │   t = [1, 2]</span><br><span class="line">  │   vis = [true, true, false]</span><br><span class="line">  └─ 回溯：移除2</span><br><span class="line">      t = [1]</span><br><span class="line">      vis = [true, false, false]</span><br></pre></td></tr></table></figure><p><strong>第二层递归的其他选择</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">选择3:</span><br><span class="line">  t = [1, 3]</span><br><span class="line">  vis = [true, false, true]</span><br><span class="line">  └─ 进入第三层递归</span><br><span class="line">      选择2:</span><br><span class="line">        t = [1, 3, 2] → 添加到结果集 ✅</span><br><span class="line">        vis = [true, true, true]</span><br><span class="line">        ├─ 回溯：移除2</span><br><span class="line">        │   t = [1, 3]</span><br><span class="line">        │   vis = [true, false, true]</span><br><span class="line">        └─ 回溯：移除3</span><br><span class="line">            t = [1]</span><br><span class="line">            vis = [true, false, false]</span><br></pre></td></tr></table></figure><p><strong>第一层递归的其他选择</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">选择2:</span><br><span class="line">  t = [2]</span><br><span class="line">  vis = [false, true, false]</span><br><span class="line">  └─ 进入第二层递归</span><br><span class="line">      选择1:</span><br><span class="line">        t = [2, 1]</span><br><span class="line">        vis = [true, true, false]</span><br><span class="line">        └─ 进入第三层递归</span><br><span class="line">            选择3:</span><br><span class="line">              t = [2, 1, 3] → 添加到结果集 ✅</span><br><span class="line">              vis = [true, true, true]</span><br><span class="line">      选择3:</span><br><span class="line">        t = [2, 3]</span><br><span class="line">        vis = [false, true, true]</span><br><span class="line">        └─ 进入第三层递归</span><br><span class="line">            选择1:</span><br><span class="line">              t = [2, 3, 1] → 添加到结果集 ✅</span><br><span class="line">              vis = [true, true, true]</span><br><span class="line"></span><br><span class="line">选择3:</span><br><span class="line">  t = [3]</span><br><span class="line">  vis = [false, false, true]</span><br><span class="line">  └─ 进入第二层递归</span><br><span class="line">      选择1:</span><br><span class="line">        t = [3, 1]</span><br><span class="line">        vis = [true, false, true]</span><br><span class="line">        └─ 进入第三层递归</span><br><span class="line">            选择2:</span><br><span class="line">              t = [3, 1, 2] → 添加到结果集 ✅</span><br><span class="line">              vis = [true, true, true]</span><br><span class="line">      选择2:</span><br><span class="line">        t = [3, 2]</span><br><span class="line">        vis = [false, true, true]</span><br><span class="line">        └─ 进入第三层递归</span><br><span class="line">            选择1:</span><br><span class="line">              t = [3, 2, 1] → 添加到结果集 ✅</span><br><span class="line">              vis = [true, true, true]</span><br></pre></td></tr></table></figure><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li><strong>时间复杂度：</strong><code>O(n*n!)</code>，共有 <code>n!</code> 个排列，每个排列需要 <code>O(n)</code> 时间复制到结果列表中。</li><li><strong>空间复杂度：</strong><code>O(n)</code>，递归栈深度为 <code>n</code>，标记数组 <code>vis</code> 占用 <code>O(n)</code> 空间（结果空间不计入复杂度分析）。</li></ul><h1 id="关键点总结"><a href="#关键点总结" class="headerlink" title="关键点总结"></a>关键点总结</h1><ol><li><strong>回溯模板：</strong>遵循”选择-递归-撤销”的标准回溯框架</li><li><strong>路径拷贝：</strong><code>ans.add(new ArrayList&lt;&gt;(t))</code> 创建新列表避免引用问题</li><li><strong>状态标记：</strong>使用 <code>vis</code> 数组高效判断元素是否可用</li><li><strong>去重处理：</strong>题目已说明数组无重复数字，无需额外去重逻辑</li></ol><p>回溯法是解决排列组合问题的经典方法，通过深度优先搜索遍历所有可能性，配合状态标记保证每个元素只使用一次。掌握回溯算法的核心框架和剪枝技巧，能高效解决此类问题。</p><h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><blockquote><p><a href="https://leetcode.cn/problems/permutations/description/" title="46. 全排列 | 力扣（LeetCode）">46. 全排列 | 力扣（LeetCode）</a><br><a href="https://leetcode.cn/problems/permutations/solutions/9914/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liweiw/" title="46. 全排列 | 题解 | liweiwei1419">46. 全排列 | 题解 | liweiwei1419</a><br><a href="https://leetcode.cn/problems/permutations/solutions/2363882/46-quan-pai-lie-hui-su-qing-xi-tu-jie-by-6o7h/" title="46. 全排列 | 题解 | Krahets">46. 全排列 | 题解 | Krahets</a></p></blockquote><hr>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;给定一个不含重复数字的数组 &lt;code&gt;nums&lt;/code&gt; ，返回其所有可能的全排列 。你可以按任意顺序返回答案。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt;&lt;code&gt;nums = [1, 2, 3]&lt;/code&gt;&lt;br&gt;&lt;strong&gt;输出：&lt;/strong&gt;&lt;code&gt;[[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt;&lt;code&gt;nums = [0, 1]&lt;/code&gt;&lt;br&gt;&lt;strong&gt;输出：&lt;/strong&gt;&lt;code&gt;[[0, 1], [1, 0]]&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例 3:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt;&lt;code&gt;nums = [1]&lt;/code&gt;&lt;br&gt;&lt;strong&gt;输出：&lt;/strong&gt;&lt;code&gt;[[1]]&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;提示:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= nums.length &amp;lt;= 6&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-10 &amp;lt;= nums[i] &amp;lt;= 10&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nums&lt;/code&gt; 中的所有整数互不相同&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://www.cylong.com/categories/LeetCode/"/>
    
    
    <category term="Java" scheme="https://www.cylong.com/tags/Java/"/>
    
    <category term="LeetCode" scheme="https://www.cylong.com/tags/LeetCode/"/>
    
    <category term="学习笔记" scheme="https://www.cylong.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="数组" scheme="https://www.cylong.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="深度优先搜索" scheme="https://www.cylong.com/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
    <category term="LeetCode中等" scheme="https://www.cylong.com/tags/LeetCode%E4%B8%AD%E7%AD%89/"/>
    
    <category term="回溯" scheme="https://www.cylong.com/tags/%E5%9B%9E%E6%BA%AF/"/>
    
  </entry>
  
  <entry>
    <title>二叉树原地展开为链表：简洁递归解法深入分析（LeetCode 114）</title>
    <link href="https://www.cylong.com/blog/2025/07/14/flatten-binary-tree-to-linked-list/"/>
    <id>https://www.cylong.com/blog/2025/07/14/flatten-binary-tree-to-linked-list/</id>
    <published>2025-07-14T14:26:46.000Z</published>
    <updated>2025-07-14T14:26:46.000Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给你二叉树的根结点 <code>root</code> ，请你将它展开为一个单链表：</p><ul><li>展开后的单链表应该同样使用 <code>TreeNode</code> ，其中 <code>right</code> 子指针指向链表中下一个结点，而左子指针始终为 <code>null</code>。</li><li>展开后的单链表应该与二叉树 <strong>先序遍历</strong> 顺序相同。</li></ul><p><strong>示例 1:</strong></p><img src="/blog/2025/07/14/flatten-binary-tree-to-linked-list/flaten.jpg" class=""><blockquote><p><strong>输入：</strong><code>root = [1, 2, 5, 3, 4, null, 6]</code><br><strong>输出：</strong><code>[1, null, 2, null, 3, null, 4, null, 5, null, 6]</code></p></blockquote><p><strong>示例 2:</strong></p><blockquote><p><strong>输入：</strong><code>root = []</code><br><strong>输出：</strong><code>[]</code></p></blockquote><p><strong>示例 3:</strong></p><blockquote><p><strong>输入：</strong><code>root = [0]</code><br><strong>输出：</strong><code>[0]</code></p></blockquote><p><strong>提示:</strong></p><ul><li>树中结点数在范围 <code>[0, 2000]</code> 内</li><li><code>-100 &lt;= Node.val &lt;= 100</code></li></ul><span id="more"></span><h1 id="递归后序遍历"><a href="#递归后序遍历" class="headerlink" title="递归后序遍历"></a>递归后序遍历</h1><h2 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h2><p>核心思路采用递归后序遍历：</p><ol><li>递归展开左右子树</li><li>将左子树插入根节点与右子树之间</li><li>遍历至新链表末端连接右子树</li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">flatten</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 递归展开左右子树</span></span><br><span class="line">    flatten(root.left);</span><br><span class="line">    flatten(root.right);</span><br><span class="line">    </span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> root.left;   <span class="comment">// 保存左子树</span></span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> root.right; <span class="comment">// 保存右子树</span></span><br><span class="line">    </span><br><span class="line">    root.left = <span class="literal">null</span>;            <span class="comment">// 切断左指针</span></span><br><span class="line">    root.right = left;           <span class="comment">// 左子树变为右子树</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历至新链表末端</span></span><br><span class="line">    <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">    <span class="keyword">while</span> (cur.right != <span class="literal">null</span>) &#123;</span><br><span class="line">        cur = cur.right;</span><br><span class="line">    &#125;</span><br><span class="line">    cur.right = right;          <span class="comment">// 连接原右子树</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="算法流程详解"><a href="#算法流程详解" class="headerlink" title="算法流程详解"></a>算法流程详解</h2><ol><li><strong>递归终止：</strong>当前节点为 <code>null</code> 时返回</li><li><strong>后序遍历：</strong><ul><li>先递归处理左子树（<code>flatten(root.left)</code>）</li><li>再递归处理右子树（<code>flatten(root.right)</code>）</li></ul></li><li><strong>链表重组：</strong><ul><li>保存当前左右子树引用</li><li>将左子树作为新的右子树（<code>root.right = left</code>）</li><li>遍历新右子树找到末端节点</li><li>将原右子树接在末端节点后</li></ul></li></ol><h2 id="关键步骤图示"><a href="#关键步骤图示" class="headerlink" title="关键步骤图示"></a>关键步骤图示</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">原始结构：</span><br><span class="line">   root</span><br><span class="line">   /  \</span><br><span class="line">left  right</span><br><span class="line"></span><br><span class="line">重组后结构：</span><br><span class="line">root</span><br><span class="line">  \</span><br><span class="line">  left (展开的链表)</span><br><span class="line">     \</span><br><span class="line">    right (展开的链表)</span><br><span class="line"></span><br><span class="line">注：这里把 left 和 right 变为叶子节点，会更好理解</span><br></pre></td></tr></table></figure><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li><strong>时间复杂度：</strong><code>O(n)</code>，每个节点被访问两次，递归展开时访问一次，寻找链表末端时访问一次。</li><li><strong>空间复杂度：</strong><code>O(n)</code>，递归栈深度取决于树的高度，最坏情况（链状树）空间复杂度为 <code>O(n)</code>，平衡树情况为 <code>O(logn)</code>。</li></ul><h1 id="关键点总结"><a href="#关键点总结" class="headerlink" title="关键点总结"></a>关键点总结</h1><ol><li><strong>后序遍历顺序：</strong>必须保证左右子树都已展开成链表后才能进行根节点的重组。</li><li><strong>链表拼接细节：</strong>左子树插入后需遍历到末端再连接右子树，注意切断左指针避免结构混乱。</li><li><strong>原地修改：</strong>直接修改节点指针，不新建数据结构。</li></ol><h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><blockquote><p><a href="https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/description/" title="114. 二叉树展开为链表 | 力扣（LeetCode）">114. 二叉树展开为链表 | 力扣（LeetCode）</a></p></blockquote><hr>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;给你二叉树的根结点 &lt;code&gt;root&lt;/code&gt; ，请你将它展开为一个单链表：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;展开后的单链表应该同样使用 &lt;code&gt;TreeNode&lt;/code&gt; ，其中 &lt;code&gt;right&lt;/code&gt; 子指针指向链表中下一个结点，而左子指针始终为 &lt;code&gt;null&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;展开后的单链表应该与二叉树 &lt;strong&gt;先序遍历&lt;/strong&gt; 顺序相同。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;img src=&quot;/blog/2025/07/14/flatten-binary-tree-to-linked-list/flaten.jpg&quot; class=&quot;&quot;&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt;&lt;code&gt;root = [1, 2, 5, 3, 4, null, 6]&lt;/code&gt;&lt;br&gt;&lt;strong&gt;输出：&lt;/strong&gt;&lt;code&gt;[1, null, 2, null, 3, null, 4, null, 5, null, 6]&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt;&lt;code&gt;root = []&lt;/code&gt;&lt;br&gt;&lt;strong&gt;输出：&lt;/strong&gt;&lt;code&gt;[]&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例 3:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt;&lt;code&gt;root = [0]&lt;/code&gt;&lt;br&gt;&lt;strong&gt;输出：&lt;/strong&gt;&lt;code&gt;[0]&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;提示:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;树中结点数在范围 &lt;code&gt;[0, 2000]&lt;/code&gt; 内&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-100 &amp;lt;= Node.val &amp;lt;= 100&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://www.cylong.com/categories/LeetCode/"/>
    
    
    <category term="Java" scheme="https://www.cylong.com/tags/Java/"/>
    
    <category term="LeetCode" scheme="https://www.cylong.com/tags/LeetCode/"/>
    
    <category term="学习笔记" scheme="https://www.cylong.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="链表" scheme="https://www.cylong.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
    <category term="树" scheme="https://www.cylong.com/tags/%E6%A0%91/"/>
    
    <category term="二叉树" scheme="https://www.cylong.com/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    
    <category term="深度优先搜索" scheme="https://www.cylong.com/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
    <category term="LeetCode中等" scheme="https://www.cylong.com/tags/LeetCode%E4%B8%AD%E7%AD%89/"/>
    
  </entry>
  
  <entry>
    <title>前缀树（Trie）实现：插入、搜索与前缀匹配操作（LeetCode 208）</title>
    <link href="https://www.cylong.com/blog/2025/07/10/implement-trie-prefix-tree/"/>
    <id>https://www.cylong.com/blog/2025/07/10/implement-trie-prefix-tree/</id>
    <published>2025-07-10T15:06:58.000Z</published>
    <updated>2025-07-10T15:06:58.000Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p><code>Trie</code>（发音类似 “try”）或者说 <strong>前缀树</strong> 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补全和拼写检查。请你实现 <code>Trie</code> 类：</p><ul><li><code>Trie()</code> 初始化前缀树对象。</li><li><code>void insert(String word)</code> 向前缀树中插入字符串 <code>word</code> 。</li><li><code>boolean search(String word)</code> 如果字符串 <code>word</code> 在前缀树中，返回 <code>true</code>（即，在检索之前已经插入）；否则，返回 <code>false</code> 。</li><li><code>boolean startsWith(String prefix)</code> 如果之前已经插入的字符串 <code>word</code> 的前缀之一为 <code>prefix</code> ，返回 <code>true</code> ；否则，返回 <code>false</code> 。</li></ul><p><strong>示例 1:</strong></p><blockquote><p><strong>输入：</strong><br><code>[&quot;Trie&quot;, &quot;insert&quot;, &quot;search&quot;, &quot;search&quot;, &quot;startsWith&quot;, &quot;insert&quot;, &quot;search&quot;]</code><br><code>[[], [&quot;apple&quot;], [&quot;apple&quot;], [&quot;app&quot;], [&quot;app&quot;], [&quot;app&quot;], [&quot;app&quot;]]</code><br><strong>输出：</strong><br><code>[null, null, true, false, true, null, true]</code><br><strong>解释：</strong><br><code>Trie trie = new Trie();</code><br><code>trie.insert(&quot;apple&quot;);</code><br><code>trie.search(&quot;apple&quot;);</code>   // 返回 True<br><code>trie.search(&quot;app&quot;);</code>     // 返回 False<br><code>trie.startsWith(&quot;app&quot;);</code> // 返回 True<br><code>trie.insert(&quot;app&quot;);</code><br><code>trie.search(&quot;app&quot;);</code>     // 返回 True</p></blockquote><p><strong>提示:</strong></p><ul><li><code>1 &lt;= word.length, prefix.length &lt;= 2000</code></li><li><code>word</code> 和 <code>prefix</code> 仅由小写英文字母组成</li><li><code>insert</code>、<code>search</code> 和 <code>startsWith</code> 调用次数总计不超过 <code>3 * 10^4</code> 次</li></ul><span id="more"></span><h1 id="基于数组的-Trie-实现"><a href="#基于数组的-Trie-实现" class="headerlink" title="基于数组的 Trie 实现"></a>基于数组的 Trie 实现</h1><p>前缀树（<code>Trie</code>）是一种高效检索字符串数据集中的键的树形数据结构。它广泛应用于搜索引擎、拼写检查、自动补全等场景。<code>Trie</code> 的核心思想是利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较。</p><h2 id="Trie-节点设计"><a href="#Trie-节点设计" class="headerlink" title="Trie 节点设计"></a>Trie 节点设计</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="comment">// 子节点数组，每个位置对应一个字母（a-z）</span></span><br><span class="line">    Node[] son = <span class="keyword">new</span> <span class="title class_">Node</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="comment">// 标记当前节点是否为单词结尾</span></span><br><span class="line">    <span class="type">boolean</span> end;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Trie-类实现"><a href="#Trie-类实现" class="headerlink" title="Trie 类实现"></a>Trie 类实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line">    <span class="comment">// 根节点，不存储实际字符</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Node</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Trie</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向 Trie 中插入一个单词</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> word 要插入的单词</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="comment">// 从根节点开始</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : word.toCharArray()) &#123;</span><br><span class="line">            <span class="comment">// 将字符转换为数组索引（0-25）</span></span><br><span class="line">            c -= <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="comment">// 如果当前字符对应的路径不存在</span></span><br><span class="line">            <span class="keyword">if</span> (cur.son[c] == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 创建新节点</span></span><br><span class="line">                cur.son[c] = <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 移动到子节点</span></span><br><span class="line">            cur = cur.son[c];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 标记单词结束</span></span><br><span class="line">        cur.end = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 搜索 Trie 中是否存在完整单词</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> word 要搜索的单词</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 存在返回 true，否则返回 false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">search</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="comment">// 需要完全匹配（状态值 2）</span></span><br><span class="line">        <span class="keyword">return</span> find(word) == <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 检查 Trie 中是否有以指定前缀开头的单词</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> prefix 要检查的前缀</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 存在返回 true，否则返回 false</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">startsWith</span><span class="params">(String prefix)</span> &#123;</span><br><span class="line">        <span class="comment">// 只要路径存在即可（状态值 1 或 2）</span></span><br><span class="line">        <span class="keyword">return</span> find(prefix) != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 内部查找方法，返回匹配状态</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> word 要查找的单词或前缀</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 0: 未找到, 1: 前缀存在, 2: 完整单词存在</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : word.toCharArray()) &#123;</span><br><span class="line">            <span class="comment">// 字符转索引</span></span><br><span class="line">            c -= <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (cur.son[c] == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 路径中断，未找到</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 继续向下查找</span></span><br><span class="line">            cur = cur.son[c];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 路径存在，检查是否为完整单词</span></span><br><span class="line">        <span class="keyword">return</span> cur.end ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li><strong>时间复杂度：</strong><ul><li>插入操作：<code>O(L)</code>，其中 <code>L</code> 是插入单词的长度。需要遍历单词的每个字符。</li><li>搜索操作：<code>O(L)</code>，其中 <code>L</code> 是搜索单词的长度。需要遍历单词的每个字符。</li><li>前缀搜索：<code>O(L)</code>，其中 <code>L</code> 是前缀的长度。需要遍历前缀的每个字符。</li></ul></li><li><strong>空间复杂度：</strong><ul><li>最坏情况：<code>O(MN)</code>，其中 <code>M</code> 是单词的平均长度，<code>N</code> 是插入的单词数量。每个字符都需要一个节点。</li><li>最佳情况：当单词共享大量前缀时，空间复杂度会显著降低。</li></ul></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li><strong>节点结构：</strong>每个节点包含一个长度为 <code>26</code> 的子节点数组（对应 <code>26</code> 个小写字母）和一个结束标志。</li><li><strong>路径创建：</strong>在插入过程中，如果路径不存在则动态创建新节点。</li><li><strong>结束标志：</strong>单词插入完成后，在最后一个节点标记结束标志。</li><li><strong>查找优化：</strong>使用统一的 <code>find</code> 方法处理完整单词查找和前缀查找，避免代码重复。</li><li><strong>字符转换：</strong>通过 <code>c - &#39;a&#39;</code> 将字符转换为数组索引（0-25），高效访问子节点。</li></ol><p><code>Trie</code> 是一种高效处理字符串相关问题的数据结构，特别适合前缀匹配的场景。本文实现的 <code>Trie</code> 结构清晰，操作高效，时间复杂度均为线性级别。理解 <code>Trie</code> 的工作原理对于解决字符串搜索、自动补全等问题至关重要。实际应用中，可以根据需求扩展 <code>Trie</code> 功能，如添加词频统计、删除操作等。</p><h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><blockquote><p><a href="https://leetcode.cn/problems/implement-trie-prefix-tree/description/" title="208. 实现 Trie (前缀树) | 力扣（LeetCode）">208. 实现 Trie (前缀树) | 力扣（LeetCode）</a><br><a href="https://leetcode.cn/problems/implement-trie-prefix-tree/solutions/2993894/cong-er-cha-shu-dao-er-shi-liu-cha-shu-p-xsj4/" title="208. 实现 Trie (前缀树) | 题解 | 灵茶山艾府">208. 实现 Trie (前缀树) | 题解 | 灵茶山艾府</a></p></blockquote><hr>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;&lt;code&gt;Trie&lt;/code&gt;（发音类似 “try”）或者说 &lt;strong&gt;前缀树&lt;/strong&gt; 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补全和拼写检查。请你实现 &lt;code&gt;Trie&lt;/code&gt; 类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Trie()&lt;/code&gt; 初始化前缀树对象。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;void insert(String word)&lt;/code&gt; 向前缀树中插入字符串 &lt;code&gt;word&lt;/code&gt; 。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;boolean search(String word)&lt;/code&gt; 如果字符串 &lt;code&gt;word&lt;/code&gt; 在前缀树中，返回 &lt;code&gt;true&lt;/code&gt;（即，在检索之前已经插入）；否则，返回 &lt;code&gt;false&lt;/code&gt; 。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;boolean startsWith(String prefix)&lt;/code&gt; 如果之前已经插入的字符串 &lt;code&gt;word&lt;/code&gt; 的前缀之一为 &lt;code&gt;prefix&lt;/code&gt; ，返回 &lt;code&gt;true&lt;/code&gt; ；否则，返回 &lt;code&gt;false&lt;/code&gt; 。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt;&lt;br&gt;&lt;code&gt;[&amp;quot;Trie&amp;quot;, &amp;quot;insert&amp;quot;, &amp;quot;search&amp;quot;, &amp;quot;search&amp;quot;, &amp;quot;startsWith&amp;quot;, &amp;quot;insert&amp;quot;, &amp;quot;search&amp;quot;]&lt;/code&gt;&lt;br&gt;&lt;code&gt;[[], [&amp;quot;apple&amp;quot;], [&amp;quot;apple&amp;quot;], [&amp;quot;app&amp;quot;], [&amp;quot;app&amp;quot;], [&amp;quot;app&amp;quot;], [&amp;quot;app&amp;quot;]]&lt;/code&gt;&lt;br&gt;&lt;strong&gt;输出：&lt;/strong&gt;&lt;br&gt;&lt;code&gt;[null, null, true, false, true, null, true]&lt;/code&gt;&lt;br&gt;&lt;strong&gt;解释：&lt;/strong&gt;&lt;br&gt;&lt;code&gt;Trie trie = new Trie();&lt;/code&gt;&lt;br&gt;&lt;code&gt;trie.insert(&amp;quot;apple&amp;quot;);&lt;/code&gt;&lt;br&gt;&lt;code&gt;trie.search(&amp;quot;apple&amp;quot;);&lt;/code&gt;   // 返回 True&lt;br&gt;&lt;code&gt;trie.search(&amp;quot;app&amp;quot;);&lt;/code&gt;     // 返回 False&lt;br&gt;&lt;code&gt;trie.startsWith(&amp;quot;app&amp;quot;);&lt;/code&gt; // 返回 True&lt;br&gt;&lt;code&gt;trie.insert(&amp;quot;app&amp;quot;);&lt;/code&gt;&lt;br&gt;&lt;code&gt;trie.search(&amp;quot;app&amp;quot;);&lt;/code&gt;     // 返回 True&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;提示:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= word.length, prefix.length &amp;lt;= 2000&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;word&lt;/code&gt; 和 &lt;code&gt;prefix&lt;/code&gt; 仅由小写英文字母组成&lt;/li&gt;
&lt;li&gt;&lt;code&gt;insert&lt;/code&gt;、&lt;code&gt;search&lt;/code&gt; 和 &lt;code&gt;startsWith&lt;/code&gt; 调用次数总计不超过 &lt;code&gt;3 * 10^4&lt;/code&gt; 次&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://www.cylong.com/categories/LeetCode/"/>
    
    
    <category term="Java" scheme="https://www.cylong.com/tags/Java/"/>
    
    <category term="LeetCode" scheme="https://www.cylong.com/tags/LeetCode/"/>
    
    <category term="学习笔记" scheme="https://www.cylong.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="字符串" scheme="https://www.cylong.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    <category term="树" scheme="https://www.cylong.com/tags/%E6%A0%91/"/>
    
    <category term="字典树" scheme="https://www.cylong.com/tags/%E5%AD%97%E5%85%B8%E6%A0%91/"/>
    
    <category term="LeetCode中等" scheme="https://www.cylong.com/tags/LeetCode%E4%B8%AD%E7%AD%89/"/>
    
  </entry>
  
  <entry>
    <title>多源 BFS 解决腐烂橘子问题（LeetCode 994）</title>
    <link href="https://www.cylong.com/blog/2025/07/09/rotting-oranges/"/>
    <id>https://www.cylong.com/blog/2025/07/09/rotting-oranges/</id>
    <published>2025-07-09T13:44:07.000Z</published>
    <updated>2025-07-09T13:44:07.000Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>在给定的 <code>m x n</code> 网格 <code>grid</code> 中，每个单元格可以有以下三个值之一：</p><ul><li>值 <code>0</code> 代表空单元格；</li><li>值 <code>1</code> 代表新鲜橘子；</li><li>值 <code>2</code> 代表腐烂的橘子。</li></ul><p>每分钟，腐烂的橘子 周围 <code>4</code> 个方向上相邻 的新鲜橘子都会腐烂。返回直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 <code>-1</code> 。</p><p><strong>示例 1:</strong></p><img src="/blog/2025/07/09/rotting-oranges/oranges.png" class=""><blockquote><p><strong>输入：</strong><code>grid = [[2, 1, 1],[1, 1, 0],[0, 1, 1]]</code><br><strong>输出：</strong><code>4</code></p></blockquote><p><strong>示例 2:</strong></p><blockquote><p><strong>输入：</strong><code>grid = [[2, 1, 1],[0, 1, 1],[1, 0, 1]]</code><br><strong>输出：</strong><code>-1</code><br><strong>解释：</strong>左下角的橘子（第 <code>2</code> 行， 第 <code>0</code> 列）永远不会腐烂，因为腐烂只会发生在 <code>4</code> 个方向上。</p></blockquote><p><strong>示例 3:</strong></p><blockquote><p><strong>输入：</strong><code>grid = [[0, 2]]</code><br><strong>输出：</strong><code>0</code><br><strong>解释：</strong>因为 <code>0</code> 分钟时已经没有新鲜橘子了，所以答案就是 <code>0</code> 。</p></blockquote><p><strong>提示:</strong></p><ul><li><code>m == grid.length</code></li><li><code>n == grid[i].length</code></li><li><code>1 &lt;= m, n &lt;= 10</code></li><li><code>grid[i][j]</code> 仅为 <code>0</code>、<code>1</code> 或 <code>2</code></li></ul><span id="more"></span><h1 id="多源-BFS（广度优先搜索）"><a href="#多源-BFS（广度优先搜索）" class="headerlink" title="多源 BFS（广度优先搜索）"></a>多源 BFS（广度优先搜索）</h1><h2 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h2><p>使用多源 <code>BFS</code> 模拟橘子腐烂的过程：</p><ol><li><strong>初始化：</strong>遍历整个网格，统计新鲜橘子的数量，并将所有腐烂橘子的坐标加入队列。</li><li><strong>BFS遍历：</strong>从所有腐烂橘子同时开始扩散。<ul><li>每一轮处理当前队列中的所有腐烂橘子（同一分钟）。</li><li>每个腐烂橘子使其上下左右相邻的新鲜橘子腐烂。</li><li>新腐烂的橘子加入队列（下一分钟继续扩散）。</li></ul></li><li><strong>结果判断：</strong><code>BFS</code> 结束后，若还有新鲜橘子剩余，返回 <code>-1</code>；否则返回分钟数。</li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">orangesRotting</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">rows</span> <span class="operator">=</span> grid.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cols</span> <span class="operator">=</span> grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">minutes</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 记录新鲜橘子数量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">freshCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// BFS 队列</span></span><br><span class="line">        Queue&lt;<span class="type">int</span>[]&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 四个方向：上、下、左、右</span></span><br><span class="line">        <span class="type">int</span>[][] directions = &#123;&#123;-<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 初始化：统计新鲜橘子，并将腐烂橘子入队</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; rows; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; cols; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                    freshCount++;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (grid[i][j] == <span class="number">2</span>) &#123;</span><br><span class="line">                    queue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;i, j&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// BFS 开始：当还有新鲜橘子且队列不为空时</span></span><br><span class="line">        <span class="keyword">while</span> (freshCount &gt; <span class="number">0</span> &amp;&amp; !queue.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 当前层的橘子数量</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">levelSize</span> <span class="operator">=</span> queue.size();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 处理当前层的所有腐烂橘子</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; levelSize; i++) &#123;</span><br><span class="line">                <span class="type">int</span>[] cur = queue.poll();</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 向四个方向扩散</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span>[] dir : directions) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> cur[<span class="number">0</span>] + dir[<span class="number">0</span>];</span><br><span class="line">                    <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> cur[<span class="number">1</span>] + dir[<span class="number">1</span>];</span><br><span class="line">                    </span><br><span class="line">                    <span class="comment">// 检查边界且是否为新鲜橘子</span></span><br><span class="line">                    <span class="keyword">if</span> (x &gt;= <span class="number">0</span> &amp;&amp; x &lt; rows &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; cols &amp;&amp; grid[x][y] == <span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="comment">// 标记为腐烂</span></span><br><span class="line">                        grid[x][y] = <span class="number">2</span>;</span><br><span class="line">                        <span class="comment">// 新鲜橘子减少</span></span><br><span class="line">                        freshCount--;</span><br><span class="line">                        <span class="comment">// 新腐烂橘子入队</span></span><br><span class="line">                        queue.offer(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;x, y&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当前层处理完毕，分钟数增加</span></span><br><span class="line">            minutes++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 若还有剩余新鲜橘子，返回 -1；否则返回分钟数</span></span><br><span class="line">        <span class="keyword">return</span> freshCount == <span class="number">0</span> ? minutes : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li><strong>时间复杂度：</strong><code>O(mn)</code>，每个网格单元最多被访问一次。</li><li><strong>空间复杂度：</strong><code>O(mn)</code>，最坏情况下队列需要存储所有腐烂橘子。</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li><strong>多源BFS：</strong>所有初始腐烂橘子同时开始扩散，确保分钟计数准确。</li><li><strong>层级处理：</strong>通过记录队列大小处理同一分钟的所有腐烂橘子。</li><li><strong>边界判断：</strong>扩散时检查网格边界和橘子状态。</li><li><strong>提前终止：</strong>当新鲜橘子数为 <code>0</code> 时，可提前结束 <code>BFS</code>。</li></ol><p>该解法高效地模拟了橘子腐烂的过程，时间复杂度与网格大小成正比，是最优解法。</p><h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><blockquote><p><a href="https://leetcode.cn/problems/rotting-oranges/description/" title="994. 腐烂的橘子 | 力扣（LeetCode）">994. 腐烂的橘子 | 力扣（LeetCode）</a><br><a href="https://leetcode.cn/problems/rotting-oranges/solutions/3712941/bfszhu-shi-fei-chang-qing-xi-ban-ben-by-jzug4/" title="994. 腐烂的橘子 | 题解 | Bravo">994. 腐烂的橘子 | 题解 | Krahets</a><br><a href="https://leetcode.cn/problems/rotting-oranges/solutions/2773461/duo-yuan-bfsfu-ti-dan-pythonjavacgojsrus-yfmh/" title="994. 腐烂的橘子 | 题解 | 灵茶山艾府">994. 腐烂的橘子 | 题解 | 灵茶山艾府</a></p></blockquote><hr>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;在给定的 &lt;code&gt;m x n&lt;/code&gt; 网格 &lt;code&gt;grid&lt;/code&gt; 中，每个单元格可以有以下三个值之一：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;值 &lt;code&gt;0&lt;/code&gt; 代表空单元格；&lt;/li&gt;
&lt;li&gt;值 &lt;code&gt;1&lt;/code&gt; 代表新鲜橘子；&lt;/li&gt;
&lt;li&gt;值 &lt;code&gt;2&lt;/code&gt; 代表腐烂的橘子。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;每分钟，腐烂的橘子 周围 &lt;code&gt;4&lt;/code&gt; 个方向上相邻 的新鲜橘子都会腐烂。返回直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 &lt;code&gt;-1&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;img src=&quot;/blog/2025/07/09/rotting-oranges/oranges.png&quot; class=&quot;&quot;&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt;&lt;code&gt;grid = [[2, 1, 1],[1, 1, 0],[0, 1, 1]]&lt;/code&gt;&lt;br&gt;&lt;strong&gt;输出：&lt;/strong&gt;&lt;code&gt;4&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt;&lt;code&gt;grid = [[2, 1, 1],[0, 1, 1],[1, 0, 1]]&lt;/code&gt;&lt;br&gt;&lt;strong&gt;输出：&lt;/strong&gt;&lt;code&gt;-1&lt;/code&gt;&lt;br&gt;&lt;strong&gt;解释：&lt;/strong&gt;左下角的橘子（第 &lt;code&gt;2&lt;/code&gt; 行， 第 &lt;code&gt;0&lt;/code&gt; 列）永远不会腐烂，因为腐烂只会发生在 &lt;code&gt;4&lt;/code&gt; 个方向上。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例 3:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt;&lt;code&gt;grid = [[0, 2]]&lt;/code&gt;&lt;br&gt;&lt;strong&gt;输出：&lt;/strong&gt;&lt;code&gt;0&lt;/code&gt;&lt;br&gt;&lt;strong&gt;解释：&lt;/strong&gt;因为 &lt;code&gt;0&lt;/code&gt; 分钟时已经没有新鲜橘子了，所以答案就是 &lt;code&gt;0&lt;/code&gt; 。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;提示:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;m == grid.length&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;n == grid[i].length&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= m, n &amp;lt;= 10&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;grid[i][j]&lt;/code&gt; 仅为 &lt;code&gt;0&lt;/code&gt;、&lt;code&gt;1&lt;/code&gt; 或 &lt;code&gt;2&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://www.cylong.com/categories/LeetCode/"/>
    
    
    <category term="Java" scheme="https://www.cylong.com/tags/Java/"/>
    
    <category term="LeetCode" scheme="https://www.cylong.com/tags/LeetCode/"/>
    
    <category term="学习笔记" scheme="https://www.cylong.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="数组" scheme="https://www.cylong.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="队列" scheme="https://www.cylong.com/tags/%E9%98%9F%E5%88%97/"/>
    
    <category term="矩阵" scheme="https://www.cylong.com/tags/%E7%9F%A9%E9%98%B5/"/>
    
    <category term="广度优先搜索" scheme="https://www.cylong.com/tags/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
    <category term="LeetCode中等" scheme="https://www.cylong.com/tags/LeetCode%E4%B8%AD%E7%AD%89/"/>
    
  </entry>
  
  <entry>
    <title>哈希表与双向链表实现LRU缓存（LeetCode 146）</title>
    <link href="https://www.cylong.com/blog/2025/07/07/lru-cache/"/>
    <id>https://www.cylong.com/blog/2025/07/07/lru-cache/</id>
    <published>2025-07-07T14:05:52.000Z</published>
    <updated>2025-07-07T14:05:52.000Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>请你设计并实现一个满足 <strong>LRU (最近最少使用) 缓存</strong> 约束的数据结构。<br>实现 <code>LRUCache</code> 类：</p><ul><li><code>LRUCache(int capacity)</code> 以正整数作为容量 <code>capacity</code> 初始化 <code>LRU</code> 缓存。</li><li><code>int get(int key)</code> 如果关键字 <code>key</code> 存在于缓存中，则返回关键字的值，否则返回 <code>-1</code> 。</li><li><code>void put(int key, int value)</code> 如果关键字 <code>key</code> 已经存在，则变更其数据值 <code>value</code> ；如果不存在，则向缓存中插入该组 <code>key-value</code> 。如果插入操作导致关键字数量超过 <code>capacity</code> ，则应该逐出最久未使用的关键字。</li><li>函数 <code>get</code> 和 <code>put</code> 必须以 <code>O(1)</code> 的平均时间复杂度运行。</li></ul><p><strong>示例 1:</strong></p><blockquote><p><strong>输入：</strong><br><code>[&quot;LRUCache&quot;, &quot;put&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;put&quot;, &quot;get&quot;, &quot;get&quot;, &quot;get&quot;]</code><br><code>[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]</code><br><strong>输出：</strong><code>[null, null, null, 1, null, -1, null, -1, 3, 4]</code><br><strong>解释：</strong><br>LRUCache lRUCache = new LRUCache(2);<br>lRUCache.put(1, 1); // 缓存是 {1=1}<br>lRUCache.put(2, 2); // 缓存是 {1=1, 2=2}<br>lRUCache.get(1);    // 返回 1<br>lRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3}<br>lRUCache.get(2);    // 返回 -1 (未找到)<br>lRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3}<br>lRUCache.get(1);    // 返回 -1 (未找到)<br>lRUCache.get(3);    // 返回 3<br>lRUCache.get(4);    // 返回 4</p></blockquote><p><strong>提示:</strong></p><ul><li><code>1 &lt;= capacity &lt;= 3000</code></li><li><code>0 &lt;= key &lt;= 10000</code></li><li><code>0 &lt;= value &lt;= 10^5</code></li><li>最多调用 <code>2 * 10^5</code> 次 <code>get</code> 和 <code>put</code></li></ul><span id="more"></span><h1 id="哈希表-双向链表"><a href="#哈希表-双向链表" class="headerlink" title="哈希表 + 双向链表"></a>哈希表 + 双向链表</h1><h2 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h2><p>使用 <strong>哈希表</strong> 实现 <code>O(1)</code> 时间复杂度的键值查找，通过 <strong>双向链表</strong> 维护访问顺序：</p><ol><li>链表头部存放最近访问的节点</li><li>链表尾部存放最久未使用的节点</li><li>伪头尾节点简化链表边界操作</li></ol><h2 id="关键操作图解"><a href="#关键操作图解" class="headerlink" title="关键操作图解"></a>关键操作图解</h2><ol><li>添加节点到头部<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">head &lt;-&gt; [node] &lt;-&gt; oldFirst</span><br><span class="line">1. node.prev = head</span><br><span class="line">2. node.next = head.next</span><br><span class="line">3. head.next.prev = node</span><br><span class="line">4. head.next = node</span><br></pre></td></tr></table></figure></li><li>移除节点<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">prevNode &lt;-&gt; [node] &lt;-&gt; nextNode</span><br><span class="line">=&gt; prevNode &lt;-&gt; nextNode</span><br><span class="line">1. node.prev.next = node.next</span><br><span class="line">2. node.next.prev = node.prev</span><br></pre></td></tr></table></figure></li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">DLinkedNode</span> &#123;</span><br><span class="line">        <span class="type">int</span> key;</span><br><span class="line">        <span class="type">int</span> value;</span><br><span class="line">        DLinkedNode prev;</span><br><span class="line">        DLinkedNode next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">DLinkedNode</span><span class="params">()</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">DLinkedNode</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Integer, DLinkedNode&gt; cache = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> size;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> capacity;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DLinkedNode head;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DLinkedNode tail;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LRUCache</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.size = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">        <span class="comment">// 使用伪头部和伪尾部节点</span></span><br><span class="line">        head = <span class="keyword">new</span> <span class="title class_">DLinkedNode</span>();</span><br><span class="line">        tail = <span class="keyword">new</span> <span class="title class_">DLinkedNode</span>();</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.prev = head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span> &#123;</span><br><span class="line">        <span class="type">DLinkedNode</span> <span class="variable">node</span> <span class="operator">=</span> cache.get(key);</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果 key 存在，先通过哈希表定位，再移到头部</span></span><br><span class="line">        moveToHead(node);</span><br><span class="line">        <span class="keyword">return</span> node.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="type">DLinkedNode</span> <span class="variable">node</span> <span class="operator">=</span> cache.get(key);</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果 key 不存在，创建一个新的节点</span></span><br><span class="line">            <span class="type">DLinkedNode</span> <span class="variable">newNode</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DLinkedNode</span>(key, value);</span><br><span class="line">            <span class="comment">// 添加进哈希表</span></span><br><span class="line">            cache.put(key, newNode);</span><br><span class="line">            <span class="comment">// 添加至双向链表的头部</span></span><br><span class="line">            addToHead(newNode);</span><br><span class="line">            size++;</span><br><span class="line">            <span class="keyword">if</span> (size &gt; capacity) &#123;</span><br><span class="line">                <span class="comment">// 如果超出容量，删除双向链表的尾部节点</span></span><br><span class="line">                <span class="type">DLinkedNode</span> <span class="variable">tail</span> <span class="operator">=</span> removeTail();</span><br><span class="line">                <span class="comment">// 删除哈希表中对应的项</span></span><br><span class="line">                cache.remove(tail.key);</span><br><span class="line">                size--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部</span></span><br><span class="line">            node.value = value;</span><br><span class="line">            moveToHead(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addToHead</span><span class="params">(DLinkedNode node)</span> &#123;</span><br><span class="line">        node.prev = head;</span><br><span class="line">        node.next = head.next;</span><br><span class="line">        head.next.prev = node;</span><br><span class="line">        head.next = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">removeNode</span><span class="params">(DLinkedNode node)</span> &#123;</span><br><span class="line">        node.prev.next = node.next;</span><br><span class="line">        node.next.prev = node.prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">moveToHead</span><span class="params">(DLinkedNode node)</span> &#123;</span><br><span class="line">        removeNode(node);</span><br><span class="line">        addToHead(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> DLinkedNode <span class="title function_">removeTail</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">DLinkedNode</span> <span class="variable">res</span> <span class="operator">=</span> tail.prev;</span><br><span class="line">        removeNode(res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li><strong>时间复杂度：</strong><code>O(1)</code>，哈希表查找 <code>O(1)</code>，链表操作 <code>O(1)</code>。</li><li><strong>空间复杂度：</strong><code>O(n)</code>，哈希表存储 <code>n</code> 个键值对，双向链表存储 <code>n+2</code> 个节点（含伪头尾）。</li></ul><h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><ol><li>数据库查询缓存</li><li>浏览器页面缓存</li><li>操作系统页面置换算法</li><li>微服务API响应缓存</li></ol><p><strong>关键点总结：</strong>哈希表保证快速访问，双向链表维护访问顺序，伪头尾节点简化边界处理。通过O(1)时间完成核心操作，是工业级LRU缓存的经典实现。</p><h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><blockquote><p><a href="https://leetcode.cn/problems/lru-cache/description/" title="146. LRU 缓存 | 力扣（LeetCode）">146. LRU 缓存 | 力扣（LeetCode）</a></p></blockquote><hr>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;请你设计并实现一个满足 &lt;strong&gt;LRU (最近最少使用) 缓存&lt;/strong&gt; 约束的数据结构。&lt;br&gt;实现 &lt;code&gt;LRUCache&lt;/code&gt; 类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;LRUCache(int capacity)&lt;/code&gt; 以正整数作为容量 &lt;code&gt;capacity&lt;/code&gt; 初始化 &lt;code&gt;LRU&lt;/code&gt; 缓存。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;int get(int key)&lt;/code&gt; 如果关键字 &lt;code&gt;key&lt;/code&gt; 存在于缓存中，则返回关键字的值，否则返回 &lt;code&gt;-1&lt;/code&gt; 。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;void put(int key, int value)&lt;/code&gt; 如果关键字 &lt;code&gt;key&lt;/code&gt; 已经存在，则变更其数据值 &lt;code&gt;value&lt;/code&gt; ；如果不存在，则向缓存中插入该组 &lt;code&gt;key-value&lt;/code&gt; 。如果插入操作导致关键字数量超过 &lt;code&gt;capacity&lt;/code&gt; ，则应该逐出最久未使用的关键字。&lt;/li&gt;
&lt;li&gt;函数 &lt;code&gt;get&lt;/code&gt; 和 &lt;code&gt;put&lt;/code&gt; 必须以 &lt;code&gt;O(1)&lt;/code&gt; 的平均时间复杂度运行。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt;&lt;br&gt;&lt;code&gt;[&amp;quot;LRUCache&amp;quot;, &amp;quot;put&amp;quot;, &amp;quot;put&amp;quot;, &amp;quot;get&amp;quot;, &amp;quot;put&amp;quot;, &amp;quot;get&amp;quot;, &amp;quot;put&amp;quot;, &amp;quot;get&amp;quot;, &amp;quot;get&amp;quot;, &amp;quot;get&amp;quot;]&lt;/code&gt;&lt;br&gt;&lt;code&gt;[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]&lt;/code&gt;&lt;br&gt;&lt;strong&gt;输出：&lt;/strong&gt;&lt;code&gt;[null, null, null, 1, null, -1, null, -1, 3, 4]&lt;/code&gt;&lt;br&gt;&lt;strong&gt;解释：&lt;/strong&gt;&lt;br&gt;LRUCache lRUCache = new LRUCache(2);&lt;br&gt;lRUCache.put(1, 1); // 缓存是 {1=1}&lt;br&gt;lRUCache.put(2, 2); // 缓存是 {1=1, 2=2}&lt;br&gt;lRUCache.get(1);    // 返回 1&lt;br&gt;lRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3}&lt;br&gt;lRUCache.get(2);    // 返回 -1 (未找到)&lt;br&gt;lRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3}&lt;br&gt;lRUCache.get(1);    // 返回 -1 (未找到)&lt;br&gt;lRUCache.get(3);    // 返回 3&lt;br&gt;lRUCache.get(4);    // 返回 4&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;提示:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= capacity &amp;lt;= 3000&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0 &amp;lt;= key &amp;lt;= 10000&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0 &amp;lt;= value &amp;lt;= 10^5&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;最多调用 &lt;code&gt;2 * 10^5&lt;/code&gt; 次 &lt;code&gt;get&lt;/code&gt; 和 &lt;code&gt;put&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://www.cylong.com/categories/LeetCode/"/>
    
    
    <category term="Java" scheme="https://www.cylong.com/tags/Java/"/>
    
    <category term="LeetCode" scheme="https://www.cylong.com/tags/LeetCode/"/>
    
    <category term="学习笔记" scheme="https://www.cylong.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="链表" scheme="https://www.cylong.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
    <category term="哈希表" scheme="https://www.cylong.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
    <category term="LeetCode中等" scheme="https://www.cylong.com/tags/LeetCode%E4%B8%AD%E7%AD%89/"/>
    
    <category term="双向链表" scheme="https://www.cylong.com/tags/%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/"/>
    
    <category term="缓存" scheme="https://www.cylong.com/tags/%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>双指针法求解链表交点（LeetCode 160）</title>
    <link href="https://www.cylong.com/blog/2025/07/01/intersection-of-two-linked-lists/"/>
    <id>https://www.cylong.com/blog/2025/07/01/intersection-of-two-linked-lists/</id>
    <published>2025-06-30T16:41:55.000Z</published>
    <updated>2025-06-30T16:41:55.000Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给你两个单链表的头节点 <code>headA</code> 和 <code>headB</code> ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 <code>null</code> 。题目数据保证整个链式结构中不存在环。</p><p>图示两个链表在节点 <code>c1</code> 开始相交：</p><img src="/blog/2025/07/01/intersection-of-two-linked-lists/160_statement.png" class=""><p><strong>注意：</strong>函数返回结果后，链表必须保持其原始结构 。</p><p><strong>自定义评测：</strong><br>评测系统的输入如下（你设计的程序不适用此输入）：</p><ul><li><code>intersectVal</code> - 相交的起始节点的值。如果不存在相交节点，这一值为 <code>0</code></li><li><code>listA</code> - 第一个链表</li><li><code>listB</code> - 第二个链表</li><li><code>skipA</code> - 在 <code>listA</code> 中（从头节点开始）跳到交叉节点的节点数</li><li><code>skipB</code> - 在 <code>listB</code> 中（从头节点开始）跳到交叉节点的节点数</li><li>评测系统将根据这些输入创建链式数据结构，并将两个头节点 <code>headA</code> 和 <code>headB</code> 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被视作正确答案。</li></ul><p><strong>示例 1:</strong></p><img src="/blog/2025/07/01/intersection-of-two-linked-lists/160_example_1.png" class=""><blockquote><p><strong>输入：</strong><code>intersectVal = 8</code>, <code>listA = [4,1,8,4,5]</code>, <code>listB = [5, 6, 1, 8, 4, 5]</code>, <code>skipA = 2</code>, <code>skipB = 3</code><br><strong>输出：</strong><code>Intersected at &#39;8&#39;</code><br><strong>解释：</strong></p><ul><li>相交节点的值为 <code>8</code> （注意，如果两个链表相交则不能为 <code>0</code>）。</li><li>从各自的表头开始算起，链表 <code>A</code> 为 <code>[4, 1, 8, 4, 5]</code>，链表 <code>B</code> 为 <code>[5, 6, 1, 8, 4, 5]</code>。</li><li>在 <code>A</code> 中，相交节点前有 2 个节点；在 <code>B</code> 中，相交节点前有 3 个节点。</li><li>请注意相交节点的值不为 1，因为在链表 <code>A</code> 和链表 <code>B</code> 之中值为 1 的节点 (<code>A</code> 中第二个节点和 <code>B</code> 中第三个节点) 是不同的节点。换句话说，它们在内存中指向两个不同的位置，而链表 <code>A</code> 和链表 <code>B</code> 中值为 8 的节点 (<code>A</code> 中第三个节点，<code>B</code> 中第四个节点) 在内存中指向相同的位置。</li></ul></blockquote><p><strong>示例 2:</strong></p><img src="/blog/2025/07/01/intersection-of-two-linked-lists/160_example_2.png" class=""><blockquote><p><strong>输入：</strong><code>intersectVal = 2</code>, <code>listA = [1, 9, 1, 2, 4]</code>, <code>listB = [3, 2, 4]</code>, <code>skipA = 3</code>, <code>skipB = 1</code><br><strong>输出：</strong><code>Intersected at &#39;2&#39;</code><br><strong>解释：</strong></p><ul><li>相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。</li><li>从各自的表头开始算起，链表 <code>A</code> 为 <code>[1, 9, 1, 2, 4]</code>，链表 <code>B</code> 为 <code>[3, 2, 4]</code>。</li><li>在 <code>A</code> 中，相交节点前有 3 个节点；在 <code>B</code> 中，相交节点前有 1 个节点。</li></ul></blockquote><p><strong>示例 3:</strong></p><img src="/blog/2025/07/01/intersection-of-two-linked-lists/160_example_3.png" class=""><blockquote><p><strong>输入：</strong><code>intersectVal = 0</code>, <code>listA = [2, 6, 4]</code>, <code>listB = [1, 5]</code>, <code>skipA = 3</code>, <code>skipB = 2</code><br><strong>输出：</strong><code>No intersection</code><br><strong>解释：</strong></p><ul><li>从各自的表头开始算起，链表 <code>A</code> 为 <code>[2, 6, 4]</code>，链表 <code>B</code> 为 <code>[1, 5]</code>。</li><li>由于这两个链表不相交，所以 <code>intersectVal</code> 必须为 0，而 <code>skipA</code> 和 <code>skipB</code> 可以是任意值。</li><li>这两个链表不相交，因此返回 <code>null</code> 。</li></ul></blockquote><p><strong>提示:</strong></p><ul><li><code>listA</code> 中节点数目为 <code>m</code></li><li><code>listB</code> 中节点数目为 <code>n</code></li><li><code>1 &lt;= m, n &lt;= 3 * 10^4</code></li><li><code>1 &lt;= Node.val &lt;= 10^5</code></li><li><code>0 &lt;= skipA &lt;= m</code></li><li><code>0 &lt;= skipB &lt;= n</code></li><li>如果 <code>listA</code> 和 <code>listB</code> 没有交点，<code>intersectVal</code> 为 0</li><li>如果 <code>listA</code> 和 <code>listB</code> 有交点，<code>intersectVal == listA[skipA] == listB[skipB]</code></li></ul><span id="more"></span><h1 id="哈希集合法"><a href="#哈希集合法" class="headerlink" title="哈希集合法"></a>哈希集合法</h1><h2 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h2><p>使用哈希集合存储链表 <code>A</code> 的所有节点，然后遍历链表 <code>B</code> 的每个节点，判断该节点是否在集合中。第一个出现在集合中的节点就是相交节点。</p><p><strong>算法步骤</strong></p><ol><li>创建一个 <code>HashSet</code> 用于存储链表 <code>A</code> 的节点。</li><li>遍历链表 <code>A</code>，将每个节点添加到集合中。</li><li>遍历链表 <code>B</code>，对于每个节点：<ul><li>如果该节点存在于集合中，则返回该节点（相交节点）。</li><li>否则继续遍历下一个节点。</li></ul></li><li>如果遍历完链表 <code>B</code> 都没有找到相交节点，返回 <code>null</code>。</li></ol><p><strong>动态过程示例</strong></p><p>以链表 A：<code>1 → 2 → 3 → 4</code> 和链表 B：<code>5 → 3 → 4</code> 为例（相交节点为 3）：</p><ol><li>遍历 A，将节点 <code>1</code>、<code>2</code>、<code>3</code>、<code>4</code> 加入集合。</li><li>遍历 B：<ul><li>节点 5：不在集合中。</li><li>节点 3：在集合中 → 返回节点 3。</li></ul></li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line">    Set&lt;ListNode&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> headA;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">        set.add(cur);</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    cur = headB;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 这里用 HashSet 可以保证查询复杂度为 O(1)</span></span><br><span class="line">        <span class="keyword">if</span> (set.contains(cur)) &#123;</span><br><span class="line">            <span class="keyword">return</span> cur;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li><strong>时间复杂度：</strong><code>O(m + n)</code>，其中 <code>m</code> 和 <code>n</code> 分别是链表 <code>A</code> 和 <code>B</code> 的长度。需要遍历两个链表各一次。</li><li><strong>空间复杂度：</strong><code>O(m)</code>，存储链表 <code>A</code> 的节点集合。</li></ul><h1 id="双指针法（浪漫相遇法）"><a href="#双指针法（浪漫相遇法）" class="headerlink" title="双指针法（浪漫相遇法）"></a>双指针法（浪漫相遇法）</h1><h2 id="核心思路-1"><a href="#核心思路-1" class="headerlink" title="核心思路"></a>核心思路</h2><p>使用两个指针 <code>pA</code> 和 <code>pB</code> 分别遍历链表 <code>A</code> 和 <code>B</code>。当 <code>pA</code> 到达链表 <code>A</code> 末尾时，重定位到链表 <code>B</code> 的头节点；当 <code>pB</code> 到达链表 <code>B</code> 末尾时，重定位到链表 <code>A</code> 的头节点。若两链表相交，则 <code>pA</code> 和 <code>pB</code> 必在相交点相遇；若不相交，则最终会同时到达 <code>null</code>。</p><p><strong>算法步骤</strong></p><img src="/blog/2025/07/01/intersection-of-two-linked-lists/%E5%9B%BE%E8%A7%A3.png" class=""><p>考虑构建两个节点指针 <code>A</code>​ , <code>B</code> 分别指向两链表头节点 <code>headA</code> , <code>headB</code> ，首个公共节点为 <code>node</code>，做如下操作：</p><ul><li>指针 <code>A</code> 先遍历完链表 <code>headA</code> ，再开始遍历链表 <code>headB</code> ，当走到 <code>node</code> 时，共走步数为：<code>a + (b - c)</code></li><li>指针 <code>B</code> 先遍历完链表 <code>headB</code> ，再开始遍历链表 <code>headA</code> ，当走到 <code>node</code> 时，共走步数为：<code>b + (a - c)</code></li></ul><p>如下式所示，此时指针 <code>A</code> , <code>B</code> 重合，并有两种情况：<code>a + (b - c) = b + (a - c)</code></p><ul><li>若两链表 有 公共尾部 (即 <code>c &gt; 0</code> ) ：指针 <code>A</code> , <code>B</code> 同时指向「第一个公共节点」<code>node</code> 。</li><li>若两链表 无 公共尾部 (即 <code>c = 0</code> ) ：指针 <code>A</code> , <code>B</code> 同时指向 <code>null</code> 。</li></ul><h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (headA == <span class="literal">null</span> || headB == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pA</span> <span class="operator">=</span> headA;</span><br><span class="line">    <span class="type">ListNode</span> <span class="variable">pB</span> <span class="operator">=</span> headB;</span><br><span class="line">    <span class="keyword">while</span> (pA != pB) &#123;</span><br><span class="line">        pA = pA == <span class="literal">null</span> ? headB : pA.next;</span><br><span class="line">        pB = pB == <span class="literal">null</span> ? headA : pB.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li><strong>时间复杂度：</strong><code>O(m + n)</code>，最多遍历两链表各两次。</li><li><strong>空间复杂度：</strong><code>O(1)</code>，仅使用两个指针。</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><table><thead><tr><th>解法</th><th>时间复杂度</th><th>空间复杂度</th><th>适用场景</th></tr></thead><tbody><tr><td>哈希集合法</td><td>O(m + n)</td><td>O(m)</td><td>无空间限制时，代码简单</td></tr><tr><td>双指针法</td><td>O(m + n)</td><td>O(1)</td><td>要求常数空间，逻辑巧妙高效</td></tr></tbody></table><p>双指针法通过重定位指针创造等长路径，巧妙解决了链表长度差异问题，是空间优化的最佳方案。实际应用中，若内存允许可优先选择哈希法（代码更直观），若要求严格空间复杂度则必须使用双指针法。</p><h1 id="力扣的一些浪漫留言"><a href="#力扣的一些浪漫留言" class="headerlink" title="力扣的一些浪漫留言"></a>力扣的一些浪漫留言</h1><ul><li>当我在我的路上走过一遍依然没有遇见你时，那么我会接着来到你走过的路走一遍，如果我们心有灵犀，那么我们终将相遇。 - 局部降雨</li><li>我走过你走过的路，只为和你相拥。 - Flow</li><li>错的人就算走过了对方的路也还是会错过。 - 小虎</li><li>我住长江头，君住长江尾，日夜思君不见君，共饮一江水。君奔长江头，我赴长江尾，辗转轮回未谋面，邂逅时好美！ - 瓦罗兰的文艺复兴</li><li>世界上没有真正的感同身受直到你走过我走过的路。 - Cool PaninipeO</li></ul><h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><blockquote><p><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/description/" title="160. 相交链表 | 力扣（LeetCode）">160. 相交链表 | 力扣（LeetCode）</a><br><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/solutions/12624/intersection-of-two-linked-lists-shuang-zhi-zhen-l/" title="160. 相交链表 | 题解 | Krahets">160. 相交链表 | 题解 | Krahets</a><br><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/solutions/2958778/tu-jie-yi-zhang-tu-miao-dong-xiang-jiao-m6tg1/" title="160. 相交链表 | 题解 | 灵茶山艾府">160. 相交链表 | 题解 | 灵茶山艾府</a></p></blockquote><hr>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;给你两个单链表的头节点 &lt;code&gt;headA&lt;/code&gt; 和 &lt;code&gt;headB&lt;/code&gt; ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 &lt;code&gt;null&lt;/code&gt; 。题目数据保证整个链式结构中不存在环。&lt;/p&gt;
&lt;p&gt;图示两个链表在节点 &lt;code&gt;c1&lt;/code&gt; 开始相交：&lt;/p&gt;
&lt;img src=&quot;/blog/2025/07/01/intersection-of-two-linked-lists/160_statement.png&quot; class=&quot;&quot;&gt;

&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;函数返回结果后，链表必须保持其原始结构 。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;自定义评测：&lt;/strong&gt;&lt;br&gt;评测系统的输入如下（你设计的程序不适用此输入）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;intersectVal&lt;/code&gt; - 相交的起始节点的值。如果不存在相交节点，这一值为 &lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;listA&lt;/code&gt; - 第一个链表&lt;/li&gt;
&lt;li&gt;&lt;code&gt;listB&lt;/code&gt; - 第二个链表&lt;/li&gt;
&lt;li&gt;&lt;code&gt;skipA&lt;/code&gt; - 在 &lt;code&gt;listA&lt;/code&gt; 中（从头节点开始）跳到交叉节点的节点数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;skipB&lt;/code&gt; - 在 &lt;code&gt;listB&lt;/code&gt; 中（从头节点开始）跳到交叉节点的节点数&lt;/li&gt;
&lt;li&gt;评测系统将根据这些输入创建链式数据结构，并将两个头节点 &lt;code&gt;headA&lt;/code&gt; 和 &lt;code&gt;headB&lt;/code&gt; 传递给你的程序。如果程序能够正确返回相交节点，那么你的解决方案将被视作正确答案。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;img src=&quot;/blog/2025/07/01/intersection-of-two-linked-lists/160_example_1.png&quot; class=&quot;&quot;&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt;&lt;code&gt;intersectVal = 8&lt;/code&gt;, &lt;code&gt;listA = [4,1,8,4,5]&lt;/code&gt;, &lt;code&gt;listB = [5, 6, 1, 8, 4, 5]&lt;/code&gt;, &lt;code&gt;skipA = 2&lt;/code&gt;, &lt;code&gt;skipB = 3&lt;/code&gt;&lt;br&gt;&lt;strong&gt;输出：&lt;/strong&gt;&lt;code&gt;Intersected at &amp;#39;8&amp;#39;&lt;/code&gt;&lt;br&gt;&lt;strong&gt;解释：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;相交节点的值为 &lt;code&gt;8&lt;/code&gt; （注意，如果两个链表相交则不能为 &lt;code&gt;0&lt;/code&gt;）。&lt;/li&gt;
&lt;li&gt;从各自的表头开始算起，链表 &lt;code&gt;A&lt;/code&gt; 为 &lt;code&gt;[4, 1, 8, 4, 5]&lt;/code&gt;，链表 &lt;code&gt;B&lt;/code&gt; 为 &lt;code&gt;[5, 6, 1, 8, 4, 5]&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;在 &lt;code&gt;A&lt;/code&gt; 中，相交节点前有 2 个节点；在 &lt;code&gt;B&lt;/code&gt; 中，相交节点前有 3 个节点。&lt;/li&gt;
&lt;li&gt;请注意相交节点的值不为 1，因为在链表 &lt;code&gt;A&lt;/code&gt; 和链表 &lt;code&gt;B&lt;/code&gt; 之中值为 1 的节点 (&lt;code&gt;A&lt;/code&gt; 中第二个节点和 &lt;code&gt;B&lt;/code&gt; 中第三个节点) 是不同的节点。换句话说，它们在内存中指向两个不同的位置，而链表 &lt;code&gt;A&lt;/code&gt; 和链表 &lt;code&gt;B&lt;/code&gt; 中值为 8 的节点 (&lt;code&gt;A&lt;/code&gt; 中第三个节点，&lt;code&gt;B&lt;/code&gt; 中第四个节点) 在内存中指向相同的位置。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;/p&gt;
&lt;img src=&quot;/blog/2025/07/01/intersection-of-two-linked-lists/160_example_2.png&quot; class=&quot;&quot;&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt;&lt;code&gt;intersectVal = 2&lt;/code&gt;, &lt;code&gt;listA = [1, 9, 1, 2, 4]&lt;/code&gt;, &lt;code&gt;listB = [3, 2, 4]&lt;/code&gt;, &lt;code&gt;skipA = 3&lt;/code&gt;, &lt;code&gt;skipB = 1&lt;/code&gt;&lt;br&gt;&lt;strong&gt;输出：&lt;/strong&gt;&lt;code&gt;Intersected at &amp;#39;2&amp;#39;&lt;/code&gt;&lt;br&gt;&lt;strong&gt;解释：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。&lt;/li&gt;
&lt;li&gt;从各自的表头开始算起，链表 &lt;code&gt;A&lt;/code&gt; 为 &lt;code&gt;[1, 9, 1, 2, 4]&lt;/code&gt;，链表 &lt;code&gt;B&lt;/code&gt; 为 &lt;code&gt;[3, 2, 4]&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;在 &lt;code&gt;A&lt;/code&gt; 中，相交节点前有 3 个节点；在 &lt;code&gt;B&lt;/code&gt; 中，相交节点前有 1 个节点。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例 3:&lt;/strong&gt;&lt;/p&gt;
&lt;img src=&quot;/blog/2025/07/01/intersection-of-two-linked-lists/160_example_3.png&quot; class=&quot;&quot;&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt;&lt;code&gt;intersectVal = 0&lt;/code&gt;, &lt;code&gt;listA = [2, 6, 4]&lt;/code&gt;, &lt;code&gt;listB = [1, 5]&lt;/code&gt;, &lt;code&gt;skipA = 3&lt;/code&gt;, &lt;code&gt;skipB = 2&lt;/code&gt;&lt;br&gt;&lt;strong&gt;输出：&lt;/strong&gt;&lt;code&gt;No intersection&lt;/code&gt;&lt;br&gt;&lt;strong&gt;解释：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从各自的表头开始算起，链表 &lt;code&gt;A&lt;/code&gt; 为 &lt;code&gt;[2, 6, 4]&lt;/code&gt;，链表 &lt;code&gt;B&lt;/code&gt; 为 &lt;code&gt;[1, 5]&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;由于这两个链表不相交，所以 &lt;code&gt;intersectVal&lt;/code&gt; 必须为 0，而 &lt;code&gt;skipA&lt;/code&gt; 和 &lt;code&gt;skipB&lt;/code&gt; 可以是任意值。&lt;/li&gt;
&lt;li&gt;这两个链表不相交，因此返回 &lt;code&gt;null&lt;/code&gt; 。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;提示:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;listA&lt;/code&gt; 中节点数目为 &lt;code&gt;m&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;listB&lt;/code&gt; 中节点数目为 &lt;code&gt;n&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= m, n &amp;lt;= 3 * 10^4&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= Node.val &amp;lt;= 10^5&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0 &amp;lt;= skipA &amp;lt;= m&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;0 &amp;lt;= skipB &amp;lt;= n&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果 &lt;code&gt;listA&lt;/code&gt; 和 &lt;code&gt;listB&lt;/code&gt; 没有交点，&lt;code&gt;intersectVal&lt;/code&gt; 为 0&lt;/li&gt;
&lt;li&gt;如果 &lt;code&gt;listA&lt;/code&gt; 和 &lt;code&gt;listB&lt;/code&gt; 有交点，&lt;code&gt;intersectVal == listA[skipA] == listB[skipB]&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://www.cylong.com/categories/LeetCode/"/>
    
    
    <category term="Java" scheme="https://www.cylong.com/tags/Java/"/>
    
    <category term="LeetCode" scheme="https://www.cylong.com/tags/LeetCode/"/>
    
    <category term="学习笔记" scheme="https://www.cylong.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="链表" scheme="https://www.cylong.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
    <category term="哈希表" scheme="https://www.cylong.com/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
    <category term="双指针" scheme="https://www.cylong.com/tags/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    
    <category term="LeetCode简单" scheme="https://www.cylong.com/tags/LeetCode%E7%AE%80%E5%8D%95/"/>
    
  </entry>
  
  <entry>
    <title>矩阵原地旋转：分层遍历与坐标映射实现（LeetCode 48）</title>
    <link href="https://www.cylong.com/blog/2025/06/27/rotate-image/"/>
    <id>https://www.cylong.com/blog/2025/06/27/rotate-image/</id>
    <published>2025-06-27T12:42:48.000Z</published>
    <updated>2025-06-27T12:42:48.000Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个 <code>n × n</code> 的二维矩阵 <code>matrix</code> 表示一个图像。请你将图像顺时针旋转 90 度。你必须在 <strong>原地</strong> 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。</p><p><strong>原地算法：</strong>在计算机科学中，一个原地算法（in-place algorithm）是一种使用小的，固定数量的额外之空间来转换资料的算法。当算法执行时，输入的资料通常会被要输出的部分覆盖掉。不是原地算法有时候称为非原地（not-in-place）或不得其所（out-of-place）。</p><p><strong>示例 1:</strong></p><img src="/blog/2025/06/27/rotate-image/mat1.jpg" class=""><blockquote><p><strong>输入：</strong><code>matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]</code><br><strong>输出：</strong><code>[[7, 4, 1], [8, 5, 2], [9, 6, 3]]</code></p></blockquote><p><strong>示例 2:</strong></p><img src="/blog/2025/06/27/rotate-image/mat2.jpg" class=""><blockquote><p><strong>输入：</strong><code>matrix = [[5, 1, 9, 11], [2, 4, 8, 10], [13, 3, 6, 7], [15, 14, 12, 16]]</code><br><strong>输出：</strong><code>[[15, 13, 2, 5], [14, 3, 4, ], [12, 6, 8, 9], [16, 7, 10, 11]]</code></p></blockquote><p><strong>提示:</strong></p><ul><li><code>n == matrix.length == matrix[i].length</code></li><li><code>1 &lt;= n &lt;= 20</code></li><li><code>-1000 &lt;= matrix[i][j] &lt;= 1000</code></li></ul><span id="more"></span><h1 id="原地旋转法"><a href="#原地旋转法" class="headerlink" title="原地旋转法"></a>原地旋转法</h1><h2 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a>核心思路</h2><p>通过一次旋转四个元素实现原地旋转。对于每个位置 <code>(i, j)</code>，我们找到旋转后对应的三个位置，使用临时变量完成四个元素的交换。旋转过程如下：</p><ol><li>左上角元素 → 右上角</li><li>右上角元素 → 右下角</li><li>右下角元素 → 左下角</li><li>左下角元素 → 左上角</li></ol><p><strong>旋转公式推导</strong></p><p>设矩阵大小为 <code>n</code>，对于位置 <code>(i, j)</code>：</p><ol><li>左上角：<code>(i, j)</code></li><li>右上角：<code>(j, n-1-i)</code></li><li>右下角：<code>(n-1-i, n-1-j)</code></li><li>左下角：<code>(n-1-j, i)</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">temp = matrix[i][j]</span><br><span class="line">matrix[i][j] = matrix[n-<span class="number">1</span>-j][i]         <span class="comment">// 左下 → 左上</span></span><br><span class="line">matrix[n-<span class="number">1</span>-j][i] = matrix[n-<span class="number">1</span>-i][n-<span class="number">1</span>-j] <span class="comment">// 右下 → 左下</span></span><br><span class="line">matrix[n-<span class="number">1</span>-i][n-<span class="number">1</span>-j] = matrix[j][n-<span class="number">1</span>-i] <span class="comment">// 右上 → 右下</span></span><br><span class="line">matrix[j][n-<span class="number">1</span>-i] = temp                 <span class="comment">// 左上 → 右上</span></span><br></pre></td></tr></table></figure><p><strong>遍历范围优化</strong></p><ul><li>当 <code>n</code> 为偶数时：遍历左上角 <code>1/4</code> 区域</li><li>当 <code>n</code> 为奇数时：遍历左上角 <code>1/4 + 中心轴</code> 区域</li></ul><img src="/blog/2025/06/27/rotate-image/mat3.png" class=""><img src="/blog/2025/06/27/rotate-image/mat4.png" class=""><p><strong>图形化示例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">初始矩阵：</span><br><span class="line">[1, 2, 3]</span><br><span class="line">[4, 5, 6]</span><br><span class="line">[7, 8, 9]</span><br><span class="line"></span><br><span class="line">步骤1：旋转(0,0)元素</span><br><span class="line">  1 → 3的位置，3 → 9的位置，9 → 7的位置，7 → 1的位置</span><br><span class="line">得到：</span><br><span class="line">[7, 2, 1]</span><br><span class="line">[4, 5, 6]</span><br><span class="line">[9, 8, 3]</span><br><span class="line"></span><br><span class="line">步骤2：旋转(0,1)元素</span><br><span class="line">  2 → 6的位置，6 → 8的位置，8 → 4的位置，4 → 2的位置</span><br><span class="line">得到：</span><br><span class="line">[7, 4, 1]</span><br><span class="line">[8, 5, 2]</span><br><span class="line">[9, 6, 3]</span><br><span class="line"></span><br><span class="line">最终结果：</span><br><span class="line">[7, 4, 1]</span><br><span class="line">[8, 5, 2]</span><br><span class="line">[9, 6, 3]</span><br></pre></td></tr></table></figure><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rotate</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> matrix.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n / <span class="number">2</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; (n + <span class="number">1</span>) / <span class="number">2</span>; ++j) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> matrix[i][j];</span><br><span class="line">            matrix[i][j] = matrix[n - j - <span class="number">1</span>][i];</span><br><span class="line">            matrix[n - j - <span class="number">1</span>][i] = matrix[n - i - <span class="number">1</span>][n - j - <span class="number">1</span>];</span><br><span class="line">            matrix[n - i - <span class="number">1</span>][n - j - <span class="number">1</span>] = matrix[j][n - i - <span class="number">1</span>];</span><br><span class="line">            matrix[j][n - i - <span class="number">1</span>] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li><strong>时间复杂度：</strong><code>O(n²)</code>，其中 <code>n</code> 是 <code>matrix</code> 的边长。</li><li><strong>空间复杂度：</strong><code>O(1)</code>，为原地旋转。</li></ul><h1 id="翻转组合法"><a href="#翻转组合法" class="headerlink" title="翻转组合法"></a>翻转组合法</h1><h2 id="核心思路-1"><a href="#核心思路-1" class="headerlink" title="核心思路"></a>核心思路</h2><p>通过两次翻转操作实现旋转：</p><ol><li><strong>水平翻转</strong>（上下翻转）：<code>matrix[i][j] ↔ matrix[n-1-i][j]</code><ul><li>以水平中线为轴交换元素</li><li>行索引变换：<code>i → n-1-i</code></li><li>列索引不变</li></ul></li><li><strong>主对角线翻转</strong>（转置）：<code>matrix[i][j] ↔ matrix[j][i]</code><ul><li>沿主对角线（左上到右下）交换元素</li><li>行列索引互换：<code>(i, j) → (j, i)</code></li><li>只需遍历对角线一侧避免重复</li></ul></li></ol><p><strong>推导步骤</strong></p><ol><li>水平翻转后：<code>(i, j) → (n-1-i, j)</code></li><li>主对角线翻转后：<code>(n-1-i, j) → (j, n-1-i)</code></li><li>与顺时针旋转 90° 的坐标变换一致：<code>(i, j) → (j, n-1-i)</code></li></ol><p><strong>图形化示例</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">初始矩阵：</span><br><span class="line">[1, 2, 3]</span><br><span class="line">[4, 5, 6]</span><br><span class="line">[7, 8, 9]</span><br><span class="line"></span><br><span class="line">步骤1：水平翻转</span><br><span class="line">  交换行：第0行 ↔ 第2行</span><br><span class="line">得到：</span><br><span class="line">[7, 8, 9]</span><br><span class="line">[4, 5, 6]</span><br><span class="line">[1, 2, 3]</span><br><span class="line"></span><br><span class="line">步骤2：主对角线翻转</span><br><span class="line">  交换(1,0)和(0,1)：8 ↔ 4</span><br><span class="line">  交换(2,0)和(0,2)：9 ↔ 1 → 但实际顺序：先1和9交换，再2和6交换</span><br><span class="line">  详细过程：</span><br><span class="line">    [7, 8, 9]    [7, 4, 9]    [7, 4, 1]    [7, 4, 1]</span><br><span class="line">    [4, 5, 6] → [8, 5, 6] → [8, 5, 6] → [8, 5, 2]</span><br><span class="line">    [1, 2, 3]    [1, 2, 3]    [9, 2, 3]    [9, 6, 3]</span><br><span class="line"></span><br><span class="line">最终结果：</span><br><span class="line">[7, 4, 1]</span><br><span class="line">[8, 5, 2]</span><br><span class="line">[9, 6, 3]</span><br></pre></td></tr></table></figure><h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">rotate</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> matrix.length;</span><br><span class="line">    <span class="comment">// 水平翻转</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n / <span class="number">2</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> matrix[i][j];</span><br><span class="line">            matrix[i][j] = matrix[n - i - <span class="number">1</span>][j];</span><br><span class="line">            matrix[n - i - <span class="number">1</span>][j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 主对角线翻转</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> matrix[i][j];</span><br><span class="line">            matrix[i][j] = matrix[j][i];</span><br><span class="line">            matrix[j][i] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li><strong>时间复杂度：</strong><code>O(n²)</code>，其中 <code>n</code> 是 <code>matrix</code> 的边长。</li><li><strong>空间复杂度：</strong><code>O(1)</code>，为原地旋转。</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><table><thead><tr><th>解法</th><th>时间复杂度</th><th>空间复杂度</th><th>优势</th></tr></thead><tbody><tr><td>原地旋转法</td><td>O(n²)</td><td>O(1)</td><td>通过数学推导直接定位旋转位置，单次循环完成操作</td></tr><tr><td>翻转组合法</td><td>O(n²)</td><td>O(1)</td><td>利用基础操作组合实现旋转，逻辑清晰易理解</td></tr></tbody></table><p>两种方法都满足原地旋转的要求，在实际应用中可根据具体场景选择。翻转组合法更易于理解和扩展（如逆时针旋转只需调整翻转顺序），而原地旋转法在理论上减少了一半的交换操作。</p><h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><blockquote><p><a href="https://leetcode.cn/problems/rotate-image/description/" title="48. 旋转图像 | 力扣（LeetCode）">48. 旋转图像 | 力扣（LeetCode）</a></p></blockquote><hr>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;给定一个 &lt;code&gt;n × n&lt;/code&gt; 的二维矩阵 &lt;code&gt;matrix&lt;/code&gt; 表示一个图像。请你将图像顺时针旋转 90 度。你必须在 &lt;strong&gt;原地&lt;/strong&gt; 旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;原地算法：&lt;/strong&gt;在计算机科学中，一个原地算法（in-place algorithm）是一种使用小的，固定数量的额外之空间来转换资料的算法。当算法执行时，输入的资料通常会被要输出的部分覆盖掉。不是原地算法有时候称为非原地（not-in-place）或不得其所（out-of-place）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;img src=&quot;/blog/2025/06/27/rotate-image/mat1.jpg&quot; class=&quot;&quot;&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt;&lt;code&gt;matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]&lt;/code&gt;&lt;br&gt;&lt;strong&gt;输出：&lt;/strong&gt;&lt;code&gt;[[7, 4, 1], [8, 5, 2], [9, 6, 3]]&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;/p&gt;
&lt;img src=&quot;/blog/2025/06/27/rotate-image/mat2.jpg&quot; class=&quot;&quot;&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt;&lt;code&gt;matrix = [[5, 1, 9, 11], [2, 4, 8, 10], [13, 3, 6, 7], [15, 14, 12, 16]]&lt;/code&gt;&lt;br&gt;&lt;strong&gt;输出：&lt;/strong&gt;&lt;code&gt;[[15, 13, 2, 5], [14, 3, 4, ], [12, 6, 8, 9], [16, 7, 10, 11]]&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;提示:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;n == matrix.length == matrix[i].length&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= n &amp;lt;= 20&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-1000 &amp;lt;= matrix[i][j] &amp;lt;= 1000&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://www.cylong.com/categories/LeetCode/"/>
    
    
    <category term="Java" scheme="https://www.cylong.com/tags/Java/"/>
    
    <category term="LeetCode" scheme="https://www.cylong.com/tags/LeetCode/"/>
    
    <category term="学习笔记" scheme="https://www.cylong.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="数组" scheme="https://www.cylong.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="矩阵" scheme="https://www.cylong.com/tags/%E7%9F%A9%E9%98%B5/"/>
    
    <category term="LeetCode中等" scheme="https://www.cylong.com/tags/LeetCode%E4%B8%AD%E7%AD%89/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot 事件驱动编程：ApplicationEventPublisher 原理与实践指南</title>
    <link href="https://www.cylong.com/blog/2025/06/20/application-event-publisher/"/>
    <id>https://www.cylong.com/blog/2025/06/20/application-event-publisher/</id>
    <published>2025-06-20T15:47:57.000Z</published>
    <updated>2025-06-20T15:47:57.000Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h1><p><code>ApplicationEventPublisher</code> 是 Spring 框架的核心接口，用于发布应用事件，实现观察者模式。其核心作用包括：</p><ol><li><strong>事件发布：</strong>允许组件发布自定义事件</li><li><strong>松耦合：</strong>实现发布者与订阅者的解耦</li><li><strong>同步处理：</strong>默认同步执行（可通过 <code>@Async</code> 实现异步）</li><li><strong>继承机制：</strong>事件对象可继承扩展（支持 <code>ApplicationEvent</code> 或任意 <code>POJO</code>）</li></ol><p><strong>工作流程：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[发布者] → (发布事件) → [ApplicationContext] → (路由事件) → [监听器]</span><br></pre></td></tr></table></figure><h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><ol><li><strong>业务解耦：</strong>如用户注册后发送邮件/短信</li><li><strong>状态变更通知：</strong>订单状态变化时更新库存</li><li><strong>审计日志：</strong>关键操作后记录审计信息</li><li><strong>异步任务触发：</strong>耗时操作异步执行</li><li><strong>系统监控：</strong>关键事件触发监控上报</li></ol><span id="more"></span><h1 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h1><h2 id="添加-Maven-依赖"><a href="#添加-Maven-依赖" class="headerlink" title="添加 Maven 依赖"></a>添加 Maven 依赖</h2><p>由于 Spring Boot 已经内置了事件发布机制，我们只需要引入 <code>spring-boot-starter</code> 即可，它包含了 <code>spring-context</code>，其中就有 <code>ApplicationEventPublisher</code>。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>关于 Spring Boot 入门可以参考：<a href="/blog/2025/06/12/spring-boot/" title="Spring Boot 入门指南：从零开始创建 Web 应用">Spring Boot 入门指南：从零开始创建 Web 应用</a></p><h2 id="事件定义（POJO）"><a href="#事件定义（POJO）" class="headerlink" title="事件定义（POJO）"></a>事件定义（POJO）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.Getter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationEvent;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里用了 Lombok 注解，也可以参考上一篇文章</span></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserRegisterEvent</span> <span class="keyword">extends</span> <span class="title class_">ApplicationEvent</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String username;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserRegisterEvent</span><span class="params">(Object source, String username)</span> &#123;</span><br><span class="line">        <span class="comment">// source 通常是事件发布者</span></span><br><span class="line">        <span class="built_in">super</span>(source);</span><br><span class="line">        <span class="built_in">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="事件监听器"><a href="#事件监听器" class="headerlink" title="事件监听器"></a>事件监听器</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserRegisterListener</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听方式1：注解监听指定事件，此时 UserRegisterEvent 无需继承 ApplicationEvent</span></span><br><span class="line">    <span class="meta">@EventListener</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleEvent</span><span class="params">(UserRegisterEvent event)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;[注解监听] 新用户注册: &quot;</span> + event.getUsername());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 监听方式2：实现 ApplicationListener 接口，此时 UserRegisterEvent 需要继承 ApplicationEvent</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EmailListener</span> <span class="keyword">implements</span> <span class="title class_">ApplicationListener</span>&lt;UserRegisterEvent&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onApplicationEvent</span><span class="params">(UserRegisterEvent event)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;[接口监听] 发送欢迎邮件至: &quot;</span> + event.getUsername());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Spring 4.2 之前，自定义事件必须继承 <code>ApplicationEvent</code>。从 Spring 4.2 开始，事件可以是任意对象，不再强制要求继承 <code>ApplicationEvent</code>。因此，有两种解决方案：</p><ol><li>让 <code>UserRegisterEvent</code> 继承 <code>ApplicationEvent</code>（这样两种监听方式都支持）</li><li>将实现 <code>ApplicationListener</code> 接口的监听器改为使用 <code>@EventListener</code> 注解（推荐，因为更灵活）</li></ol><p>为了保持代码的简洁和现代 Spring 的使用方式，我们通常推荐使用 <code>@EventListener</code> 注解。这里为了演示两种方式，我们让事件类继承 <code>ApplicationEvent</code>，同时，在发布事件的时候，需要传递 <code>source</code>（通常就是发布者对象，但也可以为 <code>null</code>）</p><h2 id="事件发布服务"><a href="#事件发布服务" class="headerlink" title="事件发布服务"></a>事件发布服务</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 注入事件发布器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ApplicationEventPublisher publisher;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserService</span><span class="params">(ApplicationEventPublisher publisher)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.publisher = publisher;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerUser</span><span class="params">(String username)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;注册用户: &quot;</span> + username);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发布事件，需传递事件源（通常就是发布者对象 this，但也可以为 null）和业务数据</span></span><br><span class="line">        publisher.publishEvent(<span class="keyword">new</span> <span class="title class_">UserRegisterEvent</span>(<span class="built_in">this</span>, username));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;主流程完成&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="主应用类"><a href="#主应用类" class="headerlink" title="主应用类"></a>主应用类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApplicationEventPublisherDemoApplication</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">ConfigurableApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> SpringApplication.run(ApplicationEventPublisherDemoApplication.class, args);</span><br><span class="line"><span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> context.getBean(UserService.class);</span><br><span class="line">userService.registerUser(<span class="string">&quot;cylong&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h2><ol><li><strong>事件对象：</strong><code>UserRegisterEvent</code> 封装事件数据</li><li><strong>监听器：</strong><ul><li><strong>注解方式：</strong><code>@EventListener</code> 自动匹配事件类型（也就是根据类名匹配）</li><li><strong>接口方式：</strong>实现 <code>ApplicationListener</code> 接口</li></ul></li><li><strong>发布器：</strong><ul><li><code>ApplicationEventPublisher.publishEvent()</code> 触发事件</li><li>Spring 自动注入发布器实例</li></ul></li><li><strong>执行流程：</strong><ul><li>主应用调用 <code>registerUser()</code></li><li>服务内部发布事件</li><li>所有监听器同步执行</li></ul></li></ol><h2 id="运行输出"><a href="#运行输出" class="headerlink" title="运行输出"></a>运行输出</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">注册用户: cylong</span><br><span class="line">[接口监听] 发送欢迎邮件至: cylong</span><br><span class="line">[注解监听] 新用户注册: cylong</span><br><span class="line">主流程完成</span><br></pre></td></tr></table></figure><h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><p>下面将展示三种异常处理方式（局部捕获、全局处理和异步处理）的实现</p><h2 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationEvent;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 自定义事件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderEvent</span> <span class="keyword">extends</span> <span class="title class_">ApplicationEvent</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String orderId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">OrderEvent</span><span class="params">(Object source, String orderId)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(source);</span><br><span class="line">        <span class="built_in">this</span>.orderId = orderId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getOrderId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> orderId;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.event.EventListener;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.Async;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderEventListeners</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.1 局部异常捕获 - 库存服务</span></span><br><span class="line">    <span class="meta">@EventListener</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleInventory</span><span class="params">(OrderEvent event)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;\n[库存服务] 处理订单: &quot;</span> + event.getOrderId());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;error_stock&quot;</span>.equals(event.getOrderId())) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;库存不足，商品A缺货&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;   &gt; 库存锁定成功&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;   ! [库存异常] &quot;</span> + e.getMessage());</span><br><span class="line">            System.out.println(<span class="string">&quot;   &gt; 执行本地补偿: 释放预留资源&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.2 局部异常捕获 - 支付服务</span></span><br><span class="line">    <span class="meta">@EventListener</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handlePayment</span><span class="params">(OrderEvent event)</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;\n[支付服务] 处理订单: &quot;</span> + event.getOrderId());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;error_payment&quot;</span>.equals(event.getOrderId())) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;支付失败，信用卡余额不足&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;   &gt; 支付处理成功&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;   ! [支付异常] &quot;</span> + e.getMessage());</span><br><span class="line">            System.out.println(<span class="string">&quot;   &gt; 执行本地补偿: 取消支付预授权&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 用于演示全局异常处理的监听器（不捕获异常）</span></span><br><span class="line">    <span class="meta">@EventListener</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleNotification</span><span class="params">(OrderEvent event)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;\n[通知服务] 处理订单: &quot;</span> + event.getOrderId());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;error_stock&quot;</span>.equals(event.getOrderId())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;通知服务失败: 短信配额不足&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;   &gt; 已发送订单确认通知&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 异步异常处理</span></span><br><span class="line">    <span class="meta">@Async</span></span><br><span class="line">    <span class="meta">@EventListener</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleAsyncTask</span><span class="params">(OrderEvent event)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;\n[异步服务] 开始处理: &quot;</span> + event.getOrderId());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;async_error&quot;</span>.equals(event.getOrderId())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;异步任务处理失败: 外部API超时&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;   &gt; 异步任务完成&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.util.ErrorHandler;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 同步事件全局异常处理器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SyncEventErrorHandler</span> <span class="keyword">implements</span> <span class="title class_">ErrorHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleError</span><span class="params">(Throwable t)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;\n[全局同步异常处理器] 捕获异常: &quot;</span> + t.getMessage());</span><br><span class="line">        System.out.println(<span class="string">&quot;   &gt; 执行全局处理: 记录错误日志并告警&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.aop.interceptor.AsyncUncaughtExceptionHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6. 异步事件全局异常处理器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AsyncEventErrorHandler</span> <span class="keyword">implements</span> <span class="title class_">AsyncUncaughtExceptionHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleUncaughtException</span><span class="params">(Throwable ex, Method method, Object... params)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;\n[全局异步异常处理器] 捕获异常: &quot;</span> + ex.getMessage());</span><br><span class="line">        System.out.println(<span class="string">&quot;   &gt; 方法: &quot;</span> + method.getName());</span><br><span class="line">        System.out.println(<span class="string">&quot;   &gt; 参数类型: &quot;</span> + params[<span class="number">0</span>].getClass().getSimpleName());</span><br><span class="line">        System.out.println(<span class="string">&quot;   &gt; 执行补偿操作: 记录日志并通知管理员&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationEventPublisher;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationEventPublisher eventPublisher;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">placeOrder</span><span class="params">(String orderId)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;\n[主流程] 开始处理订单: &quot;</span> + orderId);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 模拟核心业务逻辑</span></span><br><span class="line">            System.out.println(<span class="string">&quot;   &gt; 创建订单记录&quot;</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 发布订单事件</span></span><br><span class="line">            eventPublisher.publishEvent(<span class="keyword">new</span> <span class="title class_">OrderEvent</span>(<span class="built_in">this</span>, orderId));</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;[主流程] 订单处理完成: &quot;</span> + orderId);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;[主流程异常] &quot;</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.aop.interceptor.AsyncUncaughtExceptionHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.event.ApplicationEventMulticaster;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.event.SimpleApplicationEventMulticaster;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.task.SimpleAsyncTaskExecutor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.AsyncConfigurer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.EnableAsync;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableAsync</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EventConfig</span> <span class="keyword">implements</span> <span class="title class_">AsyncConfigurer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置异步事件广播器</span></span><br><span class="line">    <span class="meta">@Bean(name = &quot;applicationEventMulticaster&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> ApplicationEventMulticaster <span class="title function_">applicationEventMulticaster</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">SimpleApplicationEventMulticaster</span> <span class="variable">eventMulticaster</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleApplicationEventMulticaster</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置同步事件的异常处理器</span></span><br><span class="line">        eventMulticaster.setErrorHandler(<span class="keyword">new</span> <span class="title class_">SyncEventErrorHandler</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置异步执行器</span></span><br><span class="line">        eventMulticaster.setTaskExecutor(<span class="keyword">new</span> <span class="title class_">SimpleAsyncTaskExecutor</span>());</span><br><span class="line">        <span class="keyword">return</span> eventMulticaster;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 异步异常处理配置</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> AsyncUncaughtExceptionHandler <span class="title function_">getAsyncUncaughtExceptionHandler</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">AsyncEventErrorHandler</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cylong.applicationeventpublisherdemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.CommandLineRunner;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.annotation.EnableAsync;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableAsync</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EventExceptionDemoApplication</span> <span class="keyword">implements</span> <span class="title class_">CommandLineRunner</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(EventExceptionDemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OrderService orderService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(String... args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;\n===== 测试正常订单 =====&quot;</span>);</span><br><span class="line">        orderService.placeOrder(<span class="string">&quot;order_2023001&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">500</span>); <span class="comment">// 等待异步任务完成</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;\n===== 测试库存不足订单 =====&quot;</span>);</span><br><span class="line">        orderService.placeOrder(<span class="string">&quot;error_stock&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;\n===== 测试支付失败订单 =====&quot;</span>);</span><br><span class="line">        orderService.placeOrder(<span class="string">&quot;error_payment&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;\n===== 测试异步异常订单 =====&quot;</span>);</span><br><span class="line">        orderService.placeOrder(<span class="string">&quot;async_error&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>); <span class="comment">// 确保异步任务完成</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="输出结果"><a href="#输出结果" class="headerlink" title="输出结果"></a>输出结果</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">===== 测试正常订单 =====</span><br><span class="line"></span><br><span class="line">[主流程] 开始处理订单: order_2023001</span><br><span class="line">   &gt; 创建订单记录</span><br><span class="line">[主流程] 订单处理完成: order_2023001</span><br><span class="line"></span><br><span class="line">[库存服务] 处理订单: order_2023001</span><br><span class="line"></span><br><span class="line">[支付服务] 处理订单: order_2023001</span><br><span class="line"></span><br><span class="line">[通知服务] 处理订单: order_2023001</span><br><span class="line">   &gt; 已发送订单确认通知</span><br><span class="line">   &gt; 库存锁定成功</span><br><span class="line">   &gt; 支付处理成功</span><br><span class="line"></span><br><span class="line">[异步服务] 开始处理: order_2023001</span><br><span class="line">   &gt; 异步任务完成</span><br><span class="line"></span><br><span class="line">===== 测试库存不足订单 =====</span><br><span class="line"></span><br><span class="line">[主流程] 开始处理订单: error_stock</span><br><span class="line">   &gt; 创建订单记录</span><br><span class="line"></span><br><span class="line">[库存服务] 处理订单: error_stock</span><br><span class="line"></span><br><span class="line">[支付服务] 处理订单: error_stock</span><br><span class="line">   &gt; 支付处理成功</span><br><span class="line">   ! [库存异常] 库存不足，商品A缺货</span><br><span class="line">   &gt; 执行本地补偿: 释放预留资源</span><br><span class="line">[主流程] 订单处理完成: error_stock</span><br><span class="line"></span><br><span class="line">[通知服务] 处理订单: error_stock</span><br><span class="line"></span><br><span class="line">[异步服务] 开始处理: error_stock</span><br><span class="line"></span><br><span class="line">[全局同步异常处理器] 捕获异常: 通知服务失败: 短信配额不足</span><br><span class="line">   &gt; 执行全局处理: 记录错误日志并告警</span><br><span class="line">   &gt; 异步任务完成</span><br><span class="line"></span><br><span class="line">===== 测试支付失败订单 =====</span><br><span class="line"></span><br><span class="line">[主流程] 开始处理订单: error_payment</span><br><span class="line">   &gt; 创建订单记录</span><br><span class="line"></span><br><span class="line">[库存服务] 处理订单: error_payment</span><br><span class="line">   &gt; 库存锁定成功</span><br><span class="line"></span><br><span class="line">[支付服务] 处理订单: error_payment</span><br><span class="line">[主流程] 订单处理完成: error_payment</span><br><span class="line">   ! [支付异常] 支付失败，信用卡余额不足</span><br><span class="line">   &gt; 执行本地补偿: 取消支付预授权</span><br><span class="line"></span><br><span class="line">[通知服务] 处理订单: error_payment</span><br><span class="line">   &gt; 已发送订单确认通知</span><br><span class="line"></span><br><span class="line">[异步服务] 开始处理: error_payment</span><br><span class="line">   &gt; 异步任务完成</span><br><span class="line"></span><br><span class="line">===== 测试异步异常订单 =====</span><br><span class="line"></span><br><span class="line">[主流程] 开始处理订单: async_error</span><br><span class="line">   &gt; 创建订单记录</span><br><span class="line"></span><br><span class="line">[库存服务] 处理订单: async_error</span><br><span class="line">   &gt; 库存锁定成功</span><br><span class="line"></span><br><span class="line">[支付服务] 处理订单: async_error</span><br><span class="line">   &gt; 支付处理成功</span><br><span class="line">[主流程] 订单处理完成: async_error</span><br><span class="line"></span><br><span class="line">[通知服务] 处理订单: async_error</span><br><span class="line">   &gt; 已发送订单确认通知</span><br><span class="line"></span><br><span class="line">[异步服务] 开始处理: async_error</span><br><span class="line"></span><br><span class="line">[全局异步异常处理器] 捕获异常: 异步任务处理失败: 外部API超时</span><br><span class="line">   &gt; 方法: handleAsyncTask</span><br><span class="line">   &gt; 参数类型: OrderEvent</span><br><span class="line">   &gt; 执行补偿操作: 记录日志并通知管理员</span><br></pre></td></tr></table></figure><h2 id="异常处理机制解析"><a href="#异常处理机制解析" class="headerlink" title="异常处理机制解析"></a>异常处理机制解析</h2><ol><li><strong>局部异常捕获：</strong><ul><li>在监听器内部使用 <code>try-catch</code> 块</li><li>示例：库存和支付服务的监听器</li><li>特点：异常不会传播，不影响其他监听器</li><li>适用场景：需要独立处理的业务异常</li></ul></li><li><strong>全局同步异常处理：</strong><ul><li>实现 <code>ErrorHandler</code> 接口</li><li>通过 <code>SimpleApplicationEventMulticaster.setErrorHandler()</code> 注册</li><li>捕获所有未处理的同步事件异常</li><li>示例：<code>SyncEventErrorHandler</code></li><li>特点：集中处理未被捕获的同步异常</li></ul></li><li><strong>全局异步异常处理：</strong><ul><li>实现 <code>AsyncUncaughtExceptionHandler</code> 接口</li><li>通过 <code>AsyncConfigurer</code> 配置</li><li>捕获所有未处理的异步事件异常</li><li>示例：<code>AsyncEventErrorHandler</code></li><li>特点：专用于异步执行场景</li></ul></li></ol><h2 id="三种处理方式适用场景"><a href="#三种处理方式适用场景" class="headerlink" title="三种处理方式适用场景"></a>三种处理方式适用场景</h2><table><thead><tr><th>处理方式</th><th>适用场景</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>局部捕获</td><td>需要独立处理的业务异常</td><td>精确控制，不影响其他监听器</td><td>代码重复可能性高</td></tr><tr><td>全局同步处理</td><td>未捕获的同步异常统一处理</td><td>集中管理，避免异常传播</td><td>无法获取完整上下文</td></tr><tr><td>全局异步处理</td><td>所有未捕获的异步异常</td><td>统一处理异步任务失败</td><td>无法访问原始方法参数</td></tr></tbody></table><h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><h2 id="作用域限制"><a href="#作用域限制" class="headerlink" title="作用域限制"></a>作用域限制</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 监听器需是 Spring 管理的 Bean</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserRegisterListener</span> &#123;...&#125;</span><br></pre></td></tr></table></figure><h2 id="事件源（source）的作用"><a href="#事件源（source）的作用" class="headerlink" title="事件源（source）的作用"></a>事件源（source）的作用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可获取事件发布者信息</span></span><br><span class="line"><span class="keyword">if</span> (event.getSource() <span class="keyword">instanceof</span> UserService) &#123;</span><br><span class="line">    <span class="comment">// 特殊处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="监听器执行顺序"><a href="#监听器执行顺序" class="headerlink" title="监听器执行顺序"></a>监听器执行顺序</h2><p>监听器按注册顺序执行（可通过 <code>@Order</code> 调整）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Order(1)</span>  <span class="comment">// 数字越小优先级越高</span></span><br><span class="line"><span class="meta">@EventListener</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">firstListener</span><span class="params">(UserRegisterEvent event)</span> &#123;...&#125;</span><br></pre></td></tr></table></figure><h2 id="异步处理"><a href="#异步处理" class="headerlink" title="异步处理"></a>异步处理</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Async</span>  <span class="comment">// 启用异步</span></span><br><span class="line"><span class="meta">@EventListener</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">asyncHandle</span><span class="params">(UserRegisterEvent event)</span> &#123;</span><br><span class="line">    <span class="comment">// 耗时操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需在配置类添加 <code>@EnableAsync</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableAsync</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ApplicationEventPublisherDemoApplication</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">ConfigurableApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> SpringApplication.run(ApplicationEventPublisherDemoApplication.class, args);</span><br><span class="line"><span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> context.getBean(UserService.class);</span><br><span class="line">userService.registerUser(<span class="string">&quot;cylong&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="事件继承"><a href="#事件继承" class="headerlink" title="事件继承"></a>事件继承</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 监听父类事件会同时接收子类事件</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">VIPRegisterEvent</span> <span class="keyword">extends</span> <span class="title class_">UserRegisterEvent</span> &#123;...&#125;</span><br></pre></td></tr></table></figure><ol><li>监听 <code>UserRegisterEvent</code> 会接收到所有子类事件</li><li>使用 <code>@EventListener(classes = VIPRegisterEvent.class)</code> 限定具体类型</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EventListener(classes = VIPRegisterEvent.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">handleEvent</span><span class="params">(UserRegisterEvent event)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;[注解监听] 新 VIP 用户注册: &quot;</span> + event.getUsername());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="性能建议"><a href="#性能建议" class="headerlink" title="性能建议"></a>性能建议</h2><ol><li>避免在监听器执行耗时操作（默认同步，可以切换为异步）</li><li>单个事件避免注册过多监听器</li></ol><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><ol><li>监听器异常会传播到发布者</li><li>需要时添加单独异常处理</li></ol><p>通过 <code>ApplicationEventPublisher</code> 可实现优雅的业务解耦，但需根据场景权衡同步/异步机制。在实际项目中，建议将核心业务与辅助操作（邮件、日志等）通过事件分离，提升系统可维护性。</p><hr>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;基本介绍&quot;&gt;&lt;a href=&quot;#基本介绍&quot; class=&quot;headerlink&quot; title=&quot;基本介绍&quot;&gt;&lt;/a&gt;基本介绍&lt;/h1&gt;&lt;p&gt;&lt;code&gt;ApplicationEventPublisher&lt;/code&gt; 是 Spring 框架的核心接口，用于发布应用事件，实现观察者模式。其核心作用包括：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;事件发布：&lt;/strong&gt;允许组件发布自定义事件&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;松耦合：&lt;/strong&gt;实现发布者与订阅者的解耦&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;同步处理：&lt;/strong&gt;默认同步执行（可通过 &lt;code&gt;@Async&lt;/code&gt; 实现异步）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;继承机制：&lt;/strong&gt;事件对象可继承扩展（支持 &lt;code&gt;ApplicationEvent&lt;/code&gt; 或任意 &lt;code&gt;POJO&lt;/code&gt;）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;工作流程：&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[发布者] → (发布事件) → [ApplicationContext] → (路由事件) → [监听器]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h1 id=&quot;应用场景&quot;&gt;&lt;a href=&quot;#应用场景&quot; class=&quot;headerlink&quot; title=&quot;应用场景&quot;&gt;&lt;/a&gt;应用场景&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;业务解耦：&lt;/strong&gt;如用户注册后发送邮件/短信&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;状态变更通知：&lt;/strong&gt;订单状态变化时更新库存&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;审计日志：&lt;/strong&gt;关键操作后记录审计信息&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;异步任务触发：&lt;/strong&gt;耗时操作异步执行&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;系统监控：&lt;/strong&gt;关键事件触发监控上报&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="Java" scheme="https://www.cylong.com/categories/Java/"/>
    
    
    <category term="Java" scheme="https://www.cylong.com/tags/Java/"/>
    
    <category term="Spring" scheme="https://www.cylong.com/tags/Spring/"/>
    
    <category term="SpringBoot" scheme="https://www.cylong.com/tags/SpringBoot/"/>
    
    <category term="后端框架" scheme="https://www.cylong.com/tags/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6/"/>
    
    <category term="事件驱动" scheme="https://www.cylong.com/tags/%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8/"/>
    
    <category term="ApplicationEventPublisher" scheme="https://www.cylong.com/tags/ApplicationEventPublisher/"/>
    
    <category term="观察者模式" scheme="https://www.cylong.com/tags/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>矩阵置零的原地算法：首行列标记与空间优化（LeetCode 73）</title>
    <link href="https://www.cylong.com/blog/2025/06/13/set-matrix-zeroes/"/>
    <id>https://www.cylong.com/blog/2025/06/13/set-matrix-zeroes/</id>
    <published>2025-06-12T16:18:52.000Z</published>
    <updated>2025-06-12T16:18:52.000Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给定一个 <code>m x n</code> 的矩阵，如果一个元素为 <code>0</code> ，则将其所在行和列的所有元素都设为 <code>0</code> 。请使用 <strong>原地算法</strong>。</p><p><strong>原地算法：</strong>在计算机科学中，一个原地算法（in-place algorithm）是一种使用小的，固定数量的额外之空间来转换资料的算法。当算法执行时，输入的资料通常会被要输出的部分覆盖掉。不是原地算法有时候称为非原地（not-in-place）或不得其所（out-of-place）。</p><p><strong>示例 1:</strong></p><img src="/blog/2025/06/13/set-matrix-zeroes/mat1.jpg" class=""><blockquote><p><strong>输入：</strong><code>matrix = [[1, 1, 1], [1, 0, 1], [1, 1, 1]]</code><br><strong>输出：</strong><code>[[1, 0, 1], [0, 0, 0], [1, 0, 1]]</code></p></blockquote><p><strong>示例 2:</strong></p><img src="/blog/2025/06/13/set-matrix-zeroes/mat2.jpg" class=""><blockquote><p><strong>输入：</strong><code>matrix = [[0, 1, 2, 0], [3, 4, 5, 2], [1, 3, 1, 5]]</code><br><strong>输出：</strong><code>[[0, 0, 0, 0], [0, 4, 5, 0], [0, 3, 1, 0]]</code></p></blockquote><p><strong>提示:</strong></p><ul><li><code>m == matrix.length</code></li><li><code>n == matrix[0].length</code></li><li><code>1 &lt;= m, n &lt;= 200</code></li><li><code>-2^31 &lt;= matrix[i][j] &lt;= 2^31 - 1</code></li></ul><span id="more"></span><h1 id="辅助数组法"><a href="#辅助数组法" class="headerlink" title="辅助数组法"></a>辅助数组法</h1><p>使用两个辅助数组分别记录需要置零的行和列。首先遍历矩阵，当遇到元素为 <code>0</code> 时，将对应的行标记和列标记设置为 <code>true</code>。然后再次遍历矩阵，根据行标记和列标记将相应元素置为 <code>0</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setZeroes</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">    <span class="comment">// 获取矩阵的行数和列数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">rowLen</span> <span class="operator">=</span> matrix.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">colLen</span> <span class="operator">=</span> matrix[<span class="number">0</span>].length;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建两个布尔数组，分别用于标记需要置零的行和列</span></span><br><span class="line">    <span class="type">boolean</span>[] row = <span class="keyword">new</span> <span class="title class_">boolean</span>[rowLen];</span><br><span class="line">    <span class="type">boolean</span>[] col = <span class="keyword">new</span> <span class="title class_">boolean</span>[colLen];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 第一次遍历：标记包含 0 的行和列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; rowLen; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; colLen; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                row[i] = <span class="literal">true</span>; <span class="comment">// 标记第 i 行需要置零</span></span><br><span class="line">                col[j] = <span class="literal">true</span>; <span class="comment">// 标记第 j 列需要置零</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 第二次遍历：根据标记数组将相应行和列的元素置零</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; rowLen; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; colLen; j++) &#123;</span><br><span class="line">            <span class="comment">// 如果当前行或列被标记，则将元素置为 0</span></span><br><span class="line">            <span class="keyword">if</span> (row[i] || col[j]) &#123;</span><br><span class="line">                matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li><strong>时间复杂度：</strong><code>O(m × n)</code>，其中 <code>m</code> 和 <code>n</code> 分别是矩阵的行数和列数。我们遍历了两次矩阵。</li><li><strong>空间复杂度：</strong><code>O(m + n)</code>，使用了两个辅助数组分别存储行和列的标记。</li></ul><h1 id="原地标记法（优化空间）"><a href="#原地标记法（优化空间）" class="headerlink" title="原地标记法（优化空间）"></a>原地标记法（优化空间）</h1><p>使用矩阵的第一行和第一列作为标记数组，代替上面解法中的额外数组。首先检查第一行和第一列是否需要置零，然后用第一行记录各列是否需要置零，第一列记录各行是否需要置零。最后根据标记处理除第一行第一列外的元素，再单独处理第一行和第一列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setZeroes</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">rowLen</span> <span class="operator">=</span> matrix.length;</span><br><span class="line">    <span class="type">int</span> <span class="variable">colLen</span> <span class="operator">=</span> matrix[<span class="number">0</span>].length;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查第一列是否有 0</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">colHasZero</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; rowLen; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix[i][<span class="number">0</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">            colHasZero = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查第一行是否有 0</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">rowHasZero</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; colLen; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix[<span class="number">0</span>][j] == <span class="number">0</span>) &#123;</span><br><span class="line">            rowHasZero = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用第一行和第一列标记其他行列的 0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; rowLen; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; colLen; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 这里其实也是先把有零的第一行和第一列位置置零了</span></span><br><span class="line">                matrix[i][<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">// 标记第 i 行需要置零</span></span><br><span class="line">                matrix[<span class="number">0</span>][j] = <span class="number">0</span>; <span class="comment">// 标记第 j 列需要置零</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据标记设置除第一行和第一列外的元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; rowLen; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; colLen; j++) &#123;</span><br><span class="line">            <span class="comment">// 如果当前行或列被标记，则将元素置为 0</span></span><br><span class="line">            <span class="keyword">if</span> (matrix[i][<span class="number">0</span>] == <span class="number">0</span> || matrix[<span class="number">0</span>][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                matrix[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 处理第一列置零</span></span><br><span class="line">    <span class="keyword">if</span> (colHasZero) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; rowLen; i++) &#123;</span><br><span class="line">            matrix[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 处理第一行置零</span></span><br><span class="line">    <span class="keyword">if</span> (rowHasZero) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; colLen; j++) &#123;</span><br><span class="line">            matrix[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li><strong>时间复杂度：</strong><code>O(m × n)</code>，其中 <code>m</code> 和 <code>n</code> 分别是矩阵的行数和列数。我们遍历了多次矩阵，但时间复杂度仍是线性级别。</li><li><strong>空间复杂度：</strong><code>O(1)</code>，仅使用常数级别的额外空间。</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><table><thead><tr><th>解法</th><th>时间复杂度</th><th>空间复杂度</th><th>优势</th><th>劣势</th></tr></thead><tbody><tr><td>辅助数组法</td><td>O(m × n)</td><td>O(m + n)</td><td>思路清晰，实现简单，两次遍历矩阵即可完成</td><td>使用了额外的 O(m + n) 空间，不是原地算法</td></tr><tr><td>原地标记法</td><td>O(m × n)</td><td>O(1)</td><td>空间复杂度最优，仅使用常数空间，符合原地算法</td><td>实现逻辑相对复杂，需要多次遍历矩阵</td></tr></tbody></table><p>两种方法各有优劣，在实际应用中可根据具体场景选择最合适的解法。对于面试场景，掌握两种方法并能解释其优劣会更有优势。</p><h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><blockquote><p><a href="https://leetcode.cn/problems/set-matrix-zeroes/description/" title="73. 矩阵置零 | 力扣（LeetCode）">73. 矩阵置零 | 力扣（LeetCode）</a></p></blockquote><hr>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;给定一个 &lt;code&gt;m x n&lt;/code&gt; 的矩阵，如果一个元素为 &lt;code&gt;0&lt;/code&gt; ，则将其所在行和列的所有元素都设为 &lt;code&gt;0&lt;/code&gt; 。请使用 &lt;strong&gt;原地算法&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;原地算法：&lt;/strong&gt;在计算机科学中，一个原地算法（in-place algorithm）是一种使用小的，固定数量的额外之空间来转换资料的算法。当算法执行时，输入的资料通常会被要输出的部分覆盖掉。不是原地算法有时候称为非原地（not-in-place）或不得其所（out-of-place）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;img src=&quot;/blog/2025/06/13/set-matrix-zeroes/mat1.jpg&quot; class=&quot;&quot;&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt;&lt;code&gt;matrix = [[1, 1, 1], [1, 0, 1], [1, 1, 1]]&lt;/code&gt;&lt;br&gt;&lt;strong&gt;输出：&lt;/strong&gt;&lt;code&gt;[[1, 0, 1], [0, 0, 0], [1, 0, 1]]&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;/p&gt;
&lt;img src=&quot;/blog/2025/06/13/set-matrix-zeroes/mat2.jpg&quot; class=&quot;&quot;&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt;&lt;code&gt;matrix = [[0, 1, 2, 0], [3, 4, 5, 2], [1, 3, 1, 5]]&lt;/code&gt;&lt;br&gt;&lt;strong&gt;输出：&lt;/strong&gt;&lt;code&gt;[[0, 0, 0, 0], [0, 4, 5, 0], [0, 3, 1, 0]]&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;提示:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;m == matrix.length&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;n == matrix[0].length&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= m, n &amp;lt;= 200&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-2^31 &amp;lt;= matrix[i][j] &amp;lt;= 2^31 - 1&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://www.cylong.com/categories/LeetCode/"/>
    
    
    <category term="Java" scheme="https://www.cylong.com/tags/Java/"/>
    
    <category term="LeetCode" scheme="https://www.cylong.com/tags/LeetCode/"/>
    
    <category term="学习笔记" scheme="https://www.cylong.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="数组" scheme="https://www.cylong.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="矩阵" scheme="https://www.cylong.com/tags/%E7%9F%A9%E9%98%B5/"/>
    
    <category term="LeetCode中等" scheme="https://www.cylong.com/tags/LeetCode%E4%B8%AD%E7%AD%89/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot 入门指南：从零开始创建 Web 应用</title>
    <link href="https://www.cylong.com/blog/2025/06/12/spring-boot/"/>
    <id>https://www.cylong.com/blog/2025/06/12/spring-boot/</id>
    <published>2025-06-12T07:10:26.000Z</published>
    <updated>2025-06-12T07:10:26.000Z</updated>
    
    <content type="html"><![CDATA[<hr><blockquote><p>本文面向 Java 初学者，详细介绍 Spring Boot 框架原理、应用场景及从零搭建 Web 应用的完整流程。</p></blockquote><h1 id="Spring-Boot-框架简介"><a href="#Spring-Boot-框架简介" class="headerlink" title="Spring Boot 框架简介"></a>Spring Boot 框架简介</h1><h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>Spring Boot 是 Spring 框架的扩展，通过 <strong>约定优于配置</strong> 的理念解决传统 Spring 应用配置复杂的问题，简化 Spring 应用的初始搭建和开发过程。通过自动配置和起步依赖（Starter Dependencies）来减少开发者的配置工作，Spring Boot 内嵌了 Tomcat、Jetty 或 Undertow 等服务器，因此无需部署 WAR 文件即可运行。核心思想是 <strong>让开发更简单</strong> 。</p><h2 id="核心特性"><a href="#核心特性" class="headerlink" title="核心特性"></a>核心特性</h2><ol><li><strong>自动配置</strong>：通过 <code>@EnableAutoConfiguration</code> 自动配置 Bean（基于项目中的 jar 依赖自动配置 Spring 应用）</li><li><strong>起步依赖</strong>：通过提供预定义的依赖描述符（如 <code>spring-boot-starter-web</code> 包含了开发 Web 应用所需的依赖）简化构建配置，解决版本冲突。</li><li><strong>内嵌服务</strong>：内置 Tomcat/Jetty/Undertow 等服务器，无需部署 WAR，直接运行一个独立的应用即可。</li><li><strong>Actuator</strong>：提供生产级监控和管理功能，如监控应用的健康状况、信息查看等。</li></ol><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[启动类] → [@SpringBootApplication] </span><br><span class="line">    → 扫描 @Component → 加载 @Configuration </span><br><span class="line">    → 读取 spring.factories → 应用自动配置</span><br><span class="line">    → 启动内嵌容器</span><br></pre></td></tr></table></figure><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>Spring Boot 适用于构建微服务架构、RESTful API、企业级应用等。</p><span id="more"></span><h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><h2 id="软件版本"><a href="#软件版本" class="headerlink" title="软件版本"></a>软件版本</h2><ol><li><strong>开发工具</strong>：IntelliJ IDEA 2021+</li><li><strong>Java环境</strong>：JDK 1.8 或以上版本（建议使用 JDK 11 或 17）</li><li><strong>构建工具</strong>：Maven 3.6+（IDEA 一般自带，但需确保配置正确）</li></ol><h2 id="配置-Maven-的-settings-xml"><a href="#配置-Maven-的-settings-xml" class="headerlink" title="配置 Maven 的 settings.xml"></a>配置 Maven 的 settings.xml</h2><p>Maven的 <code>settings.xml</code>文件用于配置全局的 Maven 设置，如仓库镜像、代理等。通常位于Maven 安装目录的 <code>conf</code> 文件夹下，或者用户目录下的 <code>.m2</code> 文件夹（如 <code>~/.m2/settings.xml</code>），在 <code>IDEA → Settings</code> 中可以直接查看文件路径：</p><img src="/blog/2025/06/12/spring-boot/m2-settings-path.png" class=""><p>配置样例如下：</p><figure class="highlight xml"><figcaption><span>settings.xml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/SETTINGS/1.0.0&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/SETTINGS/1.0.0 </span></span></span><br><span class="line"><span class="string"><span class="tag">          http://maven.apache.org/xsd/settings-1.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 添加阿里云镜像加速 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mirrors</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mirror</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span>&gt;</span>aliyun<span class="tag">&lt;/<span class="name">id</span>&gt;</span> <span class="comment">&lt;!-- 镜像的唯一标识 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">name</span>&gt;</span>Aliyun Public Repository<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">url</span>&gt;</span>https://maven.aliyun.com/repository/public<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">mirrorOf</span>&gt;</span>*<span class="tag">&lt;/<span class="name">mirrorOf</span>&gt;</span> <span class="comment">&lt;!-- 匹配哪些仓库，`*` 表示所有仓库都使用该镜像 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">mirror</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mirrors</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="IDEA-配置"><a href="#IDEA-配置" class="headerlink" title="IDEA 配置"></a>IDEA 配置</h2><ol><li>配置 Maven 路径：<code>File → Settings → Build, Execution, Deployment → Build Tools → Maven</code></li><li>设置 JDK 版本：<code>File → Project Structure → SDKs</code></li></ol><h1 id="创建-Spring-Boot-项目"><a href="#创建-Spring-Boot-项目" class="headerlink" title="创建 Spring Boot 项目"></a>创建 Spring Boot 项目</h1><h2 id="项目初始化"><a href="#项目初始化" class="headerlink" title="项目初始化"></a>项目初始化</h2><p>在 IDEA 中创建 Spring Boot 项目有两种常用方式：</p><ol><li>通过 Spring Initializr 网站（<a href="https://start.spring.io/">https://start.spring.io/</a>）生成项目，然后导入 IDEA。<img src="/blog/2025/06/12/spring-boot/spring-initializr-web.png" class=""></li><li>打开 <code>IDEA → New → Project → Spring Boot</code>，配置项目信息<img src="/blog/2025/06/12/spring-boot/new-project.png" class=""></li><li>添加依赖<ul><li><strong>Spring Web</strong>：用于构建Web应用</li><li><strong>Lombok</strong>：非必须，主要用于简化代码<img src="/blog/2025/06/12/spring-boot/dependencies.png" class=""></li></ul></li></ol><h2 id="项目结构解析"><a href="#项目结构解析" class="headerlink" title="项目结构解析"></a>项目结构解析</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SpringBootDemo</span><br><span class="line">├── src/main/java</span><br><span class="line">│   └── com/cylong/springbootdemo</span><br><span class="line">│       ├── SpringBootDemoApplication.java  # 主启动类</span><br><span class="line">│       └── controller</span><br><span class="line">│           ├── HelloController.java # 控制器</span><br><span class="line">│           └── Student.java         # 这里主要用于展示 Lombok 简化代码作用</span><br><span class="line">├── src/main/resources</span><br><span class="line">│   ├── application.properties # 配置文件</span><br><span class="line">│   ├── static                 # 静态资源（HTML, CSS, JS）</span><br><span class="line">│   └── templates              # 模板文件（Thymeleaf）</span><br><span class="line">├── src/test                   # 测试代码</span><br><span class="line">└── pom.xml                    # Maven 配置</span><br></pre></td></tr></table></figure><h1 id="核心配置文件详解"><a href="#核心配置文件详解" class="headerlink" title="核心配置文件详解"></a>核心配置文件详解</h1><h2 id="pom-xml-解析"><a href="#pom-xml-解析" class="headerlink" title="pom.xml 解析"></a>pom.xml 解析</h2><figure class="highlight xml"><figcaption><span>pom.xml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 继承 Spring Boot 默认配置，它提供了依赖管理，这样我们在添加其他 Spring Boot 依赖时就不需要指定版本号了 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 通常填写公司或者个人域名的倒序，例如：com.example --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.cylong<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 项目名称 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>SpringBootDemo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>SpringBootDemo<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>SpringBootDemo<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>24<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- Web 开发核心依赖，（如 Spring MVC，内嵌 Tomcat 等） --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 测试依赖 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- Lombok 依赖--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 打包插件（生成可执行 Jar） --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">annotationProcessorPaths</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">path</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">annotationProcessorPaths</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">excludes</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">exclude</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">exclude</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">excludes</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="application-properties-解析"><a href="#application-properties-解析" class="headerlink" title="application.properties 解析"></a>application.properties 解析</h2><figure class="highlight yml"><figcaption><span>application.properties</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 应用名称</span></span><br><span class="line"><span class="string">spring.application.name=SpringBootDemo</span></span><br><span class="line"><span class="comment"># 修改端口 默认8080</span></span><br><span class="line"><span class="string">server.port=9090</span></span><br><span class="line"><span class="comment"># 配置上下文，URL变为：http://localhost:9090/demo/hello</span></span><br><span class="line"><span class="comment"># 如果不配置，默认是：http://localhost:9090/hello</span></span><br><span class="line"><span class="string">server.servlet.context-path=/demo</span></span><br><span class="line"><span class="comment"># 自定义属性</span></span><br><span class="line"><span class="string">welcome.message=Hello</span> <span class="string">Spring</span> <span class="string">Boot</span></span><br></pre></td></tr></table></figure><h1 id="编写第一个-Web-接口"><a href="#编写第一个-Web-接口" class="headerlink" title="编写第一个 Web 接口"></a>编写第一个 Web 接口</h1><h2 id="创建控制器"><a href="#创建控制器" class="headerlink" title="创建控制器"></a>创建控制器</h2><figure class="highlight java"><figcaption><span>HelloController.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cylong.springbootdemo.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 表明这是一个控制器，并且返回的数据直接写入响应体（如 JSON 或字符串）</span></span><br><span class="line"><span class="meta">@RestController</span> <span class="comment">// = @Controller + @ResponseBody</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// application.properties 中自定义属性</span></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;welcome.message&#125;&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> String welcomeMsg;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 映射 GET 请求到 /hello 路径</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/hello&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">sayHello</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        student.setNo(<span class="string">&quot;1000&quot;</span>);</span><br><span class="line">        student.setName(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> welcomeMsg + <span class="string">&quot; &quot;</span> + student.getName() + <span class="string">&quot; 访问成功！&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><figcaption><span>Student.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cylong.springbootdemo.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 学号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String no;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 姓名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里 <code>@Data</code> 是 Lombok 提供的一个组合注解，它主要用于简化 Java Bean 的编写。当你在类上使用 <code>@Data</code> 注解时，Lombok 会在编译时自动为类生成以下方法：</p><ol><li>所有字段的 <code>getter</code> 方法（对于非 <code>static</code> 字段）</li><li>所有非 <code>final</code> 字段的 <code>setter</code> 方法</li><li><code>equals()</code> 方法</li><li><code>hashCode()</code> 方法</li><li><code>toString()</code> 方法</li></ol><h2 id="创建启动类"><a href="#创建启动类" class="headerlink" title="创建启动类"></a>创建启动类</h2><figure class="highlight java"><figcaption><span>SpringBootDemoApplication.java</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.cylong.springbootdemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 核心注解：启用自动配置和组件扫描</span></span><br><span class="line"><span class="comment">// 组合了 @Configuration + @EnableAutoConfiguration + @ComponentScan</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringBootDemoApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 启动 Spring 应用</span></span><br><span class="line">        SpringApplication.run(SpringBootDemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="运行与测试"><a href="#运行与测试" class="headerlink" title="运行与测试"></a>运行与测试</h1><h2 id="启动应用"><a href="#启动应用" class="headerlink" title="启动应用"></a>启动应用</h2><ol><li>右键 <code>SpringBootDemoApplication → Run &#39;SpringBootDemoApplication&#39;</code> 或者使用 IDEA 工具栏的运行按钮。</li><li>查看控制台输出：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  .   ____          _            __ _ _</span><br><span class="line"> /\\ / ___&#x27;_ __ _ _(_)_ __  __ _ \ \ \ \</span><br><span class="line">( ( )\___ | &#x27;_ | &#x27;_| | &#x27;_ \/ _` | \ \ \ \</span><br><span class="line"> \\/  ___)| |_)| | | | | || (_| |  ) ) ) )</span><br><span class="line">  &#x27;  |____| .__|_| |_|_| |_\__, | / / / /</span><br><span class="line"> =========|_|==============|___/=/_/_/_/</span><br><span class="line"></span><br><span class="line"> :: Spring Boot ::                (v3.5.0)</span><br><span class="line"></span><br><span class="line">2025-06-15T06:53:46.411+08:00  INFO 22460 --- [SpringBootDemo] [           main] c.c.s.SpringBootDemoApplication          : Starting SpringBootDemoApplication using Java 24.0.1 with PID 22460 (D:\Github\IdeaProjects\SpringBootDemo\target\classes started by win in D:\Github\IdeaProjects\SpringBootDemo)</span><br><span class="line">2025-06-15T06:53:46.413+08:00  INFO 22460 --- [SpringBootDemo] [           main] c.c.s.SpringBootDemoApplication          : No active profile set, falling back to 1 default profile: &quot;default&quot;</span><br><span class="line">2025-06-15T06:53:46.865+08:00  INFO 22460 --- [SpringBootDemo] [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat initialized with port 9090 (http)</span><br><span class="line">2025-06-15T06:53:46.875+08:00  INFO 22460 --- [SpringBootDemo] [           main] o.apache.catalina.core.StandardService   : Starting service [Tomcat]</span><br><span class="line">2025-06-15T06:53:46.875+08:00  INFO 22460 --- [SpringBootDemo] [           main] o.apache.catalina.core.StandardEngine    : Starting Servlet engine: [Apache Tomcat/10.1.41]</span><br><span class="line">2025-06-15T06:53:46.904+08:00  INFO 22460 --- [SpringBootDemo] [           main] o.a.c.c.C.[Tomcat].[localhost].[/demo]   : Initializing Spring embedded WebApplicationContext</span><br><span class="line">2025-06-15T06:53:46.904+08:00  INFO 22460 --- [SpringBootDemo] [           main] w.s.c.ServletWebServerApplicationContext : Root WebApplicationContext: initialization completed in 462 ms</span><br><span class="line">2025-06-15T06:53:47.124+08:00  INFO 22460 --- [SpringBootDemo] [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port 9090 (http) with context path &#x27;/demo&#x27;</span><br><span class="line">2025-06-15T06:53:47.129+08:00  INFO 22460 --- [SpringBootDemo] [           main] c.c.s.SpringBootDemoApplication          : Started SpringBootDemoApplication in 1.0 seconds (process running for 1.349)</span><br></pre></td></tr></table></figure></li></ol><h2 id="浏览器访问"><a href="#浏览器访问" class="headerlink" title="浏览器访问"></a>浏览器访问</h2><p>应用启动后，默认端口是 8080。我上文配置文件修改了端口号为 9090，并且设置了 <code>context-path=/demo</code>，所以打开浏览器访问：<a href="http://localhost:9090/demo/hello">http://localhost:9090/demo/hello</a> （默认是：<a href="http://localhost:8080/hello">http://localhost:8080/hello</a>）</p><p>页面输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello Spring Boot 张三 访问成功！</span><br></pre></td></tr></table></figure><h2 id="项目打包部署"><a href="#项目打包部署" class="headerlink" title="项目打包部署"></a>项目打包部署</h2><ol><li><p>bash 执行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成可执行 JAR</span></span><br><span class="line">mvn clean package <span class="comment"># 生成 target/SpringBootDemo-0.0.1-SNAPSHOT.jar</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行应用</span></span><br><span class="line">java -jar target/SpringBootDemo-0.0.1-SNAPSHOT.jar</span><br></pre></td></tr></table></figure></li><li><p>或者直接图形化界面打包：</p></li></ol><img src="/blog/2025/06/12/spring-boot/maven-package.png" class=""><h1 id="常见问题排查"><a href="#常见问题排查" class="headerlink" title="常见问题排查"></a>常见问题排查</h1><ol><li>端口冲突：修改 <code>server.port=9090</code>，默认是 <code>8080</code></li><li>404 错误：<ul><li>检查 <code>@RestController</code> 注解</li><li>确认 URL 包含 <code>context-path</code></li></ul></li><li>依赖下载失败：<ul><li>检查 Maven 镜像配置</li><li>执行 <code>mvn clean install -U</code></li></ul></li></ol><hr>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;本文面向 Java 初学者，详细介绍 Spring Boot 框架原理、应用场景及从零搭建 Web 应用的完整流程。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;Spring-Boot-框架简介&quot;&gt;&lt;a href=&quot;#Spring-Boot-框架简介&quot; class=&quot;headerlink&quot; title=&quot;Spring Boot 框架简介&quot;&gt;&lt;/a&gt;Spring Boot 框架简介&lt;/h1&gt;&lt;h2 id=&quot;基本原理&quot;&gt;&lt;a href=&quot;#基本原理&quot; class=&quot;headerlink&quot; title=&quot;基本原理&quot;&gt;&lt;/a&gt;基本原理&lt;/h2&gt;&lt;p&gt;Spring Boot 是 Spring 框架的扩展，通过 &lt;strong&gt;约定优于配置&lt;/strong&gt; 的理念解决传统 Spring 应用配置复杂的问题，简化 Spring 应用的初始搭建和开发过程。通过自动配置和起步依赖（Starter Dependencies）来减少开发者的配置工作，Spring Boot 内嵌了 Tomcat、Jetty 或 Undertow 等服务器，因此无需部署 WAR 文件即可运行。核心思想是 &lt;strong&gt;让开发更简单&lt;/strong&gt; 。&lt;/p&gt;
&lt;h2 id=&quot;核心特性&quot;&gt;&lt;a href=&quot;#核心特性&quot; class=&quot;headerlink&quot; title=&quot;核心特性&quot;&gt;&lt;/a&gt;核心特性&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;自动配置&lt;/strong&gt;：通过 &lt;code&gt;@EnableAutoConfiguration&lt;/code&gt; 自动配置 Bean（基于项目中的 jar 依赖自动配置 Spring 应用）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;起步依赖&lt;/strong&gt;：通过提供预定义的依赖描述符（如 &lt;code&gt;spring-boot-starter-web&lt;/code&gt; 包含了开发 Web 应用所需的依赖）简化构建配置，解决版本冲突。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;内嵌服务&lt;/strong&gt;：内置 Tomcat/Jetty/Undertow 等服务器，无需部署 WAR，直接运行一个独立的应用即可。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Actuator&lt;/strong&gt;：提供生产级监控和管理功能，如监控应用的健康状况、信息查看等。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;工作原理&quot;&gt;&lt;a href=&quot;#工作原理&quot; class=&quot;headerlink&quot; title=&quot;工作原理&quot;&gt;&lt;/a&gt;工作原理&lt;/h2&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[启动类] → [@SpringBootApplication] &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    → 扫描 @Component → 加载 @Configuration &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    → 读取 spring.factories → 应用自动配置&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    → 启动内嵌容器&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h2 id=&quot;应用场景&quot;&gt;&lt;a href=&quot;#应用场景&quot; class=&quot;headerlink&quot; title=&quot;应用场景&quot;&gt;&lt;/a&gt;应用场景&lt;/h2&gt;&lt;p&gt;Spring Boot 适用于构建微服务架构、RESTful API、企业级应用等。&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="https://www.cylong.com/categories/Java/"/>
    
    
    <category term="Java" scheme="https://www.cylong.com/tags/Java/"/>
    
    <category term="Spring" scheme="https://www.cylong.com/tags/Spring/"/>
    
    <category term="SpringBoot" scheme="https://www.cylong.com/tags/SpringBoot/"/>
    
    <category term="JavaWeb" scheme="https://www.cylong.com/tags/JavaWeb/"/>
    
    <category term="后端框架" scheme="https://www.cylong.com/tags/%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6/"/>
    
    <category term="RESTfulAPI" scheme="https://www.cylong.com/tags/RESTfulAPI/"/>
    
  </entry>
  
  <entry>
    <title>动态规划求解最大子数组和（LeetCode 53）</title>
    <link href="https://www.cylong.com/blog/2025/06/09/maximum-subarray/"/>
    <id>https://www.cylong.com/blog/2025/06/09/maximum-subarray/</id>
    <published>2025-06-09T14:40:57.000Z</published>
    <updated>2025-06-09T14:40:57.000Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给你一个整数数组 <code>nums</code> ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p><strong>子数组</strong> 是数组中的一个连续部分。</p><p><strong>示例 1:</strong></p><blockquote><p><strong>输入：</strong><code>nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]</code><br><strong>输出：</strong>6<br><strong>解释：</strong>连续子数组 <code>[4, -1, 2, 1]</code> 的和最大，为 <code>6</code> 。</p></blockquote><p><strong>示例 2:</strong></p><blockquote><p><strong>输入：</strong><code>nums = [1]</code><br><strong>输出：</strong>1</p></blockquote><p><strong>示例 3:</strong></p><blockquote><p><strong>输入：</strong><code>nums = [5, 4, -1, 7, 8]</code><br><strong>输出：</strong>23</p></blockquote><p><strong>提示:</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 10^5</code></li><li><code>-10^4 &lt;= nums[i] &lt;= 10^4</code></li></ul><span id="more"></span><h1 id="暴力枚举"><a href="#暴力枚举" class="headerlink" title="暴力枚举"></a>暴力枚举</h1><p>最简单的思路，通过两层循环遍历所有可能的连续子数组，计算每个子数组的和并记录最大值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; nums.length; j++) &#123;</span><br><span class="line">            sum += nums[j];</span><br><span class="line">            max = Math.max(max, sum);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li><strong>时间复杂度：</strong><code>O(n²)</code>，其中 <code>n</code> 是数组长度。需要两层循环遍历所有子数组。</li><li><strong>空间复杂度：</strong><code>O(1)</code>，仅使用常数级别的额外空间。</li></ul><h1 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h1><p>参考前缀和的定义：<a href="/blog/2025/06/03/range-sum-query-immutable/" title="前缀和解法实现区间和查询（LeetCode 303） | 笑话人生">前缀和解法实现区间和查询（LeetCode 303） | 笑话人生</a></p><p>利用前缀和的思想，由于子数组的元素和等于两个前缀和的差，遍历数组计算前缀和，同时维护当前最小前缀和。最大子数组和即为当前前缀和与最小前缀和的差值的最大值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">prefixSum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">minPrefixSum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        prefixSum += nums[i];</span><br><span class="line">        max = Math.max(max, prefixSum - minPrefixSum);</span><br><span class="line">        minPrefixSum = Math.min(minPrefixSum, prefixSum);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li><strong>时间复杂度：</strong><code>O(n)</code>，只需一次遍历数组。</li><li><strong>空间复杂度：</strong><code>O(1)</code>，仅使用常数级别的额外空间。</li></ul><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p>定义 <code>dp[i]</code> 表示以 <code>nums[i]</code> 结尾的最大子数组和。状态转移方程为：<code>dp[i] = Math.max(dp[i - 1], 0) + nums[i]</code>。最终结果为 <code>dp</code> 数组中的最大值。可以简单的理解为，如果 <code>nums[i]</code> 左边的子数组和 <code>dp[i - 1] &lt; 0</code>，那么加上 <code>nums[i]</code> 的值会导致子数组和更小，所以这个时候取 <code>nums[i]</code> 的值即可，否则就将 <code>nums[i]</code> 的值加入 <code>dp[i - 1]</code> 的子数组和。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">    dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> dp[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        dp[i] = Math.max(dp[i - <span class="number">1</span>], <span class="number">0</span>) + nums[i];</span><br><span class="line">        max = Math.max(max, dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li><strong>时间复杂度：</strong><code>O(n)</code>，只需一次遍历数组。</li><li><strong>空间复杂度：</strong><code>O(n)</code>，需要额外的 <code>dp</code> 数组存储中间结果。</li></ul><h1 id="动态规划（空间优化）"><a href="#动态规划（空间优化）" class="headerlink" title="动态规划（空间优化）"></a>动态规划（空间优化）</h1><p>在以上动态规划的基础上进行空间优化。由于 <code>dp[i]</code> 只依赖于 <code>dp[i - 1]</code>，因此可以用一个变量代替 <code>dp</code> 数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">dp</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        dp = Math.max(dp, <span class="number">0</span>) + nums[i];</span><br><span class="line">        max = Math.max(max, dp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析-3"><a href="#复杂度分析-3" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li><strong>时间复杂度：</strong><code>O(n)</code>，只需一次遍历数组。</li><li><strong>空间复杂度：</strong><code>O(1)</code>，仅使用常数级别的额外空间。</li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><table><thead><tr><th>解法</th><th>时间复杂度</th><th>空间复杂度</th><th>特点</th></tr></thead><tbody><tr><td>暴力枚举</td><td>O(n²)</td><td>O(1)</td><td>思路简单，效率低</td></tr><tr><td>前缀和</td><td>O(n)</td><td>O(1)</td><td>利用前缀和思想</td></tr><tr><td>动态规划</td><td>O(n)</td><td>O(n)</td><td>标准动态规划解法</td></tr><tr><td>动态规划优化</td><td>O(n)</td><td>O(1)</td><td>最优解法，推荐使用</td></tr></tbody></table><h1 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h1><blockquote><p><a href="https://leetcode.cn/problems/maximum-subarray/description/" title="53. 最大子数组和 | 力扣（LeetCode）">53. 最大子数组和 | 力扣（LeetCode）</a><br><a href="https://leetcode.cn/problems/maximum-subarray/solutions/2533977/qian-zhui-he-zuo-fa-ben-zhi-shi-mai-mai-abu71/?envType=study-plan-v2&envId=top-100-liked" title="53. 最大子数组和 | 题解 | 灵茶山艾府">53. 最大子数组和 | 题解 | 灵茶山艾府</a></p></blockquote><hr>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;p&gt;给你一个整数数组 &lt;code&gt;nums&lt;/code&gt; ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;子数组&lt;/strong&gt; 是数组中的一个连续部分。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt;&lt;code&gt;nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]&lt;/code&gt;&lt;br&gt;&lt;strong&gt;输出：&lt;/strong&gt;6&lt;br&gt;&lt;strong&gt;解释：&lt;/strong&gt;连续子数组 &lt;code&gt;[4, -1, 2, 1]&lt;/code&gt; 的和最大，为 &lt;code&gt;6&lt;/code&gt; 。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例 2:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt;&lt;code&gt;nums = [1]&lt;/code&gt;&lt;br&gt;&lt;strong&gt;输出：&lt;/strong&gt;1&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;示例 3:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;输入：&lt;/strong&gt;&lt;code&gt;nums = [5, 4, -1, 7, 8]&lt;/code&gt;&lt;br&gt;&lt;strong&gt;输出：&lt;/strong&gt;23&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;提示:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;1 &amp;lt;= nums.length &amp;lt;= 10^5&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-10^4 &amp;lt;= nums[i] &amp;lt;= 10^4&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://www.cylong.com/categories/LeetCode/"/>
    
    
    <category term="Java" scheme="https://www.cylong.com/tags/Java/"/>
    
    <category term="LeetCode" scheme="https://www.cylong.com/tags/LeetCode/"/>
    
    <category term="学习笔记" scheme="https://www.cylong.com/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="数组" scheme="https://www.cylong.com/tags/%E6%95%B0%E7%BB%84/"/>
    
    <category term="动态规划" scheme="https://www.cylong.com/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="LeetCode中等" scheme="https://www.cylong.com/tags/LeetCode%E4%B8%AD%E7%AD%89/"/>
    
    <category term="前缀和" scheme="https://www.cylong.com/tags/%E5%89%8D%E7%BC%80%E5%92%8C/"/>
    
    <category term="子数组" scheme="https://www.cylong.com/tags/%E5%AD%90%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
</feed>
